<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Soletta machine learning: Engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta machine learning
   </div>
   <div id="projectbrief">Machine learning for IoT devices</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Engine</div>  </div>
</div><!--header-->
<div class="contents">

<p>The SML common functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsml__object.html">sml_object</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsml__variable.html">sml_variable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsml__variables__list.html">sml_variables_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga73b5e618b9272841c899b8e78a98d122"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga73b5e618b9272841c899b8e78a98d122">SML_INTERNAL_ERROR</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ga73b5e618b9272841c899b8e78a98d122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea1a1485a4b6e53c829492de697e6f4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#gaea1a1485a4b6e53c829492de697e6f4d">SML_VARIABLE_NAME_MAX_LEN</a>&#160;&#160;&#160;(127)</td></tr>
<tr class="separator:gaea1a1485a4b6e53c829492de697e6f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6349ef49f41d94ccfa8d362bbd958117"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga6349ef49f41d94ccfa8d362bbd958117">sml_change_cb</a> )(struct <a class="el" href="structsml__object.html">sml_object</a> *sml, struct <a class="el" href="structsml__variables__list.html">sml_variables_list</a> *changed, void *data)</td></tr>
<tr class="memdesc:ga6349ef49f41d94ccfa8d362bbd958117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called every time the SML made a prediction.  <a href="#ga6349ef49f41d94ccfa8d362bbd958117">More...</a><br/></td></tr>
<tr class="separator:ga6349ef49f41d94ccfa8d362bbd958117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ef56f676a34fed70aa4354ee6a03ef"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga40ef56f676a34fed70aa4354ee6a03ef">sml_read_state_cb</a> )(struct <a class="el" href="structsml__object.html">sml_object</a> *sml, void *data)</td></tr>
<tr class="memdesc:ga40ef56f676a34fed70aa4354ee6a03ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">A user defined callback to read the variables values.  <a href="#ga40ef56f676a34fed70aa4354ee6a03ef">More...</a><br/></td></tr>
<tr class="separator:ga40ef56f676a34fed70aa4354ee6a03ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5ac61c2611d8edee2d46976723e5a0ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga5ac61c2611d8edee2d46976723e5a0ce">sml_erase_knowledge</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml)</td></tr>
<tr class="memdesc:ga5ac61c2611d8edee2d46976723e5a0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all previous knowledge.  <a href="#ga5ac61c2611d8edee2d46976723e5a0ce">More...</a><br/></td></tr>
<tr class="separator:ga5ac61c2611d8edee2d46976723e5a0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14164ad22163f4e4864af9c2aa9f765d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga14164ad22163f4e4864af9c2aa9f765d">sml_free</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml)</td></tr>
<tr class="memdesc:ga14164ad22163f4e4864af9c2aa9f765d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the SML engine.  <a href="#ga14164ad22163f4e4864af9c2aa9f765d">More...</a><br/></td></tr>
<tr class="separator:ga14164ad22163f4e4864af9c2aa9f765d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c035ab8d8979d1f6ffbe606ba350912"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga3c035ab8d8979d1f6ffbe606ba350912">sml_load</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, const char *path)</td></tr>
<tr class="memdesc:ga3c035ab8d8979d1f6ffbe606ba350912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the SML state from the disk.  <a href="#ga3c035ab8d8979d1f6ffbe606ba350912">More...</a><br/></td></tr>
<tr class="separator:ga3c035ab8d8979d1f6ffbe606ba350912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e26b827843ef8c01c41f5c91bcde8b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga5e26b827843ef8c01c41f5c91bcde8b3">sml_load_debug_log_file</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, const char *str)</td></tr>
<tr class="memdesc:ga5e26b827843ef8c01c41f5c91bcde8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load to current engine the debug data logged to a file.  <a href="#ga5e26b827843ef8c01c41f5c91bcde8b3">More...</a><br/></td></tr>
<tr class="separator:ga5e26b827843ef8c01c41f5c91bcde8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0bac26c3478a21ead267fc2856b73b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#gaa0bac26c3478a21ead267fc2856b73b0">sml_load_fll_file</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, const char *filename)</td></tr>
<tr class="memdesc:gaa0bac26c3478a21ead267fc2856b73b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a FLL file.  <a href="#gaa0bac26c3478a21ead267fc2856b73b0">More...</a><br/></td></tr>
<tr class="separator:gaa0bac26c3478a21ead267fc2856b73b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae83e25b9547a8e4dea1ad7406aade425"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#gae83e25b9547a8e4dea1ad7406aade425">sml_predict</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml)</td></tr>
<tr class="memdesc:gae83e25b9547a8e4dea1ad7406aade425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a prediction based on the most recent observations.  <a href="#gae83e25b9547a8e4dea1ad7406aade425">More...</a><br/></td></tr>
<tr class="separator:gae83e25b9547a8e4dea1ad7406aade425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34004baa7332a15b3b62ed2568df53ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga34004baa7332a15b3b62ed2568df53ad">sml_print_debug</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, bool full)</td></tr>
<tr class="memdesc:ga34004baa7332a15b3b62ed2568df53ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints SML debug information.  <a href="#ga34004baa7332a15b3b62ed2568df53ad">More...</a><br/></td></tr>
<tr class="separator:ga34004baa7332a15b3b62ed2568df53ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga248e5631778d5fd464f1acff1b05aec9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga248e5631778d5fd464f1acff1b05aec9">sml_process</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml)</td></tr>
<tr class="memdesc:ga248e5631778d5fd464f1acff1b05aec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process variables and make predictions.  <a href="#ga248e5631778d5fd464f1acff1b05aec9">More...</a><br/></td></tr>
<tr class="separator:ga248e5631778d5fd464f1acff1b05aec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga322a9082bd6bd886a1edcb5cb716b4cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga322a9082bd6bd886a1edcb5cb716b4cf">sml_save</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, const char *path)</td></tr>
<tr class="memdesc:ga322a9082bd6bd886a1edcb5cb716b4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the SML state on the disk.  <a href="#ga322a9082bd6bd886a1edcb5cb716b4cf">More...</a><br/></td></tr>
<tr class="separator:ga322a9082bd6bd886a1edcb5cb716b4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046c466002ca3b34ade8e082fc917b32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga046c466002ca3b34ade8e082fc917b32">sml_set_debug_log_file</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, const char *str)</td></tr>
<tr class="memdesc:ga046c466002ca3b34ade8e082fc917b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file to be used to debug data changes in this engine.  <a href="#ga046c466002ca3b34ade8e082fc917b32">More...</a><br/></td></tr>
<tr class="separator:ga046c466002ca3b34ade8e082fc917b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga299d0d3f3d339d92b175a1ce3e2dfb32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga299d0d3f3d339d92b175a1ce3e2dfb32">sml_set_learn_disabled</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, bool disable)</td></tr>
<tr class="memdesc:ga299d0d3f3d339d92b175a1ce3e2dfb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the SML learning.  <a href="#ga299d0d3f3d339d92b175a1ce3e2dfb32">More...</a><br/></td></tr>
<tr class="separator:ga299d0d3f3d339d92b175a1ce3e2dfb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa706ae97781261caa097ed79cc6f827"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#gafa706ae97781261caa097ed79cc6f827">sml_set_max_memory_for_observations</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, unsigned int max_size)</td></tr>
<tr class="memdesc:gafa706ae97781261caa097ed79cc6f827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum memory that can be used to store observation history data.  <a href="#gafa706ae97781261caa097ed79cc6f827">More...</a><br/></td></tr>
<tr class="separator:gafa706ae97781261caa097ed79cc6f827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66335a825f0dffe082caa4dcb0f0ccd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga66335a825f0dffe082caa4dcb0f0ccd6">sml_set_output_state_changed_callback</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, <a class="el" href="group__Engine.html#ga6349ef49f41d94ccfa8d362bbd958117">sml_change_cb</a> output_state_changed_cb, void *data)</td></tr>
<tr class="memdesc:ga66335a825f0dffe082caa4dcb0f0ccd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a change callback.  <a href="#ga66335a825f0dffe082caa4dcb0f0ccd6">More...</a><br/></td></tr>
<tr class="separator:ga66335a825f0dffe082caa4dcb0f0ccd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf3b2d7d461ec2d907ae2d61df3401db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#gaaf3b2d7d461ec2d907ae2d61df3401db">sml_set_read_state_callback</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, <a class="el" href="group__Engine.html#ga40ef56f676a34fed70aa4354ee6a03ef">sml_read_state_cb</a> read_state_cb, void *data)</td></tr>
<tr class="memdesc:gaaf3b2d7d461ec2d907ae2d61df3401db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a read callblack.  <a href="#gaaf3b2d7d461ec2d907ae2d61df3401db">More...</a><br/></td></tr>
<tr class="separator:gaaf3b2d7d461ec2d907ae2d61df3401db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca270ea3de40c6c98333e0c82f8a9a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Engine.html#ga7ca270ea3de40c6c98333e0c82f8a9a0">sml_set_stabilization_hits</a> (struct <a class="el" href="structsml__object.html">sml_object</a> *sml, uint16_t hits)</td></tr>
<tr class="memdesc:ga7ca270ea3de40c6c98333e0c82f8a9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stabilization hits.  <a href="#ga7ca270ea3de40c6c98333e0c82f8a9a0">More...</a><br/></td></tr>
<tr class="separator:ga7ca270ea3de40c6c98333e0c82f8a9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The SML common functions. </p>
<p>The functions here are common to all engines. They are used to free the engines, create variables, save/load SML state and more.</p>
<p>The SML main flow consist in the following steps:</p>
<ul>
<li>Choose an engine (ANN or Fuzzy).</li>
<li>Create the inputs and outputs variables.</li>
<li>Register the read callback.</li>
<li>Register the change callback.</li>
<li>Read the variable value, set it in SML and call process.</li>
</ul>
<p>As a simple example imagine that one wants to control an indoor light that turns on automatically if a person enters in the room and goes off if the person leaves. For that, this person has a presence sensor.</p>
<p>Choosing engines and creating variables is straight-forward after the solution is modeled. Let's say fuzzy was the chosen one. Registering callbacks is simple as well:</p>
 <div class="fragment"><div class="line">main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="structsml__object.html">sml_object</a> *sml;</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="structsml__variable.html">sml_variable</a> *sensor, *light;</div>
<div class="line"></div>
<div class="line">    sml = <a class="code" href="group__Fuzzy__Engine.html#ga841716f69b32d5a83aee2c50a6f85b90">sml_fuzzy_new</a>();</div>
<div class="line"></div>
<div class="line">    sensor = <a class="code" href="group__Variables.html#gaedea90b59879608901166cc6d8ed2634">sml_new_input</a>(sml, <span class="stringliteral">&quot;PresenceSensor&quot;</span>);</div>
<div class="line">    <a class="code" href="group__Variables.html#ga93382249e110f0459dc3e23532db97e2">sml_variable_set_range</a>(sml, sensor, 0, 1);</div>
<div class="line">    <a class="code" href="group__Fuzzy__Engine.html#gab0040c7f41f262db052b99511f3c5989">sml_fuzzy_variable_set_default_term_width</a>(sml, sensor, 0.5);</div>
<div class="line"></div>
<div class="line">    light = <a class="code" href="group__Variables.html#ga85cd8a36a1f0ad5fd22bc07bec4cb255">sml_new_output</a>(sml, <span class="stringliteral">&quot;Light&quot;</span>);</div>
<div class="line">    <a class="code" href="group__Variables.html#ga93382249e110f0459dc3e23532db97e2">sml_variable_set_range</a>(sml, light, 0, 1);</div>
<div class="line">    <a class="code" href="group__Fuzzy__Engine.html#gab0040c7f41f262db052b99511f3c5989">sml_fuzzy_variable_set_default_term_width</a>(sml, light, 0.5);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__Engine.html#gaaf3b2d7d461ec2d907ae2d61df3401db">sml_set_read_state_callback</a>(sml, read_state_cb, NULL);</div>
<div class="line">    <a class="code" href="group__Engine.html#ga66335a825f0dffe082caa4dcb0f0ccd6">sml_set_output_state_changed_callback</a>(sml, output_state_changed_cb, NULL);</div>
</div><!-- fragment --></p>
<p>Terms are a way to split the values in the range in meaningful parts. Fuzzy supports some functions to describe them, as ramps, triangles and others.</p>
<p>Although we have the possibility to define each term to describe your problem, for this example we will let the fuzzy engine do this for you. To improve the quality of the automatically created terms, we need to give fuzzy engine some hints about the variable being used. As both variables are boolean values, lets set the default term width to 0.5 and the range from 0 to 1. So we will have 2 terms, one for on and another for off.</p>
<p>After everything is set up, it's time to trigger the processing. It will be done in a simple loop, making 150 <a class="el" href="group__Engine.html#ga248e5631778d5fd464f1acff1b05aec9" title="Process variables and make predictions. ">sml_process()</a> calls, but more elaborated ways to call process() can be implemented, using mainloops.</p>
<p><div class="fragment"><div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 150; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__Engine.html#ga248e5631778d5fd464f1acff1b05aec9">sml_process</a>(sml) &lt; 0) {</div>
<div class="line">            printf(<span class="stringliteral">&quot;Failed to process\n&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__Engine.html#ga14164ad22163f4e4864af9c2aa9f765d">sml_free</a>(sml);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>Read and change callbacks implementation varies a lot depending on machine learning usage, since they're the interface with the rest of the world.</p>
<p>Read callback is a function that will be called at each processing cycle to update variables values.</p>
<p>So in this function the values of presence sensor and light must to be fetched. It could be done via GPIO, OIC, or any other way, depending in your product. It may be synchronous or asynchronous.</p>
<p>To keep it simple, yet illustrative, we're going to simulate the values in a function read_state_cb() Variable sensor_state represents presence sensor reading, switch_state represents light state.</p>
<p>This variable will be global since its going to be used by the callback of state changes (you could use a struct with this variable and pass them to callbacks).</p>
<p>To simulate a daily based used, a day would be a cycle of 15 readings, user will be present on last 5 readings of each "day". When she leaves she remembers to turn lights off... most of the time. This is simulated by off_count . When she forgets lights on and leaves, machine learning should suggest to turn lights off.</p>
<p>After states are "fetch", they're set on sml variables (input and output).</p>
 <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> switch_state = 0;</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span></div>
<div class="line">read_state_cb(<span class="keyword">struct</span> <a class="code" href="structsml__object.html">sml_object</a> *sml, <span class="keywordtype">void</span> *data)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="structsml__variables__list.html">sml_variables_list</a> *inputs, *outputs;</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="structsml__variable.html">sml_variable</a> *sensor, *light;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> sensor_state = 0;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> off_count = 0;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* user is present after 10 reads */</span></div>
<div class="line">    <span class="keywordflow">if</span> (count == 10) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;User got in the room.\n&quot;</span>);</div>
<div class="line">        sensor_state = 1;</div>
<div class="line">        switch_state = 1;</div>
<div class="line">        count++;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* and stay there for 5 more reads */</span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count == 15) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;User left the room.\n&quot;</span>);</div>
<div class="line">        off_count++;</div>
<div class="line">        sensor_state = 0;</div>
<div class="line">        <span class="comment">/* most of times she remembers to swith off lights</span></div>
<div class="line"><span class="comment">         * when she leaves */</span></div>
<div class="line">        <span class="keywordflow">if</span> (off_count % 4 == 0) {</div>
<div class="line">            printf(<span class="stringliteral">&quot;Oops! User forgot to turn lights off.\n&quot;</span>);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            switch_state = 0;</div>
<div class="line">        }</div>
<div class="line">        count = 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* ... forever on this cycle */</span></div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        count++;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    inputs = <a class="code" href="group__Variables.html#ga72d504d78250921f4df9990542fb70c2">sml_get_input_list</a>(sml);</div>
<div class="line">    sensor = <a class="code" href="group__Variables.html#gaac78b244b8d3f1ff9beff5cc4703a546">sml_variables_list_index</a>(sml, inputs, 0);</div>
<div class="line">    <a class="code" href="group__Variables.html#gae5352079e72f1edfa64de77faf9f7221">sml_variable_set_value</a>(sml, sensor, sensor_state);</div>
<div class="line"></div>
<div class="line">    outputs = <a class="code" href="group__Variables.html#gaa4694d6f3a55bbab1299502466c010c3">sml_get_output_list</a>(sml);</div>
<div class="line">    light = <a class="code" href="group__Variables.html#gaac78b244b8d3f1ff9beff5cc4703a546">sml_variables_list_index</a>(sml, outputs, 0);</div>
<div class="line">    <a class="code" href="group__Variables.html#gae5352079e72f1edfa64de77faf9f7221">sml_variable_set_value</a>(sml, light, switch_state);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>To fetch predicted output values, it's required to set a callback function using <a class="el" href="group__Engine.html#ga66335a825f0dffe082caa4dcb0f0ccd6" title="Register a change callback. ">sml_set_output_state_changed_callback()</a></p>
<p>This callback will be called when SML makes a prediction for at least one output variable.</p>
<p>Change state callback only will be called on output value changes. But most of the time, this prediction should matches current state of output variable. On this case no action must to be taken. Also, sometimes SML doesn't have enough information to make a prediction, setting output variable value to NaN.</p>
<p>So in change state callback we're going to check first if it was able to predict a value, then check if we need to act, in case prediction and current light state diverges.</p>
<p>In this example we'll just print a message informing the light state should be changed.</p>
<p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div>
<div class="line">output_state_changed_cb(<span class="keyword">struct</span> <a class="code" href="structsml__object.html">sml_object</a> *sml,</div>
<div class="line">    <span class="keyword">struct</span> <a class="code" href="structsml__variables__list.html">sml_variables_list</a> *changed, <span class="keywordtype">void</span> *data)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="structsml__variable.html">sml_variable</a> *light;</div>
<div class="line">    <span class="keywordtype">double</span> prediction;</div>
<div class="line"></div>
<div class="line">    light = <a class="code" href="group__Variables.html#gaac78b244b8d3f1ff9beff5cc4703a546">sml_variables_list_index</a>(sml, changed, 0);</div>
<div class="line">    prediction = <a class="code" href="group__Variables.html#gad594115ed1b2eea6a5cbf5838867c684">sml_variable_get_value</a>(sml, light);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* When SML can&#39;t predict a value, it&#39;ll be set to NaN */</span></div>
<div class="line">    <span class="keywordflow">if</span> (isnan(prediction)) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Sorry, can&#39;t predict light state.\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* prediction is equal to current state */</span></div>
<div class="line">    <span class="keywordflow">if</span> ((prediction &gt; 0.5) == switch_state) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (prediction &gt; 0.5) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Light should be turned ON.\n&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Light should be turned OFF.\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>A few tips to obtain good predictions.</p>
<ul>
<li>Do not try to control the whole world with one SML object.</li>
<li>If you want to control a light and an air-conditioning and they are independent of each other. Create two SML objects, one will control the light and another one the air-conditioning.</li>
<li>Try to avoid adding unnecessary inputs/outputs to SML (or forget to add relevant inputs/outputs), this may lead the poor predictions.</li>
<li>Test both engines and check which one has the best results for your problem. </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga73b5e618b9272841c899b8e78a98d122"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SML_INTERNAL_ERROR&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SML error code. Could not complete an operation </p>

</div>
</div>
<a class="anchor" id="gaea1a1485a4b6e53c829492de697e6f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SML_VARIABLE_NAME_MAX_LEN&#160;&#160;&#160;(127)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum size of variables name </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga6349ef49f41d94ccfa8d362bbd958117"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sml_change_cb)(struct <a class="el" href="structsml__object.html">sml_object</a> *sml, struct <a class="el" href="structsml__variables__list.html">sml_variables_list</a> *changed, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called every time the SML made a prediction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> Object. </td></tr>
    <tr><td class="paramname">changed</td><td>A <a class="el" href="structsml__variables__list.html">sml_variables_list</a> with the predicted variables. </td></tr>
    <tr><td class="paramname">data</td><td>User defined data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Engine.html#ga66335a825f0dffe082caa4dcb0f0ccd6" title="Register a change callback. ">sml_set_output_state_changed_callback</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga40ef56f676a34fed70aa4354ee6a03ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* sml_read_state_cb)(struct <a class="el" href="structsml__object.html">sml_object</a> *sml, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A user defined callback to read the variables values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object </td></tr>
    <tr><td class="paramname">data</td><td>The user defined data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> if no reads were done. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Engine.html#gaaf3b2d7d461ec2d907ae2d61df3401db" title="Register a read callblack. ">sml_set_read_state_callback</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5ac61c2611d8edee2d46976723e5a0ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_erase_knowledge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all previous knowledge. </p>
<p>Erases everything that the SML has learned, this will required that the SML is trained again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14164ad22163f4e4864af9c2aa9f765d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sml_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the SML engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The engine to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3c035ab8d8979d1f6ffbe606ba350912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_load </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the SML state from the disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">path</td><td>A direcoty to load the engine files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> on failure. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Engine.html#ga322a9082bd6bd886a1edcb5cb716b4cf" title="Save the SML state on the disk. ">sml_save</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e26b827843ef8c01c41f5c91bcde8b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_load_debug_log_file </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load to current engine the debug data logged to a file. </p>
<p>Load all data logged in file set by <a class="el" href="group__Engine.html#ga046c466002ca3b34ade8e082fc917b32" title="Set the file to be used to debug data changes in this engine. ">sml_set_debug_log_file</a> to current engine. Used for debug purposes.</p>
<p>To use this feature, sml must be compiled with build type set to Debug.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">str</td><td>A string with full path of file to be used to load debug data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>@ true if loading debug was successful. <code>false</code> if operation failed or if sml was not compiled using Debug build type.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Engine.html#ga046c466002ca3b34ade8e082fc917b32" title="Set the file to be used to debug data changes in this engine. ">sml_set_debug_log_file</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0bac26c3478a21ead267fc2856b73b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_load_fll_file </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a FLL file. </p>
<p>FLL stands for Fuzzylite language. It can be used to create/change the fuzzy terms/defuzzifiers without using the SML apis.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the function is used on an already running SML engine, all the previous knowledge will be lost!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">filename</td><td>A fll file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gae83e25b9547a8e4dea1ad7406aade425"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_predict </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a prediction based on the most recent observations. </p>
<p>This is useful for making predictions without the normal SML flow, without a mainloop and a registered <a class="el" href="group__Engine.html#ga6349ef49f41d94ccfa8d362bbd958117" title="Called every time the SML made a prediction. ">sml_change_cb</a>. Take a look in the following example:</p>
<div class="fragment"><div class="line"><span class="comment">//A simple example that will turn the light on if someone is in the room.</span></div>
<div class="line"><span class="keyword">struct </span>sml_variale PresenveVar, LightStateVar;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structsml__object.html">sml_object</a> struct smlobject;</div>
<div class="line">ARandomLightClass MyLight;</div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">sml_variable_set_value(<span class="keyword">struct</span> smlobject, PresenceVar, 1.0); <span class="comment">//User is present</span></div>
<div class="line"><a class="code" href="group__Engine.html#gae83e25b9547a8e4dea1ad7406aade425">sml_predict</a>(<span class="keyword">struct</span> smlobject);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__Variables.html#gad594115ed1b2eea6a5cbf5838867c684">sml_variable_get_value</a>(<span class="keyword">struct</span> smlobject, LightStateVar) == 1.0) <span class="comment">//Should be on</span></div>
<div class="line"> light_api_set_On(MyLight);</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line"> light_api_set_Off(MyLight);</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="group__Engine.html#ga6349ef49f41d94ccfa8d362bbd958117" title="Called every time the SML made a prediction. ">sml_change_cb</a> and <a class="el" href="group__Engine.html#ga40ef56f676a34fed70aa4354ee6a03ef" title="A user defined callback to read the variables values. ">sml_read_state_cb</a> won't be called ! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34004baa7332a15b3b62ed2568df53ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sml_print_debug </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints SML debug information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">full</td><td><code>true</code> for full log, <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga248e5631778d5fd464f1acff1b05aec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sml_process </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process variables and make predictions. </p>
<p>This function is used to read the variables via <a class="el" href="group__Engine.html#ga40ef56f676a34fed70aa4354ee6a03ef" title="A user defined callback to read the variables values. ">sml_read_state_cb</a>, process them and call <a class="el" href="group__Engine.html#ga6349ef49f41d94ccfa8d362bbd958117" title="Called every time the SML made a prediction. ">sml_change_cb</a> if necessary.</p>
<dl class="section remark"><dt>Remarks</dt><dd>It's required to set a read callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>::0 on success </dd>
<dd>
A negative value on failure. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Engine.html#gaaf3b2d7d461ec2d907ae2d61df3401db" title="Register a read callblack. ">sml_set_read_state_callback</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga322a9082bd6bd886a1edcb5cb716b4cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_save </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the SML state on the disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">path</td><td>A direcoty to save the engine files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> on failure. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Engine.html#ga3c035ab8d8979d1f6ffbe606ba350912" title="Load the SML state from the disk. ">sml_load</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga046c466002ca3b34ade8e082fc917b32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_set_debug_log_file </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the file to be used to debug data changes in this engine. </p>
<p>This file will be used to log all calls to methods that changes the current state of the sml engine data. This information may be used to reproduce the execution of sml for debug purposes. Methods that configure the sml are not logged.</p>
<p>To use this feature, sml must be compiled with build type set to Debug.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">str</td><td>A string with full path of file to be used to write debug data. Use <code>NULL</code> or an empty string to disable data debug. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>@ true if debug file was updated successfully. <code>false</code> if operation failed or if sml was not compiled using Debug build type.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Engine.html#ga5e26b827843ef8c01c41f5c91bcde8b3" title="Load to current engine the debug data logged to a file. ">sml_load_debug_log_file</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga299d0d3f3d339d92b175a1ce3e2dfb32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_set_learn_disabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the SML learning. </p>
<p>All the reads will be ignore and they will not be used to learn new patterns. However predictions can still be made.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Learning is enabled by default.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">disable</td><td><code>true</code> to disable learn, <code>false</code> otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa706ae97781261caa097ed79cc6f827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_set_max_memory_for_observations </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set maximum memory that can be used to store observation history data. </p>
<dl class="section remark"><dt>Remarks</dt><dd>max_size = 0 means infinite (it is also the default). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">max_size</td><td>Max memory size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga66335a825f0dffe082caa4dcb0f0ccd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_set_output_state_changed_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Engine.html#ga6349ef49f41d94ccfa8d362bbd958117">sml_change_cb</a>&#160;</td>
          <td class="paramname"><em>output_state_changed_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a change callback. </p>
<p>It should be used to set a callback function to fetch the predicted output variables. This callback will be called when the SML makes a prediction for at least on output variable.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If output_state_changed_cb is null previous callback will be unset. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">output_state_changed_cb</td><td>A <a class="el" href="group__Engine.html#ga6349ef49f41d94ccfa8d362bbd958117" title="Called every time the SML made a prediction. ">sml_change_cb</a>. </td></tr>
    <tr><td class="paramname">data</td><td>User data to <a class="el" href="group__Engine.html#ga40ef56f676a34fed70aa4354ee6a03ef" title="A user defined callback to read the variables values. ">sml_read_state_cb</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf3b2d7d461ec2d907ae2d61df3401db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_set_read_state_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Engine.html#ga40ef56f676a34fed70aa4354ee6a03ef">sml_read_state_cb</a>&#160;</td>
          <td class="paramname"><em>read_state_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a read callblack. </p>
<p>It should be used to set a callback function to read variables values. This callback must return true if it was able to read all variables or false on error. If an error happens <a class="el" href="group__Engine.html#ga248e5631778d5fd464f1acff1b05aec9" title="Process variables and make predictions. ">sml_process</a> will be aborted, returning an error value. Otherwise, <a class="el" href="group__Engine.html#ga248e5631778d5fd464f1acff1b05aec9" title="Process variables and make predictions. ">sml_process</a> will proceed with updated variables values.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If read_state_cb is null previous callback will be unset. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">read_state_cb</td><td>A <a class="el" href="group__Engine.html#ga40ef56f676a34fed70aa4354ee6a03ef" title="A user defined callback to read the variables values. ">sml_read_state_cb</a>. </td></tr>
    <tr><td class="paramname">data</td><td>User data to <a class="el" href="group__Engine.html#ga40ef56f676a34fed70aa4354ee6a03ef" title="A user defined callback to read the variables values. ">sml_read_state_cb</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ca270ea3de40c6c98333e0c82f8a9a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sml_set_stabilization_hits </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsml__object.html">sml_object</a> *&#160;</td>
          <td class="paramname"><em>sml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stabilization hits. </p>
<p>Amount of reads without input changes to consider input stable. Only stable inputs are used to run predictions or to train the SML engine. This is necessary to remove noises in read data that could lead to incorrect previsions.</p>
<dl class="section remark"><dt>Remarks</dt><dd>It's defined as 5 reads by default. If set as 0, the input is always considered stable. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sml</td><td>The <a class="el" href="structsml__object.html">sml_object</a> object. </td></tr>
    <tr><td class="paramname">hits</td><td>The number of hits to be considered stable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. </dd>
<dd>
<code>false</code> on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
