<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Soletta: src/lib/common/sol-worker-thread.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta
   </div>
   <div id="projectbrief">Framework for making IoT devices</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bc32ed4505d91e3d9150841baf9e9179.html">src</a></li><li class="navelem"><a class="el" href="dir_bf9fb35a08b1d196a37cadbabea85462.html">lib</a></li><li class="navelem"><a class="el" href="dir_c3ef89f2d660c71b963f9793fd10b8ab.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sol-worker-thread.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="sol-util_8h_source.html">sol-util.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sol-macros_8h_source.html">sol-macros.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sol-worker-thread_8h_source.html">sol-worker-thread.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sol-worker-thread-impl_8h_source.html">sol-worker-thread-impl.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0fff709c92542e88449079103e03f1ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-worker-thread_8c.html#a0fff709c92542e88449079103e03f1ef">SOL_LOG_INTERNAL_DECLARE</a> (<a class="el" href="sol-worker-thread-impl_8h.html#ab6226adee074aabef9c512a8657058c2">_sol_worker_thread_log_domain</a>,&quot;worker-thread&quot;)</td></tr>
<tr class="separator:a0fff709c92542e88449079103e03f1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db418efd497294d26f5d704a8f1a187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Macros.html#ga374770937665ae002bf8d8d352c5cf99">SOL_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-worker-thread_8c.html#a2db418efd497294d26f5d704a8f1a187">sol_worker_thread_cancel</a> (struct sol_worker_thread *thread)</td></tr>
<tr class="separator:a2db418efd497294d26f5d704a8f1a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ba283b909b877287746da77a8cf3dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Macros.html#ga374770937665ae002bf8d8d352c5cf99">SOL_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-worker-thread_8c.html#a12ba283b909b877287746da77a8cf3dd">sol_worker_thread_cancel_check</a> (const struct sol_worker_thread *thread)</td></tr>
<tr class="separator:a12ba283b909b877287746da77a8cf3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28174065c9ef87d7bb7ce5e543214ed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Macros.html#ga374770937665ae002bf8d8d352c5cf99">SOL_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-worker-thread_8c.html#a28174065c9ef87d7bb7ce5e543214ed9">sol_worker_thread_feedback</a> (struct sol_worker_thread *thread)</td></tr>
<tr class="separator:a28174065c9ef87d7bb7ce5e543214ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32686f42dcb8477066858343014d2caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Macros.html#ga374770937665ae002bf8d8d352c5cf99">SOL_API</a> struct sol_worker_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol-worker-thread_8c.html#a32686f42dcb8477066858343014d2caa">sol_worker_thread_new</a> (const struct <a class="el" href="structsol__worker__thread__spec.html">sol_worker_thread_spec</a> *spec)</td></tr>
<tr class="separator:a32686f42dcb8477066858343014d2caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0fff709c92542e88449079103e03f1ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SOL_LOG_INTERNAL_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sol-worker-thread-impl_8h.html#ab6226adee074aabef9c512a8657058c2">_sol_worker_thread_log_domain</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;worker-thread&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2db418efd497294d26f5d704a8f1a187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Macros.html#ga374770937665ae002bf8d8d352c5cf99">SOL_API</a> void sol_worker_thread_cancel </td>
          <td>(</td>
          <td class="paramtype">struct sol_worker_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel a worker thread.</p>
<p>The cancel function will inform the thread it should stop working, there is no preemptive cancellation &ndash; both <code>setup()</code>, <code>iterate()</code> and <code>cleanup()</code> (see <a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a>) will be executed and take the time they need, meanwhile this function will block waiting. After this function is called no further calls to <code>iterate()</code> will be done.</p>
<p>If <a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a> was provided with a <code>cancel()</code> function, then that function will be called prior to any cancellation work. You may use that function to schedule work cancellation in more fine grained fashion in your own code.</p>
<dl class="section note"><dt>Note</dt><dd>this function must be called from the <b>main</b> thread.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>a valid worker thread handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a> </dd></dl>

<p>References <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, and <a class="el" href="sol-worker-thread-impl-glib_8c.html#a9eac75f95fbd6c3bc03f87d5c2fae852">sol_worker_thread_impl_cancel()</a>.</p>

<p>Referenced by <a class="el" href="sol-i2c-impl-linux_8c.html#ac59eaa68bf76445661e8039257ecdd80">sol_i2c_pending_cancel()</a>, and <a class="el" href="group__SPI.html#ga909f9825eb18e480bb5c05ceff4ee458">sol_spi_close()</a>.</p>

</div>
</div>
<a class="anchor" id="a12ba283b909b877287746da77a8cf3dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Macros.html#ga374770937665ae002bf8d8d352c5cf99">SOL_API</a> bool sol_worker_thread_cancel_check </td>
          <td>(</td>
          <td class="paramtype">const struct sol_worker_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a worker thread has been marked as cancelled.</p>
<dl class="section note"><dt>Note</dt><dd>this function may be called from both <b>main</b> and <b>worker</b> thread.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>a valid worker thread handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if worker thread is marked cancelled or <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sol-worker-thread_8h.html#a7d60d6443f27e0c7a4a51fd4171124b6">sol_worker_thread_cancel()</a> </dd></dl>

<p>References <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, and <a class="el" href="sol-worker-thread-impl-glib_8c.html#a7dc84a656e864ca125fde76210988ca9">sol_worker_thread_impl_cancel_check()</a>.</p>

</div>
</div>
<a class="anchor" id="a28174065c9ef87d7bb7ce5e543214ed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Macros.html#ga374770937665ae002bf8d8d352c5cf99">SOL_API</a> void sol_worker_thread_feedback </td>
          <td>(</td>
          <td class="paramtype">struct sol_worker_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule feedback from the worker to the main thread.</p>
<p>This function will schedule a call to <code>feedback()</code> function given to <a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a>. This call is not guaranteed to be executed and multiple calls to <a class="el" href="sol-worker-thread_8h.html#a43d6d9f188545f5cdc1fe27b979c811c">sol_worker_thread_feedback()</a> will not queue, a single one will be done. If queuing is to be done, then do it on your own using locks and a list/array in the <code>data</code> context.</p>
<p>When <code>feedback()</code> is called from the main thread there is no locking of data and the worker thread may be executing both <code>setup()</code>, <code>iterate()</code> or <code>cleanup()</code>.</p>
<dl class="section note"><dt>Note</dt><dd>this function must be called from the <b>worker</b> thread.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>a valid worker thread handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sol-worker-thread_8h.html#a647f164a728db00772ae47afc12d0653">sol_worker_thread_new()</a> </dd></dl>

<p>References <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, and <a class="el" href="sol-worker-thread-impl-glib_8c.html#a0c70ff6de93d3e2ccfe4befde1b83dc7">sol_worker_thread_impl_feedback()</a>.</p>

</div>
</div>
<a class="anchor" id="a32686f42dcb8477066858343014d2caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Macros.html#ga374770937665ae002bf8d8d352c5cf99">SOL_API</a> struct sol_worker_thread* sol_worker_thread_new </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__worker__thread__spec.html">sol_worker_thread_spec</a> *&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and run a worker thread.</p>
<p>Worker threads are meant to do processing that is hard to split and play nice with cooperative workloads used by the main loop (<a class="el" href="group__Mainloop.html#ga36f2bd42167cd7404bf9fb37f166b1b1">sol_idle_add()</a>, <a class="el" href="group__Mainloop.html#ga1e05a71a099eebeac9c2848e3661132b">sol_timeout_add()</a> and sol_fd_add()). Usually this is due blocking operating system calls or third party libraries that don't allow work to be segmented.</p>
<p>Worker threads shouldn't impact the main thread while they execute, but this comes at the trade off of code complexity and synchronization issues. If both the worker thread and the main thread may operate on the same data simultaneously, then it may result in partial reads and writes leading to inconsistent results if locks are not properly done. The best approach is to have the worker thread to operate on its own exclusive data and after it's finished deliver that data to users from within <em>finished</em> callback. If this pattern cannot be used, then employ locks to segments of data that may result into race conditions.</p>
<dl class="section note"><dt>Note</dt><dd>this function must be called from the <b>main</b> thread.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>worker thread specification with functions and context data to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly allocated worker thread handle on success or <code>NULL</code> on errors.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structsol__worker__thread__spec.html" title="Worker thread functions and context data specification. ">sol_worker_thread_spec</a> </dd>
<dd>
<a class="el" href="sol-worker-thread_8h.html#a7d60d6443f27e0c7a4a51fd4171124b6">sol_worker_thread_cancel()</a> </dd>
<dd>
<a class="el" href="sol-worker-thread_8h.html#a43d6d9f188545f5cdc1fe27b979c811c">sol_worker_thread_feedback()</a> </dd>
<dd>
<a class="el" href="group__Mainloop.html#ga36f2bd42167cd7404bf9fb37f166b1b1">sol_idle_add()</a> </dd></dl>

<p>References <a class="el" href="structsol__worker__thread__spec.html#afd3226b91658a3d3236a0d780dc6739a">sol_worker_thread_spec::api_version</a>, <a class="el" href="structsol__worker__thread__spec.html#a1e284be860887b5520a18954a343f060">sol_worker_thread_spec::iterate</a>, <a class="el" href="group__Log.html#gacb48844cf78438b772f069c089836835">SOL_NULL_CHECK</a>, <a class="el" href="sol-worker-thread-impl-glib_8c.html#a8a1ddcbe42c29b327d7accc8d6b8d8ae">sol_worker_thread_impl_new()</a>, <a class="el" href="sol-worker-thread_8h.html#a13e852aa5ab554f4c230f1c5d2226b36">SOL_WORKER_THREAD_SPEC_API_VERSION</a>, <a class="el" href="group__Log.html#ga5d9529e9746395acc2cd96a28ffa1c28">SOL_WRN</a>, and <a class="el" href="sol-util_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>.</p>

<p>Referenced by <a class="el" href="sol-i2c-impl-linux_8c.html#aa8b55769e472d87f60a958a466700a9c">sol_i2c_read()</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#acce58766bef6093b924cbd7d9505a489">sol_i2c_read_register()</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#a24f5ad254dfd975391e4c6a674b47c7c">sol_i2c_read_register_multiple()</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#adba39ab26c0255716126cbff193fc8c5">sol_i2c_write()</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#a5494af6ee985855c88dd0184d56d6f36">sol_i2c_write_quick()</a>, <a class="el" href="sol-i2c-impl-linux_8c.html#a3857e0667ac050c938c0e9f1b18f5fd7">sol_i2c_write_register()</a>, and <a class="el" href="group__SPI.html#gaab25170293f64d99e713c28cd0078e50">sol_spi_transfer()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
