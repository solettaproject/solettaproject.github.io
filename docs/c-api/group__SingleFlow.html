<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Soletta™ Framework: Single Flow</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta™ Framework
   </div>
   <div id="projectbrief">
   Framework for making IoT devices<br /><br />
   <small>
   <a href="http://solettaproject.github.io/docs/">Full online documentation</a> | 
   <a href="index.html">C API Index</a>
   </small><br />
   </div>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Single Flow<div class="ingroups"><a class="el" href="group__Flow.html">Flow Based Programming</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Single flow is a parent node that creates a single children that works stand alone.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__flow__single__options.html">sol_flow_single_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the specification of a single node.  <a href="structsol__flow__single__options.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga52b6661631d70dee8a3220b7d82f914c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#ga52b6661631d70dee8a3220b7d82f914c">SOL_FLOW_SINGLE_CONNECTIONS</a>(...)&#160;&#160;&#160;(const uint16_t[]){ __VA_ARGS__, UINT16_MAX }</td></tr>
<tr class="memdesc:ga52b6661631d70dee8a3220b7d82f914c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to declare an array of <code>uint16_t</code> terminated by <code>UINT16_MAX</code>.  <a href="#ga52b6661631d70dee8a3220b7d82f914c">More...</a><br/></td></tr>
<tr class="separator:ga52b6661631d70dee8a3220b7d82f914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae10f771f0400956beee3f402ceafcbb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#gae10f771f0400956beee3f402ceafcbb8">SOL_FLOW_SINGLE_OPTIONS_DEFAULTS</a>(...)</td></tr>
<tr class="memdesc:gae10f771f0400956beee3f402ceafcbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro sets struct <a class="el" href="structsol__flow__single__options.html" title="Structure for the specification of a single node. ">sol_flow_single_options</a> base member to contain the proper <code>api_version</code> (<a class="el" href="sol-flow_8h.html#aab940de570266dcc17434917797dc296" title="Compile time API version to be checked during runtime. ">SOL_FLOW_NODE_OPTIONS_API_VERSION</a>) and <code>sub_api</code> (<a class="el" href="sol-flow-single_8h.html#a5d55b65c53c44d27666a582dfd948ec0" title="This versions the rest of the structure and should be used in base.sub_api. ">SOL_FLOW_SINGLE_OPTIONS_API_VERSION</a>).  <a href="#gae10f771f0400956beee3f402ceafcbb8">More...</a><br/></td></tr>
<tr class="separator:gae10f771f0400956beee3f402ceafcbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad3c2bc038dd1c1bbf41d88e35f2e9f28"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structsol__flow__single__options.html">sol_flow_single_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#gad3c2bc038dd1c1bbf41d88e35f2e9f28">sol_flow_single_options</a></td></tr>
<tr class="memdesc:gad3c2bc038dd1c1bbf41d88e35f2e9f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the specification of a single node.  <a href="#gad3c2bc038dd1c1bbf41d88e35f2e9f28">More...</a><br/></td></tr>
<tr class="separator:gad3c2bc038dd1c1bbf41d88e35f2e9f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1819c2c62a34b939fb17d1d3d48dc332"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#ga1819c2c62a34b939fb17d1d3d48dc332">sol_flow_single_connect_port_in</a> (struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *node, uint16_t port_idx)</td></tr>
<tr class="memdesc:ga1819c2c62a34b939fb17d1d3d48dc332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the input port <em>port_idx</em> of the inner node.  <a href="#ga1819c2c62a34b939fb17d1d3d48dc332">More...</a><br/></td></tr>
<tr class="separator:ga1819c2c62a34b939fb17d1d3d48dc332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga960189068906146a92a4967c28f93de0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#ga960189068906146a92a4967c28f93de0">sol_flow_single_connect_port_out</a> (struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *node, uint16_t port_idx)</td></tr>
<tr class="memdesc:ga960189068906146a92a4967c28f93de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the output port <em>port_idx</em> of the inner node.  <a href="#ga960189068906146a92a4967c28f93de0">More...</a><br/></td></tr>
<tr class="separator:ga960189068906146a92a4967c28f93de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf063045b5482e4de0edc21ab0031de4e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#gaf063045b5482e4de0edc21ab0031de4e">sol_flow_single_disconnect_port_in</a> (struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *node, uint16_t port_idx)</td></tr>
<tr class="memdesc:gaf063045b5482e4de0edc21ab0031de4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the input port <em>port_idx</em> of the inner node.  <a href="#gaf063045b5482e4de0edc21ab0031de4e">More...</a><br/></td></tr>
<tr class="separator:gaf063045b5482e4de0edc21ab0031de4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1ee4b120b9f83802813168bb8d62bf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#gaed1ee4b120b9f83802813168bb8d62bf">sol_flow_single_disconnect_port_out</a> (struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *node, uint16_t port_idx)</td></tr>
<tr class="memdesc:gaed1ee4b120b9f83802813168bb8d62bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the output port <em>port_idx</em> of the inner node.  <a href="#gaed1ee4b120b9f83802813168bb8d62bf">More...</a><br/></td></tr>
<tr class="separator:gaed1ee4b120b9f83802813168bb8d62bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42b8cef4aeac50181391643dcce539d7"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#ga42b8cef4aeac50181391643dcce539d7">sol_flow_single_get_child</a> (const struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *node)</td></tr>
<tr class="memdesc:ga42b8cef4aeac50181391643dcce539d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference to the inner node.  <a href="#ga42b8cef4aeac50181391643dcce539d7">More...</a><br/></td></tr>
<tr class="separator:ga42b8cef4aeac50181391643dcce539d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde24d8571eeecac5f88999ab5bf51ba"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba">sol_flow_single_new</a> (const char *id, const struct <a class="el" href="structsol__flow__node__type.html">sol_flow_node_type</a> *base_type, const struct <a class="el" href="structsol__flow__node__options.html">sol_flow_node_options</a> *options, const uint16_t *connected_ports_in, const uint16_t *connected_ports_out, void(*process)(void *user_data, struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *node, uint16_t <a class="el" href="server-sse_8c.html#a63c89c04d1feae07ca35558055155ffb">port</a>, const struct <a class="el" href="group__FlowPacket.html#ga7929cae9ca6118d28b412b7bd6fe2626">sol_flow_packet</a> *packet), const void *user_data)</td></tr>
<tr class="memdesc:gadde24d8571eeecac5f88999ab5bf51ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a single-node instance for the given <em>base_type</em>.  <a href="#gadde24d8571eeecac5f88999ab5bf51ba">More...</a><br/></td></tr>
<tr class="separator:gadde24d8571eeecac5f88999ab5bf51ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa44516661ed415cbcbae18d510adc6b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsol__flow__node__type.html">sol_flow_node_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b">sol_flow_single_new_type</a> (const struct <a class="el" href="structsol__flow__node__type.html">sol_flow_node_type</a> *base_type)</td></tr>
<tr class="memdesc:gafa44516661ed415cbcbae18d510adc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a wrapper type to use <em>base_type</em> nodes without a flow.  <a href="#gafa44516661ed415cbcbae18d510adc6b">More...</a><br/></td></tr>
<tr class="separator:gafa44516661ed415cbcbae18d510adc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34f1cd887b2c1f6c2711c0a54cb93eb"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structsol__flow__node__type.html">sol_flow_node_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SingleFlow.html#gad34f1cd887b2c1f6c2711c0a54cb93eb">sol_flow_single_type_get_child_type</a> (const struct <a class="el" href="structsol__flow__node__type.html">sol_flow_node_type</a> *single_type)</td></tr>
<tr class="memdesc:gad34f1cd887b2c1f6c2711c0a54cb93eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a single-node type wrapper, return the internal (child) type.  <a href="#gad34f1cd887b2c1f6c2711c0a54cb93eb">More...</a><br/></td></tr>
<tr class="separator:gad34f1cd887b2c1f6c2711c0a54cb93eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Single flow is a parent node that creates a single children that works stand alone. </p>
<p>Sometimes it is desired to use a single node, manually feeding packets and processing those being sent on the node's output port.</p>
<p>The single node type does exactly that by wrapping a base type (also called "child type"), it will create an internal node and take care to deliver incoming packets to that and also take its outgoing packets and calling the provided <code>process()</code> method, if any.</p>
<p>It also forwards connections and disconnections requests, as some nodes will only work if there is a connection established for a given port.</p>
<p>See <a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba" title="create a single-node instance for the given base_type. ">sol_flow_single_new()</a> and <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a>. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga52b6661631d70dee8a3220b7d82f914c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_FLOW_SINGLE_CONNECTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;(const uint16_t[]){ __VA_ARGS__, UINT16_MAX }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to declare an array of <code>uint16_t</code> terminated by <code>UINT16_MAX</code>. </p>
<p>This can be used in <a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba" title="create a single-node instance for the given base_type. ">sol_flow_single_new()</a> or struct <a class="el" href="structsol__flow__single__options.html" title="Structure for the specification of a single node. ">sol_flow_single_options</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2flow_2c-api_2single-node_8c-example.html#a27">/src/samples/flow/c-api/single-node.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="single-node_8c.html#a628d35a3d6e3e51f4a89fe34b5b9f499">create_minutes()</a>, and <a class="el" href="single-node_8c.html#af988688cd8be28426c68a9cdfb0c786c">create_seconds()</a>.</p>

</div>
</div>
<a class="anchor" id="gae10f771f0400956beee3f402ceafcbb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_FLOW_SINGLE_OPTIONS_DEFAULTS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">        .base = { <a class="code" href="group__Mainloop.html#ga794a88f51470a85bb21279b32cc570ca">\</a></div>
<div class="line"><a class="code" href="group__Mainloop.html#ga794a88f51470a85bb21279b32cc570ca">            SOL_SET_API_VERSION</a>(.api_version = <a class="code" href="sol-flow_8h.html#aab940de570266dcc17434917797dc296">SOL_FLOW_NODE_OPTIONS_API_VERSION</a>, ) <a class="code" href="group__Mainloop.html#ga794a88f51470a85bb21279b32cc570ca">\</a></div>
<div class="line"><a class="code" href="group__Mainloop.html#ga794a88f51470a85bb21279b32cc570ca">            SOL_SET_API_VERSION</a>(.sub_api = <a class="code" href="sol-flow-single_8h.html#a5d55b65c53c44d27666a582dfd948ec0">SOL_FLOW_SINGLE_OPTIONS_API_VERSION</a>) \</div>
<div class="line">        }, \</div>
<div class="line">        __VA_ARGS__ \</div>
<div class="line">}</div>
<div class="ttc" id="sol-flow-single_8h_html_a5d55b65c53c44d27666a582dfd948ec0"><div class="ttname"><a href="sol-flow-single_8h.html#a5d55b65c53c44d27666a582dfd948ec0">SOL_FLOW_SINGLE_OPTIONS_API_VERSION</a></div><div class="ttdeci">#define SOL_FLOW_SINGLE_OPTIONS_API_VERSION</div><div class="ttdoc">This versions the rest of the structure and should be used in base.sub_api. </div><div class="ttdef"><b>Definition:</b> sol-flow-single.h:96</div></div>
<div class="ttc" id="group__Mainloop_html_ga794a88f51470a85bb21279b32cc570ca"><div class="ttname"><a href="group__Mainloop.html#ga794a88f51470a85bb21279b32cc570ca">SOL_SET_API_VERSION</a></div><div class="ttdeci">#define SOL_SET_API_VERSION(expression)</div><div class="ttdoc">This macro will cope with SOL_NO_API_VERSION and allows easy declaration of api_version fields...</div><div class="ttdef"><b>Definition:</b> sol-mainloop.h:660</div></div>
<div class="ttc" id="sol-flow_8h_html_aab940de570266dcc17434917797dc296"><div class="ttname"><a href="sol-flow_8h.html#aab940de570266dcc17434917797dc296">SOL_FLOW_NODE_OPTIONS_API_VERSION</a></div><div class="ttdeci">#define SOL_FLOW_NODE_OPTIONS_API_VERSION</div><div class="ttdoc">Compile time API version to be checked during runtime. </div><div class="ttdef"><b>Definition:</b> sol-flow.h:554</div></div>
</div><!-- fragment -->
<p>This macro sets struct <a class="el" href="structsol__flow__single__options.html" title="Structure for the specification of a single node. ">sol_flow_single_options</a> base member to contain the proper <code>api_version</code> (<a class="el" href="sol-flow_8h.html#aab940de570266dcc17434917797dc296" title="Compile time API version to be checked during runtime. ">SOL_FLOW_NODE_OPTIONS_API_VERSION</a>) and <code>sub_api</code> (<a class="el" href="sol-flow-single_8h.html#a5d55b65c53c44d27666a582dfd948ec0" title="This versions the rest of the structure and should be used in base.sub_api. ">SOL_FLOW_SINGLE_OPTIONS_API_VERSION</a>). </p>
<p>The remaining variable arguments are passed as member initializers, please use ".name = value" to avoid problems and make code easy to read. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gad3c2bc038dd1c1bbf41d88e35f2e9f28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsol__flow__single__options.html">sol_flow_single_options</a>  <a class="el" href="structsol__flow__single__options.html">sol_flow_single_options</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure for the specification of a single node. </p>
<p>This option is used to instatiate a single-node that wrappes an inner node of a given type specified at <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a>.</p>
<p>It is used internally by <a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba" title="create a single-node instance for the given base_type. ">sol_flow_single_new()</a> or explicitly by those calling sol_flow_new() manually.</p>
<p>It contains a struct <a class="el" href="structsol__flow__node__options.html" title="Node options are a set of attributes defined by the Node Type that can change the behavior of a Node...">sol_flow_node_options</a> header (<code>base</code>) so it conforms to the options protocol. Be sure to fill its <code>api_version</code> with <a class="el" href="sol-flow_8h.html#aab940de570266dcc17434917797dc296" title="Compile time API version to be checked during runtime. ">SOL_FLOW_NODE_OPTIONS_API_VERSION</a> and <code>sub_api</code> with <a class="el" href="sol-flow-single_8h.html#a5d55b65c53c44d27666a582dfd948ec0" title="This versions the rest of the structure and should be used in base.sub_api. ">SOL_FLOW_SINGLE_OPTIONS_API_VERSION</a>, or use <a class="el" href="group__SingleFlow.html#gae10f771f0400956beee3f402ceafcbb8" title="This macro sets struct sol_flow_single_options base member to contain the proper api_version (SOL_FLO...">SOL_FLOW_SINGLE_OPTIONS_DEFAULTS()</a> to help you. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1819c2c62a34b939fb17d1d3d48dc332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t sol_flow_single_connect_port_in </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect the input port <em>port_idx</em> of the inner node. </p>
<p>Ports connections are counted, so a matching number of disconnects must happen to actually disconnect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a valid node created from <a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba" title="create a single-node instance for the given base_type. ">sol_flow_single_new()</a> or <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a>. </td></tr>
    <tr><td class="paramname">port_idx</td><td>the port index to connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of connections (&gt;1) on success, -errno on error. 0 is never returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga960189068906146a92a4967c28f93de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t sol_flow_single_connect_port_out </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect the output port <em>port_idx</em> of the inner node. </p>
<p>Ports connections are counted, so a matching number of disconnects must happen to actually disconnect.</p>
<dl class="section note"><dt>Note</dt><dd>prefer a static list of connections specified at node creation time. Some inner nodes will deliver packets when they are opened/created, then you will miss the initial packets since they will be dropped due lack of connections.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a valid node created from <a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba" title="create a single-node instance for the given base_type. ">sol_flow_single_new()</a> or <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a>. </td></tr>
    <tr><td class="paramname">port_idx</td><td>the port index to connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of connections (&gt;1) on success, -errno on error. 0 is never returned. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2flow_2c-api_2single-node_8c-example.html#a16">/src/samples/flow/c-api/single-node.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="single-node_8c.html#a3651efcf0c3a5520e1a735baba4d52b9">on_minutes_packet()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf063045b5482e4de0edc21ab0031de4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t sol_flow_single_disconnect_port_in </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect the input port <em>port_idx</em> of the inner node. </p>
<p>Ports connections are counted, so a matching number of disconnects must happen to actually disconnect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a valid node created from <a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba" title="create a single-node instance for the given base_type. ">sol_flow_single_new()</a> or <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a>. </td></tr>
    <tr><td class="paramname">port_idx</td><td>the port index to disconnect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of connections (&gt;1) on success, -errno on error. 0 if the last connection is gone. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed1ee4b120b9f83802813168bb8d62bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t sol_flow_single_disconnect_port_out </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect the output port <em>port_idx</em> of the inner node. </p>
<p>Ports connections are counted, so a matching number of disconnects must happen to actually disconnect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a valid node created from <a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba" title="create a single-node instance for the given base_type. ">sol_flow_single_new()</a> or <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a>. </td></tr>
    <tr><td class="paramname">port_idx</td><td>the port index to disconnect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of connections (&gt;1) on success, -errno on error. 0 if the last connection is gone. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2flow_2c-api_2single-node_8c-example.html#a14">/src/samples/flow/c-api/single-node.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="single-node_8c.html#a3651efcf0c3a5520e1a735baba4d52b9">on_minutes_packet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga42b8cef4aeac50181391643dcce539d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a>* sol_flow_single_get_child </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reference to the inner node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a valid node created from <a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba" title="create a single-node instance for the given base_type. ">sol_flow_single_new()</a> or <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inner node wrapped by the given <em>node</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gadde24d8571eeecac5f88999ab5bf51ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a>* sol_flow_single_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__flow__node__type.html">sol_flow_node_type</a> *&#160;</td>
          <td class="paramname"><em>base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__flow__node__options.html">sol_flow_node_options</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>connected_ports_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>connected_ports_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *user_data, struct <a class="el" href="group__Flow.html#gafe1a5e24c9138afad039a07adc54b51d">sol_flow_node</a> *node, uint16_t <a class="el" href="server-sse_8c.html#a63c89c04d1feae07ca35558055155ffb">port</a>, const struct <a class="el" href="group__FlowPacket.html#ga7929cae9ca6118d28b412b7bd6fe2626">sol_flow_packet</a> *packet)&#160;</td>
          <td class="paramname"><em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a single-node instance for the given <em>base_type</em>. </p>
<p>Sometimes it is desired to use a single node, manually feeding packets and processing those being sent on the node's output port.</p>
<p>This function is a helper around <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a> that creates the type and instance using the provided parameters.</p>
<p>If many instances of the same type are desired, it is recommended to create a single type with <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a> and then call <a class="el" href="group__Flow.html#gaf6206a8ce4c5e0fc26cb2daa42645117" title="Creates a new node. ">sol_flow_node_new()</a> on it, using struct <a class="el" href="structsol__flow__single__options.html" title="Structure for the specification of a single node. ">sol_flow_single_options</a> to inform options of the inner node, connected ports and process callback.</p>
<p>It is worth to mention that node must be informed of the ports they will receive packets and those that they should send by specifying the <code>connected_ports_in</code> and <code>connected_ports_out</code> arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>A string to identify the node, may be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">base_type</td><td>The type of the node to be wrapped, it must be valid and a reference is stored during the returned node lifetime. </td></tr>
    <tr><td class="paramname">options</td><td>the options to be forwarded to the wrapped node of type <em>base_type</em>. </td></tr>
    <tr><td class="paramname">connected_ports_in</td><td>if non-NULL, an array of input port indexes to connect. The array must be <code>UINT16_MAX</code> terminated. See <a class="el" href="group__SingleFlow.html#ga52b6661631d70dee8a3220b7d82f914c" title="Convenience macro to declare an array of uint16_t terminated by UINT16_MAX. ">SOL_FLOW_SINGLE_CONNECTIONS()</a>. </td></tr>
    <tr><td class="paramname">connected_ports_out</td><td>if non-NULL, an array of output port indexes to connect. The array must be <code>UINT16_MAX</code> terminated. See <a class="el" href="group__SingleFlow.html#ga52b6661631d70dee8a3220b7d82f914c" title="Convenience macro to declare an array of uint16_t terminated by UINT16_MAX. ">SOL_FLOW_SINGLE_CONNECTIONS()</a>. </td></tr>
    <tr><td class="paramname">process</td><td>if non-NULL, the callback to process outgoing packets produced by node. The first argument, <code>user_data</code> will be the value of the same-name sibling parameter. </td></tr>
    <tr><td class="paramname">user_data</td><td>the context to provide to <em>process</em> when it is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error or the newly created node. It should be deleted with <a class="el" href="group__Flow.html#gafdddc9d12a1dc9fec29c77a1c0e43eef" title="Deletes a node. ">sol_flow_node_del()</a>. One can feed the node with packets by calling <a class="el" href="group__Flow.html#ga9d09a784f4dff817ff7429fd7bc30ca9" title="Send a packet from a given node to one of its output ports. ">sol_flow_send_packet()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2flow_2c-api_2single-node_8c-example.html#a26">/src/samples/flow/c-api/single-node.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="single-node_8c.html#a628d35a3d6e3e51f4a89fe34b5b9f499">create_minutes()</a>, and <a class="el" href="single-node_8c.html#af988688cd8be28426c68a9cdfb0c786c">create_seconds()</a>.</p>

</div>
</div>
<a class="anchor" id="gafa44516661ed415cbcbae18d510adc6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsol__flow__node__type.html">sol_flow_node_type</a>* sol_flow_single_new_type </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__flow__node__type.html">sol_flow_node_type</a> *&#160;</td>
          <td class="paramname"><em>base_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a wrapper type to use <em>base_type</em> nodes without a flow. </p>
<p>Sometimes it is desired to use a single node, manually feeding packets and processing those being sent on the node's output port.</p>
<p>To make it easy this function returns a wrapper node type that can be instantiated with <a class="el" href="group__Flow.html#gaf6206a8ce4c5e0fc26cb2daa42645117" title="Creates a new node. ">sol_flow_node_new()</a> and when <a class="el" href="group__Flow.html#ga9d09a784f4dff817ff7429fd7bc30ca9" title="Send a packet from a given node to one of its output ports. ">sol_flow_send_packet()</a> (or variants such as <a class="el" href="group__Flow.html#gae760e900ca018e9755296fef4e141561" title="Convenience function to create and send a Boolean packet. ">sol_flow_send_bool_packet()</a>) will feed the base type's instance with such packets, as well as outgoing packets produced by that instance can be processed by the external user.</p>
<p>To process the outgoing packets provide the <code>process</code> member of the struct <a class="el" href="structsol__flow__single__options.html" title="Structure for the specification of a single node. ">sol_flow_single_options</a> or the same-name parameter for the <a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba" title="create a single-node instance for the given base_type. ">sol_flow_single_new()</a> helper. They will receive the context data provided in <code>user_data</code>.</p>
<p>It is worth to mention that node must be informed of the ports they will receive packets and those that they should send by specifying the <code>connected_ports_in</code> and <code>connected_ports_out</code> arrays. Sending packets to disconnected ports is not verified may result in malfunction.</p>
<p>However, some nodes may produce packets even in disconnected ports and these are not filtered-out automatically. If you do not want to receive packets in disconnected ports, filter them by checking the <code>port</code> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_type</td><td>the type to be wrapped. It must be a valid type and a reference is stored while the returned type is alive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> on error or newly allocated node type wrapping <em>base_type</em>, this should be deleted with <a class="el" href="group__Flow.html#ga0e548c7b8f0e8ff5f5195de1ded5365a" title="Delete a node type. ">sol_flow_node_type_del()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__SingleFlow.html#gadde24d8571eeecac5f88999ab5bf51ba" title="create a single-node instance for the given base_type. ">sol_flow_single_new()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad34f1cd887b2c1f6c2711c0a54cb93eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structsol__flow__node__type.html">sol_flow_node_type</a>* sol_flow_single_type_get_child_type </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__flow__node__type.html">sol_flow_node_type</a> *&#160;</td>
          <td class="paramname"><em>single_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a single-node type wrapper, return the internal (child) type. </p>
<p>This is useful to create options since the wrapper type options differ from the internal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">single_type</td><td>a type previously created with <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the internal (child or base_type) used with <a class="el" href="group__SingleFlow.html#gafa44516661ed415cbcbae18d510adc6b" title="create a wrapper type to use base_type nodes without a flow. ">sol_flow_single_new_type()</a>, or NULL on failures. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<a href="http://solettaproject.github.io/docs/">Full online documentation</a> | 
<a href="index.html">C API Index</a>
</small></address>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
