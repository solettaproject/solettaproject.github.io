<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Soletta™ Framework: Soletta utility functions.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta™ Framework
   </div>
   <div id="projectbrief">
   Framework for making IoT devices<br /><br />
   <small>
   <a href="http://solettaproject.github.io/docs/">Full online documentation</a> | 
   <a href="index.html">C API Index</a>
   </small><br />
   </div>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Soletta utility functions.</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains helpers to manipulate time, error code/string, overflows, encode/decode data and some converters.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__File-utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__File-utils.html">Soletta file utility functions</a></td></tr>
<tr class="memdesc:group__File-utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains helpers to deal with files. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8f1ab5ab1508e066a38673a56b8da661"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga8f1ab5ab1508e066a38673a56b8da661">sol_util_array_size</a>(arr)&#160;&#160;&#160;(sizeof(arr) / sizeof((arr)[0]))</td></tr>
<tr class="memdesc:ga8f1ab5ab1508e066a38673a56b8da661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of elements in an array.  <a href="#ga8f1ab5ab1508e066a38673a56b8da661">More...</a><br/></td></tr>
<tr class="separator:ga8f1ab5ab1508e066a38673a56b8da661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804c3ded16e3a43a661dcff6d0bec378"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga804c3ded16e3a43a661dcff6d0bec378">sol_util_max</a>(x, y)</td></tr>
<tr class="memdesc:ga804c3ded16e3a43a661dcff6d0bec378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum value.  <a href="#ga804c3ded16e3a43a661dcff6d0bec378">More...</a><br/></td></tr>
<tr class="separator:ga804c3ded16e3a43a661dcff6d0bec378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379e823272f1197d0bc1b740cac20c86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga379e823272f1197d0bc1b740cac20c86">sol_util_min</a>(x, y)</td></tr>
<tr class="memdesc:ga379e823272f1197d0bc1b740cac20c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum value.  <a href="#ga379e823272f1197d0bc1b740cac20c86">More...</a><br/></td></tr>
<tr class="separator:ga379e823272f1197d0bc1b740cac20c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacffae23cc2a51303f86497209d3b4dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gacffae23cc2a51303f86497209d3b4dc2">SOL_UTIL_MSEC_PER_SEC</a>&#160;&#160;&#160;1000ULL</td></tr>
<tr class="memdesc:gacffae23cc2a51303f86497209d3b4dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of milliseconds in a second: 1,000.  <a href="#gacffae23cc2a51303f86497209d3b4dc2">More...</a><br/></td></tr>
<tr class="separator:gacffae23cc2a51303f86497209d3b4dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db38244936e0790e93ddfa3f49f960c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga2db38244936e0790e93ddfa3f49f960c">SOL_UTIL_NSEC_PER_MSEC</a>&#160;&#160;&#160;1000000ULL</td></tr>
<tr class="memdesc:ga2db38244936e0790e93ddfa3f49f960c"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nanoseconds in a milliseconds: 1,000,000,000 / 1,000 = 1,000,000.  <a href="#ga2db38244936e0790e93ddfa3f49f960c">More...</a><br/></td></tr>
<tr class="separator:ga2db38244936e0790e93ddfa3f49f960c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4701594d57bacc9fe7a83babfd15d174"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga4701594d57bacc9fe7a83babfd15d174">SOL_UTIL_NSEC_PER_SEC</a>&#160;&#160;&#160;1000000000ULL</td></tr>
<tr class="memdesc:ga4701594d57bacc9fe7a83babfd15d174"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nanoseconds in a second: 1,000,000,000.  <a href="#ga4701594d57bacc9fe7a83babfd15d174">More...</a><br/></td></tr>
<tr class="separator:ga4701594d57bacc9fe7a83babfd15d174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad882f7c4bc64119c8d53c5eb46e13aa8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gad882f7c4bc64119c8d53c5eb46e13aa8">SOL_UTIL_NSEC_PER_USEC</a>&#160;&#160;&#160;1000ULL</td></tr>
<tr class="memdesc:gad882f7c4bc64119c8d53c5eb46e13aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nanoseconds in a microsecond: 1,000,000,000 / 1,000,000 = 1,000.  <a href="#gad882f7c4bc64119c8d53c5eb46e13aa8">More...</a><br/></td></tr>
<tr class="separator:gad882f7c4bc64119c8d53c5eb46e13aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab584188ab3f38605dab8b04aaa85913d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gab584188ab3f38605dab8b04aaa85913d">sol_util_strerrora</a>(errnum)</td></tr>
<tr class="memdesc:gab584188ab3f38605dab8b04aaa85913d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string from a given error using the stack.  <a href="#gab584188ab3f38605dab8b04aaa85913d">More...</a><br/></td></tr>
<tr class="separator:gab584188ab3f38605dab8b04aaa85913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bb032a38daa31c3a18febd3a3802bb7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga6bb032a38daa31c3a18febd3a3802bb7">sol_util_uint16_bytes_swap</a>(val)&#160;&#160;&#160;((uint16_t)((((val) &gt;&gt; 8) &amp; 0xff) | (((val) &amp; 0xff) &lt;&lt; 8)))</td></tr>
<tr class="memdesc:ga6bb032a38daa31c3a18febd3a3802bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bytes of a 16 bytes unsigned int.  <a href="#ga6bb032a38daa31c3a18febd3a3802bb7">More...</a><br/></td></tr>
<tr class="separator:ga6bb032a38daa31c3a18febd3a3802bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11c3f12c43a911abc9955e8e762b541e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga11c3f12c43a911abc9955e8e762b541e">sol_util_uint32_bytes_swap</a>(val)</td></tr>
<tr class="memdesc:ga11c3f12c43a911abc9955e8e762b541e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bytes of a 32 bytes unsigned int.  <a href="#ga11c3f12c43a911abc9955e8e762b541e">More...</a><br/></td></tr>
<tr class="separator:ga11c3f12c43a911abc9955e8e762b541e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8ccb9b5905ae07af1e161bf98438af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gafc8ccb9b5905ae07af1e161bf98438af">sol_util_uint64_bytes_swap</a>(val)</td></tr>
<tr class="memdesc:gafc8ccb9b5905ae07af1e161bf98438af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bytes of a 32 bytes unsigned int.  <a href="#gafc8ccb9b5905ae07af1e161bf98438af">More...</a><br/></td></tr>
<tr class="separator:gafc8ccb9b5905ae07af1e161bf98438af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5becbe54da45aaa016e8ee4f47f36b8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga5becbe54da45aaa016e8ee4f47f36b8b">SOL_UTIL_USEC_PER_SEC</a>&#160;&#160;&#160;1000000ULL</td></tr>
<tr class="memdesc:ga5becbe54da45aaa016e8ee4f47f36b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of microseconds in a second: 1,000,000.  <a href="#ga5becbe54da45aaa016e8ee4f47f36b8b">More...</a><br/></td></tr>
<tr class="separator:ga5becbe54da45aaa016e8ee4f47f36b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa52ea19a1852e9e838a1ec40ffa39f30"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gaa52ea19a1852e9e838a1ec40ffa39f30">sol_util_base16_calculate_decoded_len</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:gaa52ea19a1852e9e838a1ec40ffa39f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size necessary to decode a given slice in base16.  <a href="#gaa52ea19a1852e9e838a1ec40ffa39f30">More...</a><br/></td></tr>
<tr class="separator:gaa52ea19a1852e9e838a1ec40ffa39f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d9b7bbe9d55e8a0ef3c0685bae56625"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga1d9b7bbe9d55e8a0ef3c0685bae56625">sol_util_base16_calculate_encoded_len</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:ga1d9b7bbe9d55e8a0ef3c0685bae56625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size necessary to encode a given slice in base16.  <a href="#ga1d9b7bbe9d55e8a0ef3c0685bae56625">More...</a><br/></td></tr>
<tr class="separator:ga1d9b7bbe9d55e8a0ef3c0685bae56625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4089d5876b27d70240b2ad07d4b6f64"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gac4089d5876b27d70240b2ad07d4b6f64">sol_util_base16_decode</a> (void *buf, size_t buflen, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, enum <a class="el" href="group__Buffer.html#ga06c94d5ad12e5abae2f881a53c6becf8">sol_decode_case</a> decode_case)</td></tr>
<tr class="memdesc:gac4089d5876b27d70240b2ad07d4b6f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the binary slice from base16 (hexadecimal).  <a href="#gac4089d5876b27d70240b2ad07d4b6f64">More...</a><br/></td></tr>
<tr class="separator:gac4089d5876b27d70240b2ad07d4b6f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42409b41553e6878466722ab17ddc27d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga42409b41553e6878466722ab17ddc27d">sol_util_base16_encode</a> (void *buf, size_t buflen, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, bool uppercase)</td></tr>
<tr class="memdesc:ga42409b41553e6878466722ab17ddc27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the binary slice to base16 (hexadecimal).  <a href="#ga42409b41553e6878466722ab17ddc27d">More...</a><br/></td></tr>
<tr class="separator:ga42409b41553e6878466722ab17ddc27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2630baa157de5d41f25f527a185501"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga4f2630baa157de5d41f25f527a185501">sol_util_base64_calculate_decoded_len</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const char base64_map[<a class="el" href="group__Macros.html#ga38dd7c61af06bb93b22b32217dfa944d">SOL_STATIC_ARRAY_SIZE</a>(65)])</td></tr>
<tr class="memdesc:ga4f2630baa157de5d41f25f527a185501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size necessary to decode a given slice in base64.  <a href="#ga4f2630baa157de5d41f25f527a185501">More...</a><br/></td></tr>
<tr class="separator:ga4f2630baa157de5d41f25f527a185501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4177d45ab373433b10e72e059253b46d"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga4177d45ab373433b10e72e059253b46d">sol_util_base64_calculate_encoded_len</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const char base64_map[<a class="el" href="group__Macros.html#ga38dd7c61af06bb93b22b32217dfa944d">SOL_STATIC_ARRAY_SIZE</a>(65)])</td></tr>
<tr class="memdesc:ga4177d45ab373433b10e72e059253b46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size necessary to encode a given slice in base64.  <a href="#ga4177d45ab373433b10e72e059253b46d">More...</a><br/></td></tr>
<tr class="separator:ga4177d45ab373433b10e72e059253b46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e2b3856ee9a879658c868b80050970"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga19e2b3856ee9a879658c868b80050970">sol_util_base64_decode</a> (void *buf, size_t buflen, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const char base64_map[<a class="el" href="group__Macros.html#ga38dd7c61af06bb93b22b32217dfa944d">SOL_STATIC_ARRAY_SIZE</a>(65)])</td></tr>
<tr class="memdesc:ga19e2b3856ee9a879658c868b80050970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the binary slice from base64 using the given map.  <a href="#ga19e2b3856ee9a879658c868b80050970">More...</a><br/></td></tr>
<tr class="separator:ga19e2b3856ee9a879658c868b80050970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7228f93dcb7e29a7eb594624265997d0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga7228f93dcb7e29a7eb594624265997d0">sol_util_base64_encode</a> (void *buf, size_t buflen, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const char base64_map[<a class="el" href="group__Macros.html#ga38dd7c61af06bb93b22b32217dfa944d">SOL_STATIC_ARRAY_SIZE</a>(65)])</td></tr>
<tr class="memdesc:ga7228f93dcb7e29a7eb594624265997d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the binary slice to base64 using the given map.  <a href="#ga7228f93dcb7e29a7eb594624265997d0">More...</a><br/></td></tr>
<tr class="separator:ga7228f93dcb7e29a7eb594624265997d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0258d91cf52518556da4570df97abee"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gaf0258d91cf52518556da4570df97abee">sol_util_be16_to_cpu</a> (uint16_t val)</td></tr>
<tr class="memdesc:gaf0258d91cf52518556da4570df97abee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 16 bytes big endian integer to cpu endianness.  <a href="#gaf0258d91cf52518556da4570df97abee">More...</a><br/></td></tr>
<tr class="separator:gaf0258d91cf52518556da4570df97abee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa5f58ed390da32d8a8da3bb6b5a5b4"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gacaa5f58ed390da32d8a8da3bb6b5a5b4">sol_util_be32_to_cpu</a> (uint32_t val)</td></tr>
<tr class="memdesc:gacaa5f58ed390da32d8a8da3bb6b5a5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 32 bytes big endian integer to cpu endianness.  <a href="#gacaa5f58ed390da32d8a8da3bb6b5a5b4">More...</a><br/></td></tr>
<tr class="separator:gacaa5f58ed390da32d8a8da3bb6b5a5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4d62e1f14e4ed9bebc91629e37fd5c"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga5a4d62e1f14e4ed9bebc91629e37fd5c">sol_util_be64_to_cpu</a> (uint64_t val)</td></tr>
<tr class="memdesc:ga5a4d62e1f14e4ed9bebc91629e37fd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 64 bytes big endian integer to cpu endianness.  <a href="#ga5a4d62e1f14e4ed9bebc91629e37fd5c">More...</a><br/></td></tr>
<tr class="separator:ga5a4d62e1f14e4ed9bebc91629e37fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd7654cbc5e20ca25d9a2d55fe718de"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga8dd7654cbc5e20ca25d9a2d55fe718de">sol_util_clear_memory_secure</a> (void *buf, size_t len)</td></tr>
<tr class="memdesc:ga8dd7654cbc5e20ca25d9a2d55fe718de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an allocated memory securely.  <a href="#ga8dd7654cbc5e20ca25d9a2d55fe718de">More...</a><br/></td></tr>
<tr class="separator:ga8dd7654cbc5e20ca25d9a2d55fe718de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga807cecfed816870ec5aad29126c3b9cc"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga807cecfed816870ec5aad29126c3b9cc">sol_util_cpu_to_be16</a> (uint16_t val)</td></tr>
<tr class="memdesc:ga807cecfed816870ec5aad29126c3b9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 16 bytes integer to big endian format.  <a href="#ga807cecfed816870ec5aad29126c3b9cc">More...</a><br/></td></tr>
<tr class="separator:ga807cecfed816870ec5aad29126c3b9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46889a42b373c4ac375daa6768a41d2b"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga46889a42b373c4ac375daa6768a41d2b">sol_util_cpu_to_be32</a> (uint32_t val)</td></tr>
<tr class="memdesc:ga46889a42b373c4ac375daa6768a41d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 32 bytes integer to big endian format.  <a href="#ga46889a42b373c4ac375daa6768a41d2b">More...</a><br/></td></tr>
<tr class="separator:ga46889a42b373c4ac375daa6768a41d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1258b67f97da5bc01852684c87e998"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga7f1258b67f97da5bc01852684c87e998">sol_util_cpu_to_be64</a> (uint64_t val)</td></tr>
<tr class="memdesc:ga7f1258b67f97da5bc01852684c87e998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 64 bytes integer to big endian format.  <a href="#ga7f1258b67f97da5bc01852684c87e998">More...</a><br/></td></tr>
<tr class="separator:ga7f1258b67f97da5bc01852684c87e998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga006f1fe01c984b58a6445b5334234e66"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga006f1fe01c984b58a6445b5334234e66">sol_util_cpu_to_le16</a> (uint16_t val)</td></tr>
<tr class="memdesc:ga006f1fe01c984b58a6445b5334234e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 16 bytes integer to little endian format.  <a href="#ga006f1fe01c984b58a6445b5334234e66">More...</a><br/></td></tr>
<tr class="separator:ga006f1fe01c984b58a6445b5334234e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b9c092ef1f91d460f88b2959c1705b"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gac3b9c092ef1f91d460f88b2959c1705b">sol_util_cpu_to_le32</a> (uint32_t val)</td></tr>
<tr class="memdesc:gac3b9c092ef1f91d460f88b2959c1705b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 32 bytes integer to little endian format.  <a href="#gac3b9c092ef1f91d460f88b2959c1705b">More...</a><br/></td></tr>
<tr class="separator:gac3b9c092ef1f91d460f88b2959c1705b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31039a248872ad9123ffb4d7dd09ebee"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga31039a248872ad9123ffb4d7dd09ebee">sol_util_cpu_to_le64</a> (uint64_t val)</td></tr>
<tr class="memdesc:ga31039a248872ad9123ffb4d7dd09ebee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 64 bytes integer to little endian format.  <a href="#ga31039a248872ad9123ffb4d7dd09ebee">More...</a><br/></td></tr>
<tr class="separator:ga31039a248872ad9123ffb4d7dd09ebee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa234717286ed1c78df5c0f7c15122446"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gaa234717286ed1c78df5c0f7c15122446">sol_util_double_eq</a> (double var0, double var1)</td></tr>
<tr class="memdesc:gaa234717286ed1c78df5c0f7c15122446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <code>var0</code> and <code>var1</code> for equality.  <a href="#gaa234717286ed1c78df5c0f7c15122446">More...</a><br/></td></tr>
<tr class="separator:gaa234717286ed1c78df5c0f7c15122446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148a2d09a5cb34ca70ba282eb67ddf8e"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga148a2d09a5cb34ca70ba282eb67ddf8e">sol_util_int32_clamp</a> (int32_t start, int32_t end, int32_t <a class="el" href="server_8c.html#acda54b23a3b92ae2efa63634288c0496">value</a>)</td></tr>
<tr class="memdesc:ga148a2d09a5cb34ca70ba282eb67ddf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts a number between two other numbers.  <a href="#ga148a2d09a5cb34ca70ba282eb67ddf8e">More...</a><br/></td></tr>
<tr class="separator:ga148a2d09a5cb34ca70ba282eb67ddf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcbe8afdb019a2b050ad8ab16cb8954f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gafcbe8afdb019a2b050ad8ab16cb8954f">sol_util_int32_mul</a> (int32_t op1, int32_t op2, int32_t *out)</td></tr>
<tr class="memdesc:gafcbe8afdb019a2b050ad8ab16cb8954f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#gafcbe8afdb019a2b050ad8ab16cb8954f">More...</a><br/></td></tr>
<tr class="separator:gafcbe8afdb019a2b050ad8ab16cb8954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad10a7a75f9b1e34ef1e044fb73f80ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gaad10a7a75f9b1e34ef1e044fb73f80ae">sol_util_int64_mul</a> (int64_t op1, int64_t op2, int64_t *out)</td></tr>
<tr class="memdesc:gaad10a7a75f9b1e34ef1e044fb73f80ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#gaad10a7a75f9b1e34ef1e044fb73f80ae">More...</a><br/></td></tr>
<tr class="separator:gaad10a7a75f9b1e34ef1e044fb73f80ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64996cc23e42c0b4f31724082abd1899"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga64996cc23e42c0b4f31724082abd1899">sol_util_le16_to_cpu</a> (uint16_t val)</td></tr>
<tr class="memdesc:ga64996cc23e42c0b4f31724082abd1899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 16 bytes little endian integer to cpu endianness.  <a href="#ga64996cc23e42c0b4f31724082abd1899">More...</a><br/></td></tr>
<tr class="separator:ga64996cc23e42c0b4f31724082abd1899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7e7d152e57a0c330bd464cd3367ae8"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga8d7e7d152e57a0c330bd464cd3367ae8">sol_util_le32_to_cpu</a> (uint32_t val)</td></tr>
<tr class="memdesc:ga8d7e7d152e57a0c330bd464cd3367ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 32 bytes little endian integer to cpu endianness.  <a href="#ga8d7e7d152e57a0c330bd464cd3367ae8">More...</a><br/></td></tr>
<tr class="separator:ga8d7e7d152e57a0c330bd464cd3367ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2915c43bca876e9b81e9e1e15bdaebd"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gae2915c43bca876e9b81e9e1e15bdaebd">sol_util_le64_to_cpu</a> (uint64_t val)</td></tr>
<tr class="memdesc:gae2915c43bca876e9b81e9e1e15bdaebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 64 bytes little endian integer to cpu endianness.  <a href="#gae2915c43bca876e9b81e9e1e15bdaebd">More...</a><br/></td></tr>
<tr class="separator:gae2915c43bca876e9b81e9e1e15bdaebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7793fa5208d5fc1ff3f2a25e06ab34d8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga7793fa5208d5fc1ff3f2a25e06ab34d8">sol_util_memdup</a> (const void *data, size_t len)</td></tr>
<tr class="memdesc:ga7793fa5208d5fc1ff3f2a25e06ab34d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate memory.  <a href="#ga7793fa5208d5fc1ff3f2a25e06ab34d8">More...</a><br/></td></tr>
<tr class="separator:ga7793fa5208d5fc1ff3f2a25e06ab34d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga803075d7e3b618971556ebed7615478e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga803075d7e3b618971556ebed7615478e">sol_util_msec_from_timespec</a> (const struct timespec *ts)</td></tr>
<tr class="memdesc:ga803075d7e3b618971556ebed7615478e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of milliseconds for given time.  <a href="#ga803075d7e3b618971556ebed7615478e">More...</a><br/></td></tr>
<tr class="separator:ga803075d7e3b618971556ebed7615478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ece69bf5fbb994a9610f155a320a165"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga0ece69bf5fbb994a9610f155a320a165">sol_util_replace_str_from_slice_if_changed</a> (char **str, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:ga0ece69bf5fbb994a9610f155a320a165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the string's contents.  <a href="#ga0ece69bf5fbb994a9610f155a320a165">More...</a><br/></td></tr>
<tr class="separator:ga0ece69bf5fbb994a9610f155a320a165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d3f4a639aca2702609ebec66677214"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga67d3f4a639aca2702609ebec66677214">sol_util_replace_str_if_changed</a> (char **str, const char *new_str)</td></tr>
<tr class="memdesc:ga67d3f4a639aca2702609ebec66677214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the string's contents.  <a href="#ga67d3f4a639aca2702609ebec66677214">More...</a><br/></td></tr>
<tr class="separator:ga67d3f4a639aca2702609ebec66677214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce9089a8a805362546f7166d447b598"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gadce9089a8a805362546f7166d447b598">sol_util_size_add</a> (size_t op1, size_t op2, size_t *out)</td></tr>
<tr class="memdesc:gadce9089a8a805362546f7166d447b598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two values checking for overflow.  <a href="#gadce9089a8a805362546f7166d447b598">More...</a><br/></td></tr>
<tr class="separator:gadce9089a8a805362546f7166d447b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27ceaafd5444816bd9e239a67c1aa9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gae27ceaafd5444816bd9e239a67c1aa9e">sol_util_size_mul</a> (size_t op1, size_t op2, size_t *out)</td></tr>
<tr class="memdesc:gae27ceaafd5444816bd9e239a67c1aa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#gae27ceaafd5444816bd9e239a67c1aa9e">More...</a><br/></td></tr>
<tr class="separator:gae27ceaafd5444816bd9e239a67c1aa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa1ea4d4898bc9272755530677f1535"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga4aa1ea4d4898bc9272755530677f1535">sol_util_size_sub</a> (size_t op1, size_t op2, size_t *out)</td></tr>
<tr class="memdesc:ga4aa1ea4d4898bc9272755530677f1535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two values checking for overflow.  <a href="#ga4aa1ea4d4898bc9272755530677f1535">More...</a><br/></td></tr>
<tr class="separator:ga4aa1ea4d4898bc9272755530677f1535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7880de7559ba11c37feba7328d5d789c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga7880de7559ba11c37feba7328d5d789c">sol_util_ssize_mul</a> (ssize_t op1, ssize_t op2, ssize_t *out)</td></tr>
<tr class="memdesc:ga7880de7559ba11c37feba7328d5d789c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#ga7880de7559ba11c37feba7328d5d789c">More...</a><br/></td></tr>
<tr class="separator:ga7880de7559ba11c37feba7328d5d789c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599c379593c1d19c8d6fee209bfec6f3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga599c379593c1d19c8d6fee209bfec6f3">sol_util_strerror</a> (int errnum, struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga599c379593c1d19c8d6fee209bfec6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string from a given error.  <a href="#ga599c379593c1d19c8d6fee209bfec6f3">More...</a><br/></td></tr>
<tr class="separator:ga599c379593c1d19c8d6fee209bfec6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61509e2226afb48a13c558c463a1b3f3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga61509e2226afb48a13c558c463a1b3f3">sol_util_strftime</a> (struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *buf, const char *format, const struct tm *timeptr, bool use_locale) <a class="el" href="group__Macros.html#ga2e2cdb709d0e8332fc1f58b810cde843">SOL_ATTR_STRFTIME</a>(2)</td></tr>
<tr class="memdesc:ga61509e2226afb48a13c558c463a1b3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around strftime()/strftime_l()  <a href="#ga61509e2226afb48a13c558c463a1b3f3">More...</a><br/></td></tr>
<tr class="separator:ga61509e2226afb48a13c558c463a1b3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ced42ebb7bc5c837a0aeeb22136ddc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga72ced42ebb7bc5c837a0aeeb22136ddc">sol_util_strtod_n</a> (const char *nptr, char **endptr, ssize_t len, bool use_locale)</td></tr>
<tr class="memdesc:ga72ced42ebb7bc5c837a0aeeb22136ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper over strtod() that consumes up to <code>len</code> bytes and may not use a locale.  <a href="#ga72ced42ebb7bc5c837a0aeeb22136ddc">More...</a><br/></td></tr>
<tr class="separator:ga72ced42ebb7bc5c837a0aeeb22136ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd81441c3b5e1ecc88c34c13bce0d249"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gacd81441c3b5e1ecc88c34c13bce0d249">sol_util_strtol_n</a> (const char *nptr, char **endptr, ssize_t len, int base)</td></tr>
<tr class="memdesc:gacd81441c3b5e1ecc88c34c13bce0d249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper over strtol() that consumes up to <code>len</code> bytes.  <a href="#gacd81441c3b5e1ecc88c34c13bce0d249">More...</a><br/></td></tr>
<tr class="separator:gacd81441c3b5e1ecc88c34c13bce0d249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997a4ae0ff4264a7a6f5b6eda35db2be"><td class="memItemLeft" align="right" valign="top">unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga997a4ae0ff4264a7a6f5b6eda35db2be">sol_util_strtoul_n</a> (const char *nptr, char **endptr, ssize_t len, int base)</td></tr>
<tr class="memdesc:ga997a4ae0ff4264a7a6f5b6eda35db2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper over strtoul() that consumes up to <code>len</code> bytes.  <a href="#ga997a4ae0ff4264a7a6f5b6eda35db2be">More...</a><br/></td></tr>
<tr class="separator:ga997a4ae0ff4264a7a6f5b6eda35db2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c708f18f7244e791f2bcfd1c88172e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga86c708f18f7244e791f2bcfd1c88172e">sol_util_timespec_add</a> (const struct timespec *t1, const struct timespec *t2, struct timespec *result)</td></tr>
<tr class="memdesc:ga86c708f18f7244e791f2bcfd1c88172e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum two time values.  <a href="#ga86c708f18f7244e791f2bcfd1c88172e">More...</a><br/></td></tr>
<tr class="separator:ga86c708f18f7244e791f2bcfd1c88172e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844d3517f1567c03759b6e9e5d7f8d9e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga844d3517f1567c03759b6e9e5d7f8d9e">sol_util_timespec_compare</a> (const struct timespec *t1, const struct timespec *t2)</td></tr>
<tr class="memdesc:ga844d3517f1567c03759b6e9e5d7f8d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two time values.  <a href="#ga844d3517f1567c03759b6e9e5d7f8d9e">More...</a><br/></td></tr>
<tr class="separator:ga844d3517f1567c03759b6e9e5d7f8d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5afcef74682dd08e589091603e1e19"><td class="memItemLeft" align="right" valign="top">static struct timespec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gadf5afcef74682dd08e589091603e1e19">sol_util_timespec_from_msec</a> (int msec)</td></tr>
<tr class="memdesc:gadf5afcef74682dd08e589091603e1e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>struct</code> timespec from milliseconds.  <a href="#gadf5afcef74682dd08e589091603e1e19">More...</a><br/></td></tr>
<tr class="separator:gadf5afcef74682dd08e589091603e1e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b18696d4ca894a0a0a281cd98f90c66"><td class="memItemLeft" align="right" valign="top">static struct timespec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga9b18696d4ca894a0a0a281cd98f90c66">sol_util_timespec_from_usec</a> (int usec)</td></tr>
<tr class="memdesc:ga9b18696d4ca894a0a0a281cd98f90c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>struct</code> timespec from microseconds.  <a href="#ga9b18696d4ca894a0a0a281cd98f90c66">More...</a><br/></td></tr>
<tr class="separator:ga9b18696d4ca894a0a0a281cd98f90c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ce4e370b335210cfc9f5b11c282c28"><td class="memItemLeft" align="right" valign="top">struct timespec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga57ce4e370b335210cfc9f5b11c282c28">sol_util_timespec_get_current</a> (void)</td></tr>
<tr class="memdesc:ga57ce4e370b335210cfc9f5b11c282c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current time (Monotonic).  <a href="#ga57ce4e370b335210cfc9f5b11c282c28">More...</a><br/></td></tr>
<tr class="separator:ga57ce4e370b335210cfc9f5b11c282c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0000c794612dcaec7bfec8a10627576d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga0000c794612dcaec7bfec8a10627576d">sol_util_timespec_get_realtime</a> (struct timespec *t)</td></tr>
<tr class="memdesc:ga0000c794612dcaec7bfec8a10627576d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current time (System-wide clock).  <a href="#ga0000c794612dcaec7bfec8a10627576d">More...</a><br/></td></tr>
<tr class="separator:ga0000c794612dcaec7bfec8a10627576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e029d247d32dd0d079d2e00f468cc9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga8e029d247d32dd0d079d2e00f468cc9b">sol_util_timespec_sub</a> (const struct timespec *t1, const struct timespec *t2, struct timespec *result)</td></tr>
<tr class="memdesc:ga8e029d247d32dd0d079d2e00f468cc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two time values.  <a href="#ga8e029d247d32dd0d079d2e00f468cc9b">More...</a><br/></td></tr>
<tr class="separator:ga8e029d247d32dd0d079d2e00f468cc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dce3684d3b7513e464495f031592390"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga1dce3684d3b7513e464495f031592390">sol_util_uint32_mul</a> (uint32_t op1, uint32_t op2, uint32_t *out)</td></tr>
<tr class="memdesc:ga1dce3684d3b7513e464495f031592390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#ga1dce3684d3b7513e464495f031592390">More...</a><br/></td></tr>
<tr class="separator:ga1dce3684d3b7513e464495f031592390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga376aebf311e93dd6da977810bcdd4417"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga376aebf311e93dd6da977810bcdd4417">sol_util_uint64_add</a> (uint64_t op1, uint64_t op2, uint64_t *out)</td></tr>
<tr class="memdesc:ga376aebf311e93dd6da977810bcdd4417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two values checking for overflow.  <a href="#ga376aebf311e93dd6da977810bcdd4417">More...</a><br/></td></tr>
<tr class="separator:ga376aebf311e93dd6da977810bcdd4417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e5f73457828dbb2d2b81250cadb6ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga24e5f73457828dbb2d2b81250cadb6ee">sol_util_uint64_mul</a> (uint64_t op1, uint64_t op2, uint64_t *out)</td></tr>
<tr class="memdesc:ga24e5f73457828dbb2d2b81250cadb6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two values checking for overflow.  <a href="#ga24e5f73457828dbb2d2b81250cadb6ee">More...</a><br/></td></tr>
<tr class="separator:ga24e5f73457828dbb2d2b81250cadb6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7df6638697e10b7c02e5759ef2736c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#gafc7df6638697e10b7c02e5759ef2736c">sol_util_unescape_quotes</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *buf)</td></tr>
<tr class="memdesc:gafc7df6638697e10b7c02e5759ef2736c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unescape a string removing quotes from it.  <a href="#gafc7df6638697e10b7c02e5759ef2736c">More...</a><br/></td></tr>
<tr class="separator:gafc7df6638697e10b7c02e5759ef2736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga739423811b1b2bca8dc71e925ccd09aa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga739423811b1b2bca8dc71e925ccd09aa">sol_util_unicode_code_from_utf8</a> (const uint8_t *buf, size_t buf_len, uint8_t *bytes_read)</td></tr>
<tr class="memdesc:ga739423811b1b2bca8dc71e925ccd09aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a utf-8 character to unicode code.  <a href="#ga739423811b1b2bca8dc71e925ccd09aa">More...</a><br/></td></tr>
<tr class="separator:ga739423811b1b2bca8dc71e925ccd09aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd0f5d95a25cd050c3523b50c5274ca"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga7dd0f5d95a25cd050c3523b50c5274ca">sol_util_usec_from_timespec</a> (const struct timespec *ts)</td></tr>
<tr class="memdesc:ga7dd0f5d95a25cd050c3523b50c5274ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of microseconds for given time.  <a href="#ga7dd0f5d95a25cd050c3523b50c5274ca">More...</a><br/></td></tr>
<tr class="separator:ga7dd0f5d95a25cd050c3523b50c5274ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3">sol_util_utf8_from_unicode_code</a> (uint8_t *buf, size_t buf_len, uint32_t unicode_code)</td></tr>
<tr class="memdesc:ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from unicode code to utf-8 string.  <a href="#ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3">More...</a><br/></td></tr>
<tr class="separator:ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935eb75782e5999a24f950d0218f20f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga935eb75782e5999a24f950d0218f20f3">sol_util_uuid_bytes_from_string</a> (struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> uuid_str, struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *uuid_bytes)</td></tr>
<tr class="memdesc:ga935eb75782e5999a24f950d0218f20f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UUID in string format to a byte array with UUID bytes.  <a href="#ga935eb75782e5999a24f950d0218f20f3">More...</a><br/></td></tr>
<tr class="separator:ga935eb75782e5999a24f950d0218f20f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d7f46816d3af0d591209568477d257"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga24d7f46816d3af0d591209568477d257">sol_util_uuid_gen</a> (bool uppercase, bool with_hyphens, struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *uuid_buf)</td></tr>
<tr class="memdesc:ga24d7f46816d3af0d591209568477d257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new universally unique identifier (UUID) string.  <a href="#ga24d7f46816d3af0d591209568477d257">More...</a><br/></td></tr>
<tr class="separator:ga24d7f46816d3af0d591209568477d257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2cb61d8464feb5d07bed5da82cd6a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga6b2cb61d8464feb5d07bed5da82cd6a2">sol_util_uuid_str_is_valid</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> uuid)</td></tr>
<tr class="memdesc:ga6b2cb61d8464feb5d07bed5da82cd6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given universally unique identifier (UUID), in string form, is valid.  <a href="#ga6b2cb61d8464feb5d07bed5da82cd6a2">More...</a><br/></td></tr>
<tr class="separator:ga6b2cb61d8464feb5d07bed5da82cd6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57490a7717a80d2e579c0132b8be8ad2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utils.html#ga57490a7717a80d2e579c0132b8be8ad2">sol_util_uuid_string_from_bytes</a> (bool uppercase, bool with_hyphens, const uint8_t uuid_bytes[<a class="el" href="group__Macros.html#ga38dd7c61af06bb93b22b32217dfa944d">SOL_STATIC_ARRAY_SIZE</a>(16)], struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *uuid_str)</td></tr>
<tr class="memdesc:ga57490a7717a80d2e579c0132b8be8ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UUID in byte format to UUID string format.  <a href="#ga57490a7717a80d2e579c0132b8be8ad2">More...</a><br/></td></tr>
<tr class="separator:ga57490a7717a80d2e579c0132b8be8ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Contains helpers to manipulate time, error code/string, overflows, encode/decode data and some converters. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga8f1ab5ab1508e066a38673a56b8da661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_util_array_size</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arr</td><td>)</td>
          <td>&#160;&#160;&#160;(sizeof(arr) / sizeof((arr)[0]))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the number of elements in an array. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2coap_2lwm2m-bs-server_8c-example.html#a24">/src/samples/coap/lwm2m-bs-server.c</a>, and <a class="el" href="src_2samples_2coap_2lwm2m-server_8c-example.html#a46">/src/samples/coap/lwm2m-server.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="lwm2m-server_8c.html#a41f1e01b439e15b60cf5730152a9e2e2">create_location_obj()</a>, <a class="el" href="lwm2m-bs-server_8c.html#aef4e7c3aca43eeada6f65597335a068e">delete_all_cb()</a>, <a class="el" href="lwm2m-bs-server_8c.html#aa7de55e6a72b455f4ac4f0f841300fb9">write_sec_one_cb()</a>, and <a class="el" href="lwm2m-bs-server_8c.html#ae7eb8956cc2da1b6e4118d2e8e171f10">write_server_one_cb()</a>.</p>

</div>
</div>
<a class="anchor" id="ga804c3ded16e3a43a661dcff6d0bec378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_util_max</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">        __typeof__(x)_max1 = (x); \</div>
<div class="line">        __typeof__(y)_max2 = (y); \</div>
<div class="line">        (<span class="keywordtype">void</span>)(&amp;_max1 == &amp;_max2); \</div>
<div class="line">        _max1 &gt; _max2 ? _max1 : _max2; \</div>
<div class="line">    })</div>
</div><!-- fragment -->
<p>Gets the maximum value. </p>
<p>This will generate shadowing warnings if the same kind is nested, but the warnings on type mismatch are a fair benefit.</p>
<p>Use temporary variables to address nested call cases. </p>

</div>
</div>
<a class="anchor" id="ga379e823272f1197d0bc1b740cac20c86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_util_min</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">        __typeof__(x)_min1 = (x); \</div>
<div class="line">        __typeof__(y)_min2 = (y); \</div>
<div class="line">        (<span class="keywordtype">void</span>)(&amp;_min1 == &amp;_min2); \</div>
<div class="line">        _min1 &lt; _min2 ? _min1 : _min2; \</div>
<div class="line">    })</div>
</div><!-- fragment -->
<p>Gets the minimum value. </p>
<p>This will generate shadowing warnings if the same kind is nested, but the warnings on type mismatch are a fair benefit.</p>
<p>Use temporary variables to address nested call cases. </p>

</div>
</div>
<a class="anchor" id="gacffae23cc2a51303f86497209d3b4dc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_UTIL_MSEC_PER_SEC&#160;&#160;&#160;1000ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of milliseconds in a second: 1,000. </p>

<p>Referenced by <a class="el" href="group__Utils.html#ga803075d7e3b618971556ebed7615478e">sol_util_msec_from_timespec()</a>, and <a class="el" href="group__Utils.html#gadf5afcef74682dd08e589091603e1e19">sol_util_timespec_from_msec()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2db38244936e0790e93ddfa3f49f960c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_UTIL_NSEC_PER_MSEC&#160;&#160;&#160;1000000ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of nanoseconds in a milliseconds: 1,000,000,000 / 1,000 = 1,000,000. </p>

<p>Referenced by <a class="el" href="group__Utils.html#ga803075d7e3b618971556ebed7615478e">sol_util_msec_from_timespec()</a>, and <a class="el" href="group__Utils.html#gadf5afcef74682dd08e589091603e1e19">sol_util_timespec_from_msec()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4701594d57bacc9fe7a83babfd15d174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_UTIL_NSEC_PER_SEC&#160;&#160;&#160;1000000000ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of nanoseconds in a second: 1,000,000,000. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2crypto_2message-digest_8c-example.html#a11">/src/samples/crypto/message-digest.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="message-digest_8c.html#a5366c50e85344eaf247246178b11bd5b">print_time()</a>, <a class="el" href="group__Utils.html#ga86c708f18f7244e791f2bcfd1c88172e">sol_util_timespec_add()</a>, and <a class="el" href="group__Utils.html#ga8e029d247d32dd0d079d2e00f468cc9b">sol_util_timespec_sub()</a>.</p>

</div>
</div>
<a class="anchor" id="gad882f7c4bc64119c8d53c5eb46e13aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_UTIL_NSEC_PER_USEC&#160;&#160;&#160;1000ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of nanoseconds in a microsecond: 1,000,000,000 / 1,000,000 = 1,000. </p>

<p>Referenced by <a class="el" href="group__Utils.html#ga9b18696d4ca894a0a0a281cd98f90c66">sol_util_timespec_from_usec()</a>, and <a class="el" href="group__Utils.html#ga7dd0f5d95a25cd050c3523b50c5274ca">sol_util_usec_from_timespec()</a>.</p>

</div>
</div>
<a class="anchor" id="gab584188ab3f38605dab8b04aaa85913d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_util_strerrora</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">errnum</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ <a class="code" href="group__Buffer.html#ga397dbea3989940ad0d1243983a7a2204">\</a></div>
<div class="line"><a class="code" href="group__Buffer.html#ga397dbea3989940ad0d1243983a7a2204">        SOL_BUFFER_DECLARE_STATIC</a>(buf ## __COUNT__, 512); <a class="code" href="group__Utils.html#ga599c379593c1d19c8d6fee209bfec6f3">\</a></div>
<div class="line"><a class="code" href="group__Utils.html#ga599c379593c1d19c8d6fee209bfec6f3">        sol_util_strerror</a>((errnum), &amp;buf ## __COUNT__); \</div>
<div class="line">    })</div>
<div class="ttc" id="group__Buffer_html_ga397dbea3989940ad0d1243983a7a2204"><div class="ttname"><a href="group__Buffer.html#ga397dbea3989940ad0d1243983a7a2204">SOL_BUFFER_DECLARE_STATIC</a></div><div class="ttdeci">#define SOL_BUFFER_DECLARE_STATIC(name_, size_)</div><div class="ttdoc">A helper macro to create a static allocated buffer with a fixed capacity. </div><div class="ttdef"><b>Definition:</b> sol-buffer.h:203</div></div>
<div class="ttc" id="group__Utils_html_ga599c379593c1d19c8d6fee209bfec6f3"><div class="ttname"><a href="group__Utils.html#ga599c379593c1d19c8d6fee209bfec6f3">sol_util_strerror</a></div><div class="ttdeci">char * sol_util_strerror(int errnum, struct sol_buffer *buf)</div><div class="ttdoc">Gets a string from a given error. </div></div>
</div><!-- fragment -->
<p>Gets a string from a given error using the stack. </p>
<p>The function returns a pointer to a string (created using the stack) that describes the error code passed in the argument <code>errnum</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>The error code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appropriate error description string.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga599c379593c1d19c8d6fee209bfec6f3" title="Gets a string from a given error. ">sol_util_strerror</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2common_2uart_8c-example.html#a11">/src/samples/common/uart.c</a>, <a class="el" href="src_2samples_2crypto_2message-digest_8c-example.html#a34">/src/samples/crypto/message-digest.c</a>, <a class="el" href="src_2samples_2crypto_2sha256sum_8c-example.html#a40">/src/samples/crypto/sha256sum.c</a>, <a class="el" href="src_2samples_2design_patterns_2stream_sample_8c-example.html#a76">/src/samples/design_patterns/stream_sample.c</a>, <a class="el" href="src_2samples_2flow_2c-api_2single-node_8c-example.html#a11">/src/samples/flow/c-api/single-node.c</a>, <a class="el" href="src_2samples_2http_2server-sse_8c-example.html#a13">/src/samples/http/server-sse.c</a>, <a class="el" href="src_2samples_2http_2server_8c-example.html#a10">/src/samples/http/server.c</a>, <a class="el" href="src_2samples_2mavlink_2basic_8c-example.html#a6">/src/samples/mavlink/basic.c</a>, <a class="el" href="src_2samples_2mavlink_2goto_8c-example.html#a6">/src/samples/mavlink/goto.c</a>, and <a class="el" href="src_2samples_2network_2echo-server_8c-example.html#a37">/src/samples/network/echo-server.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="single-node_8c.html#a558a1a7f379d050200743d2bcb5fb620">get_int32_packet_and_log()</a>, <a class="el" href="basic_8c.html#ad29bbe8a9dce491f048c1aa22021fe15">mavlink_connect_cb()</a>, <a class="el" href="basic_8c.html#ab34b282da15b5a49106699ddd559b52e">mission_reached_cb()</a>, <a class="el" href="basic_8c.html#ab0c64db3ed9f0c3d4df2cffa279e12cc">mode_changed_cb()</a>, <a class="el" href="stream__sample_8c.html#a35dc30440509d1cc850f88847ee59abf">on_feed_done()</a>, <a class="el" href="server-sse_8c.html#ae15b6636fe22ea3bfcca92f512cbf3db">on_stdin()</a>, <a class="el" href="sha256sum_8c.html#afc7855e4b6972e4d50f909d42dd67776">on_stdin_hash()</a>, <a class="el" href="basic_8c.html#a36dfa5adb36c28f7c4648de2f3bf11fd">position_changed_cb()</a>, <a class="el" href="uart_8c.html#a8694ec865bfd7b8d243ca28de0957684">producer_data_written()</a>, <a class="el" href="uart_8c.html#af9f6c5e151a851d960a38b4d4b1cb432">producer_make_data()</a>, <a class="el" href="uart_8c.html#ac7f3be202700792259fedf833dcf695a">send_blob()</a>, <a class="el" href="message-digest_8c.html#a8f65ca9f5a72be7fe776126fc632f8a9">startup()</a>, <a class="el" href="echo-server_8c.html#a01f52f14b9e6dd3c57b905c4db4213bf">startup_server()</a>, and <a class="el" href="basic_8c.html#acc98c288a5a11d0ada82dd7bd1c164f8">takeoff()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6bb032a38daa31c3a18febd3a3802bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_util_uint16_bytes_swap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val</td><td>)</td>
          <td>&#160;&#160;&#160;((uint16_t)((((val) &gt;&gt; 8) &amp; 0xff) | (((val) &amp; 0xff) &lt;&lt; 8)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the bytes of a 16 bytes unsigned int. </p>

<p>Referenced by <a class="el" href="group__Utils.html#gaf0258d91cf52518556da4570df97abee">sol_util_be16_to_cpu()</a>, <a class="el" href="group__Utils.html#ga807cecfed816870ec5aad29126c3b9cc">sol_util_cpu_to_be16()</a>, <a class="el" href="group__Utils.html#ga006f1fe01c984b58a6445b5334234e66">sol_util_cpu_to_le16()</a>, and <a class="el" href="group__Utils.html#ga64996cc23e42c0b4f31724082abd1899">sol_util_le16_to_cpu()</a>.</p>

</div>
</div>
<a class="anchor" id="ga11c3f12c43a911abc9955e8e762b541e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_util_uint32_bytes_swap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint32_t)((((val) &amp; 0xff000000) &gt;&gt; 24) | (((val) &amp; 0x00ff0000) &gt;&gt;  8) | \</div>
<div class="line">    (((val) &amp; 0x0000ff00) &lt;&lt;  8) | (((val) &amp; 0x000000ff) &lt;&lt; 24)))</div>
</div><!-- fragment -->
<p>Swaps the bytes of a 32 bytes unsigned int. </p>

<p>Referenced by <a class="el" href="group__Utils.html#gacaa5f58ed390da32d8a8da3bb6b5a5b4">sol_util_be32_to_cpu()</a>, <a class="el" href="group__Utils.html#ga46889a42b373c4ac375daa6768a41d2b">sol_util_cpu_to_be32()</a>, <a class="el" href="group__Utils.html#gac3b9c092ef1f91d460f88b2959c1705b">sol_util_cpu_to_le32()</a>, and <a class="el" href="group__Utils.html#ga8d7e7d152e57a0c330bd464cd3367ae8">sol_util_le32_to_cpu()</a>.</p>

</div>
</div>
<a class="anchor" id="gafc8ccb9b5905ae07af1e161bf98438af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sol_util_uint64_bytes_swap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((uint64_t)((((val) &amp; 0xff00000000000000ull) &gt;&gt; 56) \</div>
<div class="line">    | (((val) &amp; 0x00ff000000000000ull) &gt;&gt; 40) | (((val) &amp; 0x0000ff0000000000ull) &gt;&gt; 24) \</div>
<div class="line">    | (((val) &amp; 0x000000ff00000000ull) &gt;&gt; 8) | (((val) &amp; 0x00000000ff000000ull) &lt;&lt; 8) \</div>
<div class="line">    | (((val) &amp; 0x0000000000ff0000ull) &lt;&lt; 24) | (((val) &amp; 0x000000000000ff00ull) &lt;&lt; 40) \</div>
<div class="line">    | (((val) &amp; 0x00000000000000ffull) &lt;&lt; 56)))</div>
</div><!-- fragment -->
<p>Swaps the bytes of a 32 bytes unsigned int. </p>

<p>Referenced by <a class="el" href="group__Utils.html#ga5a4d62e1f14e4ed9bebc91629e37fd5c">sol_util_be64_to_cpu()</a>, <a class="el" href="group__Utils.html#ga7f1258b67f97da5bc01852684c87e998">sol_util_cpu_to_be64()</a>, <a class="el" href="group__Utils.html#ga31039a248872ad9123ffb4d7dd09ebee">sol_util_cpu_to_le64()</a>, and <a class="el" href="group__Utils.html#gae2915c43bca876e9b81e9e1e15bdaebd">sol_util_le64_to_cpu()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5becbe54da45aaa016e8ee4f47f36b8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_UTIL_USEC_PER_SEC&#160;&#160;&#160;1000000ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of microseconds in a second: 1,000,000. </p>

<p>Referenced by <a class="el" href="group__Utils.html#ga9b18696d4ca894a0a0a281cd98f90c66">sol_util_timespec_from_usec()</a>, and <a class="el" href="group__Utils.html#ga7dd0f5d95a25cd050c3523b50c5274ca">sol_util_usec_from_timespec()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa52ea19a1852e9e838a1ec40ffa39f30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sol_util_base16_calculate_decoded_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the size necessary to decode a given slice in base16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice that is wanted to know the decoded size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size that will be utilized to decode the <code>slice</code> or a negative number on error. </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d9b7bbe9d55e8a0ef3c0685bae56625"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sol_util_base16_calculate_encoded_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the size necessary to encode a given slice in base16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice that is wanted to know the encoded size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size that will be utilized to encode the <code>slice</code> or a negative number on error. </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>, and <a class="el" href="group__Utils.html#ga7880de7559ba11c37feba7328d5d789c">sol_util_ssize_mul()</a>.</p>

</div>
</div>
<a class="anchor" id="gac4089d5876b27d70240b2ad07d4b6f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_base16_decode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__Buffer.html#ga06c94d5ad12e5abae2f881a53c6becf8">sol_decode_case</a>&#160;</td>
          <td class="paramname"><em>decode_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the binary slice from base16 (hexadecimal). </p>
<dl class="section note"><dt>Note</dt><dd><b>no</b> trailing null '\0' is added!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>a buffer of size <em>buflen</em> that is big enough to hold the decoded string. </td></tr>
    <tr><td class="paramname">buflen</td><td>the number of bytes available in buffer. Must be large enough to contain the decoded slice, that is: slice.len / 2. </td></tr>
    <tr><td class="paramname">slice</td><td>the slice to decode, it must be a set of 0-9 or letters A-F (if uppercase) or a-f, otherwise decode fails. </td></tr>
    <tr><td class="paramname">decode_case</td><td>if SOL_DECODE_UPPERCASE, uppercase letters ABCDEF are used, if SOL_DECODE_LOWERCASE, lowercase abcdef are used instead. If SOL_DECODE_BOTH both, lowercase and uppercase, letters can be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or -errno if failed. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2coap_2lwm2m-bs-server_8c-example.html#a58">/src/samples/coap/lwm2m-bs-server.c</a>, <a class="el" href="src_2samples_2coap_2lwm2m-client_8c-example.html#a173">/src/samples/coap/lwm2m-client.c</a>, and <a class="el" href="src_2samples_2coap_2lwm2m-server_8c-example.html#a71">/src/samples/coap/lwm2m-server.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="lwm2m-bs-server_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ga42409b41553e6878466722ab17ddc27d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_base16_encode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uppercase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the binary slice to base16 (hexadecimal). </p>
<dl class="section note"><dt>Note</dt><dd><b>no</b> trailing null '\0' is added!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>a buffer of size <em>buflen</em> that is big enough to hold the encoded string. </td></tr>
    <tr><td class="paramname">buflen</td><td>the number of bytes available in buffer. Must be large enough to contain the encoded slice, that is: slice.len * 2 </td></tr>
    <tr><td class="paramname">slice</td><td>the slice to encode, it may contain null-bytes (\0), the whole size of the slice will be used (slice.len). </td></tr>
    <tr><td class="paramname">uppercase</td><td>if true, uppercase letters ABCDEF are used, otherwise lowercase abcdef are used instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or -errno if failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f2630baa157de5d41f25f527a185501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_base64_calculate_decoded_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>base64_map</em>[SOL_STATIC_ARRAY_SIZE(65)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the size necessary to decode a given slice in base64. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice that is wanted to know the decode size. </td></tr>
    <tr><td class="paramname">base64_map</td><td>the map to use. The last char is used as the padding character if slice length is not multiple of 3 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size that will be utilized to decode the <code>slice</code> or a negative number on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4177d45ab373433b10e72e059253b46d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sol_util_base64_calculate_encoded_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>base64_map</em>[SOL_STATIC_ARRAY_SIZE(65)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the size necessary to encode a given slice in base64. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice that is wanted to know the encoded size. </td></tr>
    <tr><td class="paramname">base64_map</td><td>the map to use. The last char is used as the padding character if slice length is not multiple of 3 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size that will be utilized to encode the <code>slice</code> or a negative number on error. </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>, and <a class="el" href="group__Utils.html#ga7880de7559ba11c37feba7328d5d789c">sol_util_ssize_mul()</a>.</p>

</div>
</div>
<a class="anchor" id="ga19e2b3856ee9a879658c868b80050970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_base64_decode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>base64_map</em>[SOL_STATIC_ARRAY_SIZE(65)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the binary slice from base64 using the given map. </p>
<p><a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a></p>
<dl class="section note"><dt>Note</dt><dd><b>no</b> trailing null '\0' is added!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>a buffer of size <em>buflen</em> that is big enough to hold the decoded string. </td></tr>
    <tr><td class="paramname">buflen</td><td>the number of bytes available in buffer. Must be large enough to contain the decoded slice, that is: (slice.len / 4) * 3 </td></tr>
    <tr><td class="paramname">slice</td><td>the slice to decode, it must be composed solely of the base64_map characters or it will fail. </td></tr>
    <tr><td class="paramname">base64_map</td><td>the map to use. The last char is used as the padding character if slice length is not multiple of 3 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or -errno if failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7228f93dcb7e29a7eb594624265997d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_base64_encode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>base64_map</em>[SOL_STATIC_ARRAY_SIZE(65)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the binary slice to base64 using the given map. </p>
<p><a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a></p>
<dl class="section note"><dt>Note</dt><dd><b>no</b> trailing null '\0' is added!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>a buffer of size <em>buflen</em> that is big enough to hold the encoded string. </td></tr>
    <tr><td class="paramname">buflen</td><td>the number of bytes available in buffer. Must be large enough to contain the encoded slice, that is: (slice.len / 3 + 1) * 4 </td></tr>
    <tr><td class="paramname">slice</td><td>the slice to encode, it may contain null-bytes (\0), the whole size of the slice will be used (slice.len). </td></tr>
    <tr><td class="paramname">base64_map</td><td>the map to use. The last char is used as the padding character if slice length is not multiple of 3 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or -errno if failed. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0258d91cf52518556da4570df97abee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t sol_util_be16_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 16 bytes big endian integer to cpu endianness. </p>
<p>This function converts a integer of 16 bytes to little endian format, in case of the integer being in the cpu endiannesst nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint16_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga64996cc23e42c0b4f31724082abd1899" title="Convert a 16 bytes little endian integer to cpu endianness. ">sol_util_le16_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga6bb032a38daa31c3a18febd3a3802bb7">sol_util_uint16_bytes_swap</a>.</p>

<p>Referenced by <a class="el" href="group__Network.html#ga74a815293eed73cb9af2501f7a3b92a0">sol_network_link_addr_eq_full()</a>.</p>

</div>
</div>
<a class="anchor" id="gacaa5f58ed390da32d8a8da3bb6b5a5b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sol_util_be32_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 32 bytes big endian integer to cpu endianness. </p>
<p>This function converts a integer of 32 bytes to little endian format, in case of the integer being in the cpu endiannesst nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint32_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga8d7e7d152e57a0c330bd464cd3367ae8" title="Convert a 32 bytes little endian integer to cpu endianness. ">sol_util_le32_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga11c3f12c43a911abc9955e8e762b541e">sol_util_uint32_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a4d62e1f14e4ed9bebc91629e37fd5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sol_util_be64_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 64 bytes big endian integer to cpu endianness. </p>
<p>This function converts a integer of 64 bytes to little endian format, in case of the integer being in the cpu endiannesst nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint64_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gae2915c43bca876e9b81e9e1e15bdaebd" title="Convert a 64 bytes little endian integer to cpu endianness. ">sol_util_le64_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#gafc8ccb9b5905ae07af1e161bf98438af">sol_util_uint64_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga8dd7654cbc5e20ca25d9a2d55fe718de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sol_util_clear_memory_secure </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear an allocated memory securely. </p>
<p>Clobber memory pointed to by <code>buf</code> to prevent the optimizer from eliding the <code>memset()</code> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The memory block </td></tr>
    <tr><td class="paramname">len</td><td>The buf length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga807cecfed816870ec5aad29126c3b9cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t sol_util_cpu_to_be16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 16 bytes integer to big endian format. </p>
<p>This function converts a integer of 16 bytes to big endian format, in case of the integer being in big endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint16_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on big endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga006f1fe01c984b58a6445b5334234e66" title="Convert a 16 bytes integer to little endian format. ">sol_util_cpu_to_le16</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga6bb032a38daa31c3a18febd3a3802bb7">sol_util_uint16_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga46889a42b373c4ac375daa6768a41d2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sol_util_cpu_to_be32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 32 bytes integer to big endian format. </p>
<p>This function converts a integer of 32 bytes to big endian format, in case of the integer being in big endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint32_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on big endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gac3b9c092ef1f91d460f88b2959c1705b" title="Convert a 32 bytes integer to little endian format. ">sol_util_cpu_to_le32</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga11c3f12c43a911abc9955e8e762b541e">sol_util_uint32_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga7f1258b67f97da5bc01852684c87e998"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sol_util_cpu_to_be64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 64 bytes integer to big endian format. </p>
<p>This function converts a integer of 64 bytes to big endian format, in case of the integer being in big endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint64_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on big endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga31039a248872ad9123ffb4d7dd09ebee" title="Convert a 64 bytes integer to little endian format. ">sol_util_cpu_to_le64</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#gafc8ccb9b5905ae07af1e161bf98438af">sol_util_uint64_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga006f1fe01c984b58a6445b5334234e66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t sol_util_cpu_to_le16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 16 bytes integer to little endian format. </p>
<p>This function converts a integer of 16 bytes to little endian format, in case of the integer being in little endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint16_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga807cecfed816870ec5aad29126c3b9cc" title="Convert a 16 bytes integer to big endian format. ">sol_util_cpu_to_be16</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga6bb032a38daa31c3a18febd3a3802bb7">sol_util_uint16_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="gac3b9c092ef1f91d460f88b2959c1705b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sol_util_cpu_to_le32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 32 bytes integer to little endian format. </p>
<p>This function converts a integer of 32 bytes to little endian format, in case of the integer being in little endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint32_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga46889a42b373c4ac375daa6768a41d2b" title="Convert a 32 bytes integer to big endian format. ">sol_util_cpu_to_be32</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga11c3f12c43a911abc9955e8e762b541e">sol_util_uint32_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga31039a248872ad9123ffb4d7dd09ebee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sol_util_cpu_to_le64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 64 bytes integer to little endian format. </p>
<p>This function converts a integer of 64 bytes to little endian format, in case of the integer being in little endian format nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint64_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga7f1258b67f97da5bc01852684c87e998" title="Convert a 64 bytes integer to big endian format. ">sol_util_cpu_to_be64</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#gafc8ccb9b5905ae07af1e161bf98438af">sol_util_uint64_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="gaa234717286ed1c78df5c0f7c15122446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_util_double_eq </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>var0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>var1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks <code>var0</code> and <code>var1</code> for equality. </p>
<p>It uses relative comparison to account for impressions caused by floating point arithmetics, so give preference to use this function instead of comparing the numbers directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var0</td><td>First argument </td></tr>
    <tr><td class="paramname">var1</td><td>Second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both values are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga148a2d09a5cb34ca70ba282eb67ddf8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t sol_util_int32_clamp </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts a number between two other numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Minimum value. </td></tr>
    <tr><td class="paramname">end</td><td>Maximum value. </td></tr>
    <tr><td class="paramname">value</td><td>The value to clamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>value</code> if living in the range imposed by the <code>start</code> and <code>end</code>, the lower value if initially lower than <code>start</code>, or the higher one if initially higher than <code>end</code>. </dd></dl>

<p>References <a class="el" href="server_8c.html#acda54b23a3b92ae2efa63634288c0496">value</a>.</p>

</div>
</div>
<a class="anchor" id="gafcbe8afdb019a2b050ad8ab16cb8954f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_int32_mul </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiplies two variables of the type <code>int32_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaad10a7a75f9b1e34ef1e044fb73f80ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_int64_mul </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiply two variables of the type <code>int64_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga24e5f73457828dbb2d2b81250cadb6ee" title="Multiply two values checking for overflow. ">sol_util_uint64_mul</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga64996cc23e42c0b4f31724082abd1899"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t sol_util_le16_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 16 bytes little endian integer to cpu endianness. </p>
<p>This function converts a integer of 16 bytes to little endian format, in case of the integer being in the cpu endianness nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint16_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gaf0258d91cf52518556da4570df97abee" title="Convert a 16 bytes big endian integer to cpu endianness. ">sol_util_be16_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga6bb032a38daa31c3a18febd3a3802bb7">sol_util_uint16_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga8d7e7d152e57a0c330bd464cd3367ae8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sol_util_le32_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 32 bytes little endian integer to cpu endianness. </p>
<p>This function converts a integer of 32 bytes to little endian format, in case of the integer being in the cpu endianness nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint32_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gacaa5f58ed390da32d8a8da3bb6b5a5b4" title="Convert a 32 bytes big endian integer to cpu endianness. ">sol_util_be32_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#ga11c3f12c43a911abc9955e8e762b541e">sol_util_uint32_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="gae2915c43bca876e9b81e9e1e15bdaebd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sol_util_le64_to_cpu </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a 64 bytes little endian integer to cpu endianness. </p>
<p>This function converts a integer of 64 bytes to little endian format, in case of the integer being in the cpu endianness nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the uint64_t number to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given value on little endian format.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga5a4d62e1f14e4ed9bebc91629e37fd5c" title="Convert a 64 bytes big endian integer to cpu endianness. ">sol_util_be64_to_cpu</a> </dd></dl>

<p>References <a class="el" href="group__Utils.html#gafc8ccb9b5905ae07af1e161bf98438af">sol_util_uint64_bytes_swap</a>.</p>

</div>
</div>
<a class="anchor" id="ga7793fa5208d5fc1ff3f2a25e06ab34d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sol_util_memdup </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate memory. </p>
<p>It's a helper function to allocated memory and copy data, returning the pointer to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the memory to be copied </td></tr>
    <tr><td class="paramname">len</td><td>Size in bytes of the memory to be allocated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid pointer to the allocated memory, with copied data or <code>NULL</code> if it fails to allocate it. The pointer need to be freed after usage. </dd></dl>

</div>
</div>
<a class="anchor" id="ga803075d7e3b618971556ebed7615478e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sol_util_msec_from_timespec </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of milliseconds for given time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts</td><td>The struct timespec to get the milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of milliseconds on <code>ts</code>. </dd></dl>

<p>References <a class="el" href="group__Utils.html#gacffae23cc2a51303f86497209d3b4dc2">SOL_UTIL_MSEC_PER_SEC</a>, and <a class="el" href="group__Utils.html#ga2db38244936e0790e93ddfa3f49f960c">SOL_UTIL_NSEC_PER_MSEC</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ece69bf5fbb994a9610f155a320a165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_replace_str_from_slice_if_changed </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the string's contents. </p>
<p>This function takes a string and replace its contents if different from the new given slice, otherwise it lets the string intact.</p>
<dl class="section note"><dt>Note</dt><dd>If the string is replaced its memory is properly released.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The pointer for string which will be changed. </td></tr>
    <tr><td class="paramname">slice</td><td>The slice with string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if changed, 0 if unchanged, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>util_replace_str_from_slice_if_changed </dd></dl>

</div>
</div>
<a class="anchor" id="ga67d3f4a639aca2702609ebec66677214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_replace_str_if_changed </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the string's contents. </p>
<p>This function takes a string and replace its contents if different from the new given string, otherwise it lets the string intact.</p>
<dl class="section note"><dt>Note</dt><dd>If the string is replaced its memory is properly released.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The pointer for string which will be changed. </td></tr>
    <tr><td class="paramname">new_str</td><td>The new string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if changed, 0 if unchanged, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>util_replace_str_from_slice_if_changed </dd></dl>

</div>
</div>
<a class="anchor" id="gadce9089a8a805362546f7166d447b598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_size_add </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two values checking for overflow. </p>
<p>This function adds two variables of the type <code>size_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga4aa1ea4d4898bc9272755530677f1535" title="Subtract two values checking for overflow. ">sol_util_size_sub</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae27ceaafd5444816bd9e239a67c1aa9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_size_mul </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiply two variables of the type <code>size_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#ga7880de7559ba11c37feba7328d5d789c" title="Multiply two values checking for overflow. ">sol_util_ssize_mul</a> </dd></dl>

<p>Referenced by <a class="el" href="sol-glib-integration_8h.html#a47d65d9a67a44844b350f7e916f3f060">_sol_glib_integration_source_prepare()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4aa1ea4d4898bc9272755530677f1535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_size_sub </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract two values checking for overflow. </p>
<p>This function subtracts two variables of the type <code>size_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gadce9089a8a805362546f7166d447b598" title="Add two values checking for overflow. ">sol_util_size_add</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7880de7559ba11c37feba7328d5d789c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_ssize_mul </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiply two variables of the type <code>ssize_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gae27ceaafd5444816bd9e239a67c1aa9e" title="Multiply two values checking for overflow. ">sol_util_size_mul</a> </dd></dl>

<p>Referenced by <a class="el" href="group__Utils.html#ga1d9b7bbe9d55e8a0ef3c0685bae56625">sol_util_base16_calculate_encoded_len()</a>, and <a class="el" href="group__Utils.html#ga4177d45ab373433b10e72e059253b46d">sol_util_base64_calculate_encoded_len()</a>.</p>

</div>
</div>
<a class="anchor" id="ga599c379593c1d19c8d6fee209bfec6f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* sol_util_strerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a string from a given error. </p>
<p>The function returns a pointer to a string that describes the error code passed in the argument <code>errnum</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>The error code </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer used to append error the string - It must be already initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the appropriate error description string.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gab584188ab3f38605dab8b04aaa85913d" title="Gets a string from a given error using the stack. ">sol_util_strerrora</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga61509e2226afb48a13c558c463a1b3f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_util_strftime </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>timeptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_locale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around strftime()/strftime_l() </p>
<p>This is a simple wrapper around strftime()/strftime_l() functions. The <code>use_locale</code> parameter is only considered if strftime_l() and newlocale() are available, otherwise this wrapper will fallback to strftime() - Thus current system's locale will be considered when formatting the time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to append the formatted time to - It must be already initialzed. </td></tr>
    <tr><td class="paramname">format</td><td>The date format - check strftime man page for accepted formats. </td></tr>
    <tr><td class="paramname">timeptr</td><td>The broken down time struct. </td></tr>
    <tr><td class="paramname">use_locale</td><td>true to use current system locale or false to do not use system's locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, negative errno or 0 on error. (see strftime man page). </dd></dl>

</div>
</div>
<a class="anchor" id="ga72ced42ebb7bc5c837a0aeeb22136ddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double sol_util_strtod_n </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_locale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper over strtod() that consumes up to <code>len</code> bytes and may not use a locale. </p>
<p>This variation of strtod() will work with buffers that are not null-terminated.</p>
<p>It also offers a way to skip the currently set locale, forcing plain "C". This is required to parse numbers in formats that require '.' as the decimal point while the current locale may use ',' such as in pt_BR.</p>
<p>All the formats accepted by strtod() are accepted and the behavior should be the same, including using information from <code>LC_NUMERIC</code> if locale is configured and <em>use_locale</em> is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>the string containing the number to convert. </td></tr>
    <tr><td class="paramname">endptr</td><td>if non-NULL, it will contain the last character used in the conversion. If no conversion was done, endptr is <em>nptr</em>. </td></tr>
    <tr><td class="paramname">use_locale</td><td>if true, then current locale is used, if false then "C" locale is forced.</td></tr>
    <tr><td class="paramname">len</td><td>use at most this amount of bytes of <em>nptr</em>. If -1, assumes nptr has a trailing NUL and calculate the string length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value, if any. The converted value may be <code>NAN</code>, <code>INF</code> (positive or negative). See the strtod(3) documentation for the details. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2coap_2lwm2m-client_8c-example.html#a65">/src/samples/coap/lwm2m-client.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="lwm2m-client_8c.html#a5bbe2753246ccd77b921740c497d2dca">create_location_obj()</a>.</p>

</div>
</div>
<a class="anchor" id="gacd81441c3b5e1ecc88c34c13bce0d249"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int sol_util_strtol_n </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper over strtol() that consumes up to <code>len</code> bytes. </p>
<p>This variation of strtol() will work with buffers that are not null-terminated.</p>
<p>All the formats accepted by strtol() are accepted and the behavior should be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>the string containing the number to convert.</td></tr>
    <tr><td class="paramname">endptr</td><td>if non-NULL, it will contain the last character used in the conversion. If no conversion was done, endptr is <em>nptr</em>.</td></tr>
    <tr><td class="paramname">len</td><td>use at most this amount of bytes of <em>nptr</em>. If -1, assumes nptr has a trailing NUL and calculate the string length.</td></tr>
    <tr><td class="paramname">base</td><td>it's the base of conversion, which must be between 2 and 36 inclusive, or be the special value 0. A zero base is taken as 10 (decimal) unless the next character is '0', in which case it is taken as 8 (octal).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value, if any. </dd></dl>

</div>
</div>
<a class="anchor" id="ga997a4ae0ff4264a7a6f5b6eda35db2be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long int sol_util_strtoul_n </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper over strtoul() that consumes up to <code>len</code> bytes. </p>
<p>This variation of strtoul() will work with buffers that are not null-terminated.</p>
<p>All the formats accepted by strtoul() are accepted and the behavior should be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>the string containing the number to convert.</td></tr>
    <tr><td class="paramname">endptr</td><td>if non-NULL, it will contain the last character used in the conversion. If no conversion was done, endptr is <em>nptr</em>.</td></tr>
    <tr><td class="paramname">len</td><td>use at most this amount of bytes of <em>nptr</em>. If -1, assumes nptr has a trailing NUL and calculate the string length.</td></tr>
    <tr><td class="paramname">base</td><td>it's the base of conversion, which must be between 2 and 36 inclusive, or be the special value 0. A zero base is taken as 10 (decimal) unless the next character is '0', in which case it is taken as 8 (octal).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value, if any. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86c708f18f7244e791f2bcfd1c88172e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sol_util_timespec_add </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum two time values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>First time value used on operation. </td></tr>
    <tr><td class="paramname">t2</td><td>Second time value used on operation. </td></tr>
    <tr><td class="paramname">result</td><td>Variable used to store the sum's result. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__Utils.html#ga4701594d57bacc9fe7a83babfd15d174">SOL_UTIL_NSEC_PER_SEC</a>.</p>

</div>
</div>
<a class="anchor" id="ga844d3517f1567c03759b6e9e5d7f8d9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sol_util_timespec_compare </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two time values. </p>
<p>Function to compare two times. It returns an integer less than, equal to, or greater than zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>First time value used on operation. </td></tr>
    <tr><td class="paramname">t2</td><td>Second time value used on operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if equal, -1 if t2 is greater or 1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf5afcef74682dd08e589091603e1e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct timespec sol_util_timespec_from_msec </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code>struct</code> timespec from milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msec</td><td>The number of milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>struct</code> timespec representing <code>msec</code> milliseconds. </dd></dl>

<p>References <a class="el" href="group__Utils.html#gacffae23cc2a51303f86497209d3b4dc2">SOL_UTIL_MSEC_PER_SEC</a>, and <a class="el" href="group__Utils.html#ga2db38244936e0790e93ddfa3f49f960c">SOL_UTIL_NSEC_PER_MSEC</a>.</p>

<p>Referenced by <a class="el" href="sol-glib-integration_8h.html#a0da04329ee258220d04a8b3aa9d40fdc">_sol_glib_integration_source_get_next_timeout()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b18696d4ca894a0a0a281cd98f90c66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct timespec sol_util_timespec_from_usec </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>usec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code>struct</code> timespec from microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usec</td><td>The number of microseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>struct</code> timespec representing <code>usec</code> microseconds. </dd></dl>

<p>References <a class="el" href="group__Utils.html#gad882f7c4bc64119c8d53c5eb46e13aa8">SOL_UTIL_NSEC_PER_USEC</a>, and <a class="el" href="group__Utils.html#ga5becbe54da45aaa016e8ee4f47f36b8b">SOL_UTIL_USEC_PER_SEC</a>.</p>

</div>
</div>
<a class="anchor" id="ga57ce4e370b335210cfc9f5b11c282c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct timespec sol_util_timespec_get_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current time (Monotonic). </p>
<dl class="section return"><dt>Returns</dt><dd>The current time represented in <code>struct</code> timespec. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2crypto_2message-digest_8c-example.html#a7">/src/samples/crypto/message-digest.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="message-digest_8c.html#a5366c50e85344eaf247246178b11bd5b">print_time()</a>, and <a class="el" href="message-digest_8c.html#a8f65ca9f5a72be7fe776126fc632f8a9">startup()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0000c794612dcaec7bfec8a10627576d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_timespec_get_realtime </td>
          <td>(</td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current time (System-wide clock). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Variable used to store the time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, or -1 for failure (in which case errno is set appropriately). </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e029d247d32dd0d079d2e00f468cc9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sol_util_timespec_sub </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts two time values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>First time value used on operation. </td></tr>
    <tr><td class="paramname">t2</td><td>Second time value used on operation. </td></tr>
    <tr><td class="paramname">result</td><td>Variable used to store the subtraction's result. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2crypto_2message-digest_8c-example.html#a9">/src/samples/crypto/message-digest.c</a>.</dd>
</dl>
<p>References <a class="el" href="group__Utils.html#ga4701594d57bacc9fe7a83babfd15d174">SOL_UTIL_NSEC_PER_SEC</a>.</p>

<p>Referenced by <a class="el" href="message-digest_8c.html#a5366c50e85344eaf247246178b11bd5b">print_time()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1dce3684d3b7513e464495f031592390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_uint32_mul </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiplies two variables of the type <code>int64_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga376aebf311e93dd6da977810bcdd4417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_uint64_add </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two values checking for overflow. </p>
<p>This function add two variables of the type <code>uint64_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gadce9089a8a805362546f7166d447b598" title="Add two values checking for overflow. ">sol_util_size_add</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga24e5f73457828dbb2d2b81250cadb6ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_uint64_mul </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two values checking for overflow. </p>
<p>This function multiply two unsigned variables of the type <code>uint64_t</code> and check if this operation causes an overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>First operation's operator. </td></tr>
    <tr><td class="paramname">op2</td><td>Second operation's operator. </td></tr>
    <tr><td class="paramname">out</td><td>Variable used to store the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Utils.html#gaad10a7a75f9b1e34ef1e044fb73f80ae" title="Multiply two values checking for overflow. ">sol_util_int64_mul</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafc7df6638697e10b7c02e5759ef2736c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_unescape_quotes </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unescape a string removing quotes from it. </p>
<p>This function will unescape single quotes (\') and double quotes (") from the slice, it will also remove single and double quotes from the string if they are not escaped. Trying to unescape a character that is not a single quote or double quote it is also considered an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice to be escaped </td></tr>
    <tr><td class="paramname">buf</td><td>- The buffer to hold the unescaped string - It will be initialized by this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga739423811b1b2bca8dc71e925ccd09aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t sol_util_unicode_code_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bytes_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a utf-8 character to unicode code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer with the utf-8 representation of the unicode character. </td></tr>
    <tr><td class="paramname">buf_len</td><td>The buffer length. </td></tr>
    <tr><td class="paramname">bytes_read</td><td>Optional pointer to variable to write number of bytes read from buf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The code from unicode table of the character in 'buf' or a negative number on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7dd0f5d95a25cd050c3523b50c5274ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sol_util_usec_from_timespec </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of microseconds for given time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts</td><td>The struct timespec to get the microseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of microseconds on <code>ts</code>. </dd></dl>

<p>References <a class="el" href="group__Utils.html#gad882f7c4bc64119c8d53c5eb46e13aa8">SOL_UTIL_NSEC_PER_USEC</a>, and <a class="el" href="group__Utils.html#ga5becbe54da45aaa016e8ee4f47f36b8b">SOL_UTIL_USEC_PER_SEC</a>.</p>

</div>
</div>
<a class="anchor" id="ga83d5b9e4ac3f4e96cf3b0df7d1c8edd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t sol_util_utf8_from_unicode_code </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>unicode_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from unicode code to utf-8 string. </p>
<p>Write at string buf the bytes needed to represent the unicode charater informed as utf-8. One to four characters will be written on success. No character is written on error.</p>
<dl class="section note"><dt>Note</dt><dd><b>no</b> trailing null '\0' is added!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to write the utf-8 representation of the unicode character </td></tr>
    <tr><td class="paramname">buf_len</td><td>The buffer length </td></tr>
    <tr><td class="paramname">unicode_code</td><td>Code from unicode table of the character to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written in 'buf' or a negative number on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga935eb75782e5999a24f950d0218f20f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_uuid_bytes_from_string </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>uuid_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *&#160;</td>
          <td class="paramname"><em>uuid_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UUID in string format to a byte array with UUID bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uuid_str</td><td>The UUID in string format, with or without hyphens, using lowercase or uppercase characters. </td></tr>
    <tr><td class="paramname">uuid_bytes</td><td>an initialized buffer to be used to append the converted uuid, totalizing 16 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga24d7f46816d3af0d591209568477d257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_uuid_gen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uppercase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_hyphens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *&#160;</td>
          <td class="paramname"><em>uuid_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a new universally unique identifier (UUID) string. </p>
<p>The generated string is 16 bytes-long (128 bits) long and conforms to v4 UUIDs (generated from random—or pseudo-random—numbers).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uppercase</td><td>Whether to generate the UUID in uppercase or not </td></tr>
    <tr><td class="paramname">with_hyphens</td><td>Format the resulting UUID string with hyphens (e.g. "de305d54-75b4-431b-adb2-eb6b9e546014") or without them. </td></tr>
    <tr><td class="paramname">uuid_buf</td><td>An initialized buffer to be used to append the generated id. It will have 36 bytes of length if with_hyphens is true or 32 bytes of length if with_hyphens is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2common_2uart_8c-example.html#a18">/src/samples/common/uart.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="uart_8c.html#af9f6c5e151a851d960a38b4d4b1cb432">producer_make_data()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b2cb61d8464feb5d07bed5da82cd6a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_util_uuid_str_is_valid </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>uuid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given universally unique identifier (UUID), in string form, is valid. </p>
<p>All upcase/downcase, hyphenated/non-hyphenated cases are included.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uuid</td><td>The given UUID formatted in a string, with or without hyphens.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if it's valid, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga57490a7717a80d2e579c0132b8be8ad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_util_uuid_string_from_bytes </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uppercase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_hyphens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>uuid_bytes</em>[SOL_STATIC_ARRAY_SIZE(16)], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *&#160;</td>
          <td class="paramname"><em>uuid_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UUID in byte format to UUID string format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uppercase</td><td>Whether to create the UUID string in uppercase or not </td></tr>
    <tr><td class="paramname">with_hyphens</td><td>Format the resulting UUID string with hyphens (e.g. "de305d54-75b4-431b-adb2-eb6b9e546014") or without them. </td></tr>
    <tr><td class="paramname">uuid_bytes</td><td>A 16 byte array containing the UUID in byte format. </td></tr>
    <tr><td class="paramname">uuid_str</td><td>n initialized buffer to be used to append the converted uuid. It will have 36 bytes of length if with_hyphens is true or 32 bytes of length if with_hyphens is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<a href="http://solettaproject.github.io/docs/">Full online documentation</a> | 
<a href="index.html">C API Index</a>
</small></address>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
