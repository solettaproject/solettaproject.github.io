<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Soletta™ Framework: I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta™ Framework
   </div>
   <div id="projectbrief">
   Framework for making IoT devices<br /><br />
   <small>
   <a href="http://solettaproject.github.io/docs/">Full online documentation</a> | 
   <a href="index.html">C API Index</a>
   </small><br />
   </div>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C<div class="ingroups"><a class="el" href="group__IO.html">I/O</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>I²C (Inter-Integrated Circuit) API for Soletta.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9520166ad64f4ac87137f99789126d37"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a></td></tr>
<tr class="memdesc:ga9520166ad64f4ac87137f99789126d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C handle structure.  <a href="#ga9520166ad64f4ac87137f99789126d37">More...</a><br/></td></tr>
<tr class="separator:ga9520166ad64f4ac87137f99789126d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb643c03234b6412fac2fb0826ec0a58"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a></td></tr>
<tr class="memdesc:gadb643c03234b6412fac2fb0826ec0a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C pending operation handle structure.  <a href="#gadb643c03234b6412fac2fb0826ec0a58">More...</a><br/></td></tr>
<tr class="separator:gadb643c03234b6412fac2fb0826ec0a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2a27a2238a08a352353426df1ff440d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> { <br/>
&#160;&#160;<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6aae7266bcbc836ae6013609abeb7a1d3c">SOL_I2C_SPEED_10KBIT</a> = 0, 
<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6a6f3c4ddd9f4a729c90aee29a8c806752">SOL_I2C_SPEED_100KBIT</a>, 
<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6aa46e872c069c9605b2eb8b9313a04b4b">SOL_I2C_SPEED_400KBIT</a>, 
<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6a15f9d8ee77c27344e5d3bf8d43c474d9">SOL_I2C_SPEED_1MBIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6a12945c5903700e30972b38637f8c1ff4">SOL_I2C_SPEED_3MBIT_400KBIT</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga2a27a2238a08a352353426df1ff440d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for I2C bus speed.  <a href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">More...</a><br/></td></tr>
<tr class="separator:ga2a27a2238a08a352353426df1ff440d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabca31deed9d3eb838a7e038aa7d4b300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabca31deed9d3eb838a7e038aa7d4b300">sol_i2c_close</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c)</td></tr>
<tr class="memdesc:gabca31deed9d3eb838a7e038aa7d4b300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an I2C bus.  <a href="#gabca31deed9d3eb838a7e038aa7d4b300">More...</a><br/></td></tr>
<tr class="separator:gabca31deed9d3eb838a7e038aa7d4b300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e75fe85ba3f9faa6b243a35b4d807d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga65e75fe85ba3f9faa6b243a35b4d807d">sol_i2c_get_bus</a> (const struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c)</td></tr>
<tr class="memdesc:ga65e75fe85ba3f9faa6b243a35b4d807d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the I2C bus ID.  <a href="#ga65e75fe85ba3f9faa6b243a35b4d807d">More...</a><br/></td></tr>
<tr class="separator:ga65e75fe85ba3f9faa6b243a35b4d807d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba3760a7aa59217fd08035b07f4296b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gafba3760a7aa59217fd08035b07f4296b">sol_i2c_get_slave_address</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c)</td></tr>
<tr class="memdesc:gafba3760a7aa59217fd08035b07f4296b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (slave) device address set on an I2C bus (to deliver I2C commands to)  <a href="#gafba3760a7aa59217fd08035b07f4296b">More...</a><br/></td></tr>
<tr class="separator:gafba3760a7aa59217fd08035b07f4296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3375e5e1d35e3c5c5baa50b1ac597ce"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gae3375e5e1d35e3c5c5baa50b1ac597ce">sol_i2c_open</a> (uint8_t bus, enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> speed)</td></tr>
<tr class="memdesc:gae3375e5e1d35e3c5c5baa50b1ac597ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an I2C bus.  <a href="#gae3375e5e1d35e3c5c5baa50b1ac597ce">More...</a><br/></td></tr>
<tr class="separator:gae3375e5e1d35e3c5c5baa50b1ac597ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f74252c3cfd3582e7c907a840db6469"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga7f74252c3cfd3582e7c907a840db6469">sol_i2c_open_raw</a> (uint8_t bus, enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> speed)</td></tr>
<tr class="memdesc:ga7f74252c3cfd3582e7c907a840db6469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an I2C bus.  <a href="#ga7f74252c3cfd3582e7c907a840db6469">More...</a><br/></td></tr>
<tr class="separator:ga7f74252c3cfd3582e7c907a840db6469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598ad9006e87e32ce34d163a813efd2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga598ad9006e87e32ce34d163a813efd2b">sol_i2c_pending_cancel</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a> *<a class="el" href="download_8c.html#add7d3a20f2cd7ffcb80b6c9a3cb4b8f9">pending</a>)</td></tr>
<tr class="memdesc:ga598ad9006e87e32ce34d163a813efd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending operation.  <a href="#ga598ad9006e87e32ce34d163a813efd2b">More...</a><br/></td></tr>
<tr class="separator:ga598ad9006e87e32ce34d163a813efd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbc27121339b1e4c422fdab483d9e71"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gacfbc27121339b1e4c422fdab483d9e71">sol_i2c_read</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t *data, size_t count, void(*read_cb)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:gacfbc27121339b1e4c422fdab483d9e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform successive asynchronous I2C byte read operations, with no specified register.  <a href="#gacfbc27121339b1e4c422fdab483d9e71">More...</a><br/></td></tr>
<tr class="separator:gacfbc27121339b1e4c422fdab483d9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022d31e09906af1a1934a03c49f41315"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga022d31e09906af1a1934a03c49f41315">sol_i2c_read_register</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, size_t count, void(*read_reg_cb)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:ga022d31e09906af1a1934a03c49f41315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an asynchronous I2C read operation on a given device register.  <a href="#ga022d31e09906af1a1934a03c49f41315">More...</a><br/></td></tr>
<tr class="separator:ga022d31e09906af1a1934a03c49f41315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3bc641d763b31d2e0db61761a67c5b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabf3bc641d763b31d2e0db61761a67c5b">sol_i2c_read_register_multiple</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t reg, uint8_t *values, size_t count, uint8_t times, void(*read_reg_multiple_cb)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:gabf3bc641d763b31d2e0db61761a67c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous read of an arbitrary number of bytes from a register in repeated bursts of a given length (that start always on the provided register address)  <a href="#gabf3bc641d763b31d2e0db61761a67c5b">More...</a><br/></td></tr>
<tr class="separator:gabf3bc641d763b31d2e0db61761a67c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a9823d77077f5a49ecf0d2656115ed6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga5a9823d77077f5a49ecf0d2656115ed6">sol_i2c_set_slave_address</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t slave_address)</td></tr>
<tr class="memdesc:ga5a9823d77077f5a49ecf0d2656115ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a (slave) device address on a I2C bus to deliver commands to.  <a href="#ga5a9823d77077f5a49ecf0d2656115ed6">More...</a><br/></td></tr>
<tr class="separator:ga5a9823d77077f5a49ecf0d2656115ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf1e40af72264a81a6979c6ef106f3a"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga5bf1e40af72264a81a6979c6ef106f3a">sol_i2c_speed_from_str</a> (const char *speed)</td></tr>
<tr class="memdesc:ga5bf1e40af72264a81a6979c6ef106f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string I2C speed to sol_i2c_speed.  <a href="#ga5bf1e40af72264a81a6979c6ef106f3a">More...</a><br/></td></tr>
<tr class="separator:ga5bf1e40af72264a81a6979c6ef106f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41791b39f13b1c44e390639e32bddf7a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga41791b39f13b1c44e390639e32bddf7a">sol_i2c_speed_to_str</a> (enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> speed)</td></tr>
<tr class="memdesc:ga41791b39f13b1c44e390639e32bddf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts sol_i2c_speed to a string name.  <a href="#ga41791b39f13b1c44e390639e32bddf7a">More...</a><br/></td></tr>
<tr class="separator:ga41791b39f13b1c44e390639e32bddf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf328baecae0e32b78fe133d67273ed9a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf328baecae0e32b78fe133d67273ed9a">sol_i2c_write</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t *data, size_t count, void(*write_cb)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:gaf328baecae0e32b78fe133d67273ed9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform successive asynchronous I2C byte write operations, with no specified register.  <a href="#gaf328baecae0e32b78fe133d67273ed9a">More...</a><br/></td></tr>
<tr class="separator:gaf328baecae0e32b78fe133d67273ed9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07bd4788ce4eb74e1d0e395a98e5c4be"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga07bd4788ce4eb74e1d0e395a98e5c4be">sol_i2c_write_quick</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, bool rw, void(*write_quick_cb)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:ga07bd4788ce4eb74e1d0e395a98e5c4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a I2C write quick operation.  <a href="#ga07bd4788ce4eb74e1d0e395a98e5c4be">More...</a><br/></td></tr>
<tr class="separator:ga07bd4788ce4eb74e1d0e395a98e5c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da92cd3bac0a28234f3f95865afa6cb"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6da92cd3bac0a28234f3f95865afa6cb">sol_i2c_write_register</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t reg, const uint8_t *data, size_t count, void(*write_reg_cb)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:ga6da92cd3bac0a28234f3f95865afa6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an asynchronous I2C write operation on a given device register.  <a href="#ga6da92cd3bac0a28234f3f95865afa6cb">More...</a><br/></td></tr>
<tr class="separator:ga6da92cd3bac0a28234f3f95865afa6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3ef27e7abac40247b0773ef8b6db342"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gac3ef27e7abac40247b0773ef8b6db342">sol_i2c_op_type</a> { <a class="el" href="group__I2C.html#ggac3ef27e7abac40247b0773ef8b6db342a556e6808fffb31fdf28cd16dc3e883e7">SOL_I2C_READ</a>, 
<a class="el" href="group__I2C.html#ggac3ef27e7abac40247b0773ef8b6db342a87ea1e076813fe504d74ae4f7010124c">SOL_I2C_WRITE</a>
 }</td></tr>
<tr class="memdesc:gac3ef27e7abac40247b0773ef8b6db342"><td class="mdescLeft">&#160;</td><td class="mdescRight">I²C operation dispatcher.  <a href="group__I2C.html#gac3ef27e7abac40247b0773ef8b6db342">More...</a><br/></td></tr>
<tr class="separator:gac3ef27e7abac40247b0773ef8b6db342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f4ef4a7d0d38603fc60fd688ec6cca1"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="group__I2C.html#ga5f4ef4a7d0d38603fc60fd688ec6cca1">sol_i2c_op_set_pending</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga5f4ef4a7d0d38603fc60fd688ec6cca1">sol_i2c_op_set_pending</a></td></tr>
<tr class="memdesc:ga5f4ef4a7d0d38603fc60fd688ec6cca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Dispatcher pending operation set handle structure.  <a href="#ga5f4ef4a7d0d38603fc60fd688ec6cca1">More...</a><br/></td></tr>
<tr class="separator:ga5f4ef4a7d0d38603fc60fd688ec6cca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba8f3513e399a45f3da3dc3bf516f87"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__I2C.html#ga5f4ef4a7d0d38603fc60fd688ec6cca1">sol_i2c_op_set_pending</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga7ba8f3513e399a45f3da3dc3bf516f87">sol_i2c_dispatcher_add_op_set</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t addr, struct <a class="el" href="structsol__vector.html">sol_vector</a> *set, void(*cb)(void *cb_data, ssize_t status), void *cb_data, uint32_t delay)</td></tr>
<tr class="memdesc:ga7ba8f3513e399a45f3da3dc3bf516f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation set in the dispatcher's queue of a given I2C bus.  <a href="#ga7ba8f3513e399a45f3da3dc3bf516f87">More...</a><br/></td></tr>
<tr class="separator:ga7ba8f3513e399a45f3da3dc3bf516f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefa7b43e6b92ed5464f59c14a03a5f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaefa7b43e6b92ed5464f59c14a03a5f3a">sol_i2c_dispatcher_remove_op_set</a> (struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, struct <a class="el" href="group__I2C.html#ga5f4ef4a7d0d38603fc60fd688ec6cca1">sol_i2c_op_set_pending</a> *<a class="el" href="download_8c.html#add7d3a20f2cd7ffcb80b6c9a3cb4b8f9">pending</a>)</td></tr>
<tr class="memdesc:gaefa7b43e6b92ed5464f59c14a03a5f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the execution of the pending operation set.  <a href="#gaefa7b43e6b92ed5464f59c14a03a5f3a">More...</a><br/></td></tr>
<tr class="separator:gaefa7b43e6b92ed5464f59c14a03a5f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>I²C (Inter-Integrated Circuit) API for Soletta. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga9520166ad64f4ac87137f99789126d37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C handle structure. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__I2C.html#gae3375e5e1d35e3c5c5baa50b1ac597ce" title="Open an I2C bus. ">sol_i2c_open()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#ga7f74252c3cfd3582e7c907a840db6469" title="Open an I2C bus. ">sol_i2c_open_raw()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#gabca31deed9d3eb838a7e038aa7d4b300" title="Close an I2C bus. ">sol_i2c_close()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#ga5a9823d77077f5a49ecf0d2656115ed6" title="Set a (slave) device address on a I2C bus to deliver commands to. ">sol_i2c_set_slave_address()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#gafba3760a7aa59217fd08035b07f4296b" title="Get the (slave) device address set on an I2C bus (to deliver I2C commands to) ">sol_i2c_get_slave_address()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#ga65e75fe85ba3f9faa6b243a35b4d807d" title="Get the I2C bus ID. ">sol_i2c_get_bus()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#ga07bd4788ce4eb74e1d0e395a98e5c4be" title="Perform a I2C write quick operation. ">sol_i2c_write_quick()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#gacfbc27121339b1e4c422fdab483d9e71" title="Perform successive asynchronous I2C byte read operations, with no specified register. ">sol_i2c_read()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#gaf328baecae0e32b78fe133d67273ed9a" title="Perform successive asynchronous I2C byte write operations, with no specified register. ">sol_i2c_write()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#ga022d31e09906af1a1934a03c49f41315" title="Perform an asynchronous I2C read operation on a given device register. ">sol_i2c_read_register()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#ga6da92cd3bac0a28234f3f95865afa6cb" title="Perform an asynchronous I2C write operation on a given device register. ">sol_i2c_write_register()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#gabf3bc641d763b31d2e0db61761a67c5b" title="Asynchronous read of an arbitrary number of bytes from a register in repeated bursts of a given lengt...">sol_i2c_read_register_multiple()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#ga598ad9006e87e32ce34d163a813efd2b" title="Cancel a pending operation. ">sol_i2c_pending_cancel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f4ef4a7d0d38603fc60fd688ec6cca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__I2C.html#ga5f4ef4a7d0d38603fc60fd688ec6cca1">sol_i2c_op_set_pending</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Dispatcher pending operation set handle structure. </p>

</div>
</div>
<a class="anchor" id="gadb643c03234b6412fac2fb0826ec0a58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C pending operation handle structure. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__I2C.html#ga07bd4788ce4eb74e1d0e395a98e5c4be" title="Perform a I2C write quick operation. ">sol_i2c_write_quick()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#gacfbc27121339b1e4c422fdab483d9e71" title="Perform successive asynchronous I2C byte read operations, with no specified register. ">sol_i2c_read()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#gaf328baecae0e32b78fe133d67273ed9a" title="Perform successive asynchronous I2C byte write operations, with no specified register. ">sol_i2c_write()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#ga022d31e09906af1a1934a03c49f41315" title="Perform an asynchronous I2C read operation on a given device register. ">sol_i2c_read_register()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#ga6da92cd3bac0a28234f3f95865afa6cb" title="Perform an asynchronous I2C write operation on a given device register. ">sol_i2c_write_register()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#gabf3bc641d763b31d2e0db61761a67c5b" title="Asynchronous read of an arbitrary number of bytes from a register in repeated bursts of a given lengt...">sol_i2c_read_register_multiple()</a> </dd>
<dd>
<a class="el" href="group__I2C.html#ga598ad9006e87e32ce34d163a813efd2b" title="Cancel a pending operation. ">sol_i2c_pending_cancel()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gac3ef27e7abac40247b0773ef8b6db342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#gac3ef27e7abac40247b0773ef8b6db342">sol_i2c_op_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I²C operation dispatcher. </p>
<p>These routines are used manipulate groups of I2C operations to slave devices under Soletta. Enum for the dispatcher operation type.</p>
<p>If a given operation in the set to either read or write a data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggac3ef27e7abac40247b0773ef8b6db342a556e6808fffb31fdf28cd16dc3e883e7"></a>SOL_I2C_READ</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac3ef27e7abac40247b0773ef8b6db342a87ea1e076813fe504d74ae4f7010124c"></a>SOL_I2C_WRITE</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga2a27a2238a08a352353426df1ff440d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for I2C bus speed. </p>
<p>Must be chosen when opening a bus with <a class="el" href="group__I2C.html#gae3375e5e1d35e3c5c5baa50b1ac597ce" title="Open an I2C bus. ">sol_i2c_open()</a> and <a class="el" href="group__I2C.html#ga7f74252c3cfd3582e7c907a840db6469" title="Open an I2C bus. ">sol_i2c_open_raw()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6aae7266bcbc836ae6013609abeb7a1d3c"></a>SOL_I2C_SPEED_10KBIT</em>&#160;</td><td class="fielddoc">
<p>flag for low speed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6a6f3c4ddd9f4a729c90aee29a8c806752"></a>SOL_I2C_SPEED_100KBIT</em>&#160;</td><td class="fielddoc">
<p>flag for normal speed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6aa46e872c069c9605b2eb8b9313a04b4b"></a>SOL_I2C_SPEED_400KBIT</em>&#160;</td><td class="fielddoc">
<p>flag for fast speed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6a15f9d8ee77c27344e5d3bf8d43c474d9"></a>SOL_I2C_SPEED_1MBIT</em>&#160;</td><td class="fielddoc">
<p>flag for fast plus speed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6a12945c5903700e30972b38637f8c1ff4"></a>SOL_I2C_SPEED_3MBIT_400KBIT</em>&#160;</td><td class="fielddoc">
<p>flag for high speed </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabca31deed9d3eb838a7e038aa7d4b300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7ba8f3513e399a45f3da3dc3bf516f87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__I2C.html#ga5f4ef4a7d0d38603fc60fd688ec6cca1">sol_i2c_op_set_pending</a>* sol_i2c_dispatcher_add_op_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__vector.html">sol_vector</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, ssize_t status)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an operation set in the dispatcher's queue of a given I2C bus. </p>
<p>It adds an operation set scheduling it for execution by the dispatcher handling i2c opeations at bus <em>i2c</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The i2c bus handle </td></tr>
    <tr><td class="paramname">addr</td><td>The slave device address </td></tr>
    <tr><td class="paramname">set</td><td>Operation set to be added </td></tr>
    <tr><td class="paramname">cb</td><td>Callback to be called after the operation set is executed </td></tr>
    <tr><td class="paramname">cb_data</td><td>Callback context data </td></tr>
    <tr><td class="paramname">delay</td><td>Time, in milliseconds, to wait between two consecutive operations of this set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaefa7b43e6b92ed5464f59c14a03a5f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_dispatcher_remove_op_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga5f4ef4a7d0d38603fc60fd688ec6cca1">sol_i2c_op_set_pending</a> *&#160;</td>
          <td class="paramname"><em>pending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel the execution of the pending operation set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">pending</td><td>The operation set pending handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga65e75fe85ba3f9faa6b243a35b4d807d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sol_i2c_get_bus </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the I2C bus ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bus id </dd></dl>

</div>
</div>
<a class="anchor" id="gafba3760a7aa59217fd08035b07f4296b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sol_i2c_get_slave_address </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (slave) device address set on an I2C bus (to deliver I2C commands to) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The slave device address set on <em>bus</em>. <code>0x0</code> means <em>bus</em> was not set to any device yet </dd></dl>

</div>
</div>
<a class="anchor" id="gae3375e5e1d35e3c5c5baa50b1ac597ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a>* sol_i2c_open </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The I2C bus number to open </td></tr>
    <tr><td class="paramname">speed</td><td>The speed to open I2C bus <em>bus</em> at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new I2C bus handle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This call will attempt to make pin muxing operations underneath, for the given platform that the code is running in. Use <a class="el" href="group__I2C.html#ga7f74252c3cfd3582e7c907a840db6469" title="Open an I2C bus. ">sol_i2c_open_raw()</a> if you want to skip any pin mux operation.</dd>
<dd>
The same I2C bus is shared between every user, so only the first one opening a bus will be able to set its speed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f74252c3cfd3582e7c907a840db6469"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a>* sol_i2c_open_raw </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The I2C bus number to open </td></tr>
    <tr><td class="paramname">speed</td><td>The speed to open I2C bus <em>bus</em> at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new I2C bus handle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This call won't attempt to make any pin muxing operations underneath. Use <a class="el" href="group__I2C.html#gae3375e5e1d35e3c5c5baa50b1ac597ce" title="Open an I2C bus. ">sol_i2c_open()</a> for that. Also, this will never cache this I2C handle (or return any previously cached I2C handle). </dd></dl>

</div>
</div>
<a class="anchor" id="ga598ad9006e87e32ce34d163a813efd2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_pending_cancel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a> *&#160;</td>
          <td class="paramname"><em>pending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a pending operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>the I2C bus handle </td></tr>
    <tr><td class="paramname">pending</td><td>the operation handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacfbc27121339b1e4c422fdab483d9e71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a>* sol_i2c_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform successive asynchronous I2C byte read operations, with no specified register. </p>
<p>This makes <em>count</em> read byte I2C operations on the device <em>bus</em> is set to operate on, at no specific register. Some devices are so simple that this interface is enough. For others, it is a shorthand if you want to read the same register as in the previous I2C command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the read operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the read operation </td></tr>
    <tr><td class="paramname">read_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller should guarantee that data will not be freed until the callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>read_cb</em> is called. It may be used before that to cancel the read operation. If <code>NULL</code> is returned, the errno variable will be set with the correct error value. In case that the I2C device is in use, the errno variable is set to EBUSY. </dd></dl>

</div>
</div>
<a class="anchor" id="ga022d31e09906af1a1934a03c49f41315"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a>* sol_i2c_read_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_reg_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an asynchronous I2C read operation on a given device register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The I2C register for the read operation </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the read operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the read operation </td></tr>
    <tr><td class="paramname">read_reg_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller should guarantee that data will not be freed until the callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>read_reg_cb</em> is called. It may be used before that to cancel the read operation. If <code>NULL</code> is returned, the errno variable will be set with the correct error value. In case that the I2C device is in use, the errno variable is set to EBUSY. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf3bc641d763b31d2e0db61761a67c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a>* sol_i2c_read_register_multiple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_reg_multiple_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous read of an arbitrary number of bytes from a register in repeated bursts of a given length (that start always on the provided register address) </p>
<p>This is so because a lot of devices will, after a read operation, update its register values with new data to be read on subsequent operations, until the total data length the user requested is read. If the device has the auto-increment feature, <a class="el" href="group__I2C.html#ga022d31e09906af1a1934a03c49f41315" title="Perform an asynchronous I2C read operation on a given device register. ">sol_i2c_read_register()</a> might be a better call than this function.</p>
<p>This will issue multiple I2C read/write transactions with the first (write) message specifying the register to operate on and the second (read) message specifying the length (always <em>len</em> per read) and the destination of the read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The register to start reading from </td></tr>
    <tr><td class="paramname">values</td><td>Where to store the read bytes </td></tr>
    <tr><td class="paramname">count</td><td>The size of a single read block </td></tr>
    <tr><td class="paramname">times</td><td>How many reads of size <em>len</em> to perform (on success, <em>len</em> * <em>times</em> bytes will be read) </td></tr>
    <tr><td class="paramname">read_reg_multiple_cb</td><td>The callback to be called when the operation finishes. The status parameter should be equal to count in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller should guarantee that data will not be freed until the callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>read_reg_multiple_cb</em> is called. It may be used before that to cancel the read operation. If <code>NULL</code> is returned, the errno variable will be set with the correct error value. In case that the I2C device is in use, the errno variable is set to EBUSY. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a9823d77077f5a49ecf0d2656115ed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_i2c_set_slave_address </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slave_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a (slave) device address on a I2C bus to deliver commands to. </p>
<p>All other I2C functions, after this call, will act on the given <em>slave_address</em> device address. Since other I2C calls might happen in between your own ones, though, it's highly advisable that you issue this call before using any of the I2C read/write functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">slave_address</td><td>The slave device address to deliver commands to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, <code>-EBUSY</code> if the device is busy or -errno on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5bf1e40af72264a81a6979c6ef106f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> sol_i2c_speed_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string I2C speed to sol_i2c_speed. </p>
<p>This function converts a string I2C speed to enumeration sol_i2c_speed.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__I2C.html#ga41791b39f13b1c44e390639e32bddf7a" title="Converts sol_i2c_speed to a string name. ">sol_i2c_speed_to_str()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>Valid values are "10kbps", "100kbps", "400kbps", "1000kbps", "3400kbps".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enumeration sol_i2c_speed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga41791b39f13b1c44e390639e32bddf7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sol_i2c_speed_to_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a>&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts sol_i2c_speed to a string name. </p>
<p>This function converts sol_i2c_speed enumeration to a string I2C speed name.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__I2C.html#ga5bf1e40af72264a81a6979c6ef106f3a" title="Converts a string I2C speed to sol_i2c_speed. ">sol_i2c_speed_from_str()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>sol_i2c_speed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation of the sol_i2c_speed. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf328baecae0e32b78fe133d67273ed9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a>* sol_i2c_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform successive asynchronous I2C byte write operations, with no specified register. </p>
<p>This makes <em>count</em> write byte I2C operations on the device <em>bus</em> is set to operate on, at no specific register. Some devices are so simple that this interface is enough. For others, it is a shorthand if you want to write the same register as in the previous I2C command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the write operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the write operation </td></tr>
    <tr><td class="paramname">write_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller should guarantee that data will not be freed until the callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>write_cb</em> is called. It may be used before that to cancel the read operation. If <code>NULL</code> is returned, the errno variable will be set with the correct error value. In case that the I2C device is in use, the errno variable is set to EBUSY. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07bd4788ce4eb74e1d0e395a98e5c4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a>* sol_i2c_write_quick </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_quick_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a I2C write quick operation. </p>
<p>This sends a single bit to a device (command designed to turn on and off simple devices)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">rw</td><td>The value to write </td></tr>
    <tr><td class="paramname">write_quick_cb</td><td>The callback to be issued when the operation finishes. The status parameter should be equal to one in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>Data to be passed to <em>write_quick_cb</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>write_quick_cb</em> is called. It may be used before that to cancel the read operation. If <code>NULL</code> is returned, the errno variable will be set with the correct error value. In case that the I2C device is in use, the errno variable is set to EBUSY. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6da92cd3bac0a28234f3f95865afa6cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__I2C.html#gadb643c03234b6412fac2fb0826ec0a58">sol_i2c_pending</a>* sol_i2c_write_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct <a class="el" href="group__I2C.html#ga9520166ad64f4ac87137f99789126d37">sol_i2c</a> *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_reg_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an asynchronous I2C write operation on a given device register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The I2C register for the write operation </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the write operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the write operation </td></tr>
    <tr><td class="paramname">write_reg_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success (or a negative error code, on failure) </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller should guarantee that data will not be freed until the callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending An I2C pending operation handle on success, otherwise <code>NULL</code>. It's only valid before <em>write_reg_cb</em> is called. It may be used before that to cancel the read operation. If <code>NULL</code> is returned, the errno variable will be set with the correct error value. In case that the I2C device is in use, the errno variable is set to EBUSY. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<a href="http://solettaproject.github.io/docs/">Full online documentation</a> | 
<a href="index.html">C API Index</a>
</small></address>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
