<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Soletta: I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta
   </div>
   <div id="projectbrief">Framework for making IoT devices</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C<div class="ingroups"><a class="el" href="group__IO.html">I/O</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>I²C (Inter-Integrated Circuit) API for Soletta.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2a27a2238a08a352353426df1ff440d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> { <br />
&#160;&#160;<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6aae7266bcbc836ae6013609abeb7a1d3c">SOL_I2C_SPEED_10KBIT</a> = 0, 
<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6a6f3c4ddd9f4a729c90aee29a8c806752">SOL_I2C_SPEED_100KBIT</a>, 
<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6aa46e872c069c9605b2eb8b9313a04b4b">SOL_I2C_SPEED_400KBIT</a>, 
<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6a15f9d8ee77c27344e5d3bf8d43c474d9">SOL_I2C_SPEED_1MBIT</a>, 
<br />
&#160;&#160;<a class="el" href="group__I2C.html#gga2a27a2238a08a352353426df1ff440d6a12945c5903700e30972b38637f8c1ff4">SOL_I2C_SPEED_3MBIT_400KBIT</a>
<br />
 }<tr class="memdesc:ga2a27a2238a08a352353426df1ff440d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for I2C bus speed.  <a href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">More...</a><br /></td></tr>
<tr class="separator:ga2a27a2238a08a352353426df1ff440d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf77b39c4aee929e9c75c11f6359cf458"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf77b39c4aee929e9c75c11f6359cf458">sol_i2c_bus_get</a> (const struct sol_i2c *i2c)</td></tr>
<tr class="memdesc:gaf77b39c4aee929e9c75c11f6359cf458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the I2C bus id.  <a href="#gaf77b39c4aee929e9c75c11f6359cf458">More...</a><br /></td></tr>
<tr class="separator:gaf77b39c4aee929e9c75c11f6359cf458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9810395724370f3f00acb5ab95d2969"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf9810395724370f3f00acb5ab95d2969">sol_i2c_busy</a> (struct sol_i2c *i2c)</td></tr>
<tr class="memdesc:gaf9810395724370f3f00acb5ab95d2969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if I2C bus is busy, processing another operation. This function should be called before call any other I2C function.  <a href="#gaf9810395724370f3f00acb5ab95d2969">More...</a><br /></td></tr>
<tr class="separator:gaf9810395724370f3f00acb5ab95d2969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca31deed9d3eb838a7e038aa7d4b300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabca31deed9d3eb838a7e038aa7d4b300">sol_i2c_close</a> (struct sol_i2c *i2c)</td></tr>
<tr class="memdesc:gabca31deed9d3eb838a7e038aa7d4b300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an I2C bus.  <a href="#gabca31deed9d3eb838a7e038aa7d4b300">More...</a><br /></td></tr>
<tr class="separator:gabca31deed9d3eb838a7e038aa7d4b300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf697f94177ca536843244fe34c3c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabaf697f94177ca536843244fe34c3c1c">sol_i2c_close_raw</a> (struct sol_i2c *i2c)</td></tr>
<tr class="memdesc:gabaf697f94177ca536843244fe34c3c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an I2C bus.  <a href="#gabaf697f94177ca536843244fe34c3c1c">More...</a><br /></td></tr>
<tr class="separator:gabaf697f94177ca536843244fe34c3c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba3760a7aa59217fd08035b07f4296b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gafba3760a7aa59217fd08035b07f4296b">sol_i2c_get_slave_address</a> (struct sol_i2c *i2c)</td></tr>
<tr class="memdesc:gafba3760a7aa59217fd08035b07f4296b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (slave) device address set on an I2C bus (to deliver I2C commands)  <a href="#gafba3760a7aa59217fd08035b07f4296b">More...</a><br /></td></tr>
<tr class="separator:gafba3760a7aa59217fd08035b07f4296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d88e4d8e1bafbcfdc36cbfe3928f5a"><td class="memItemLeft" align="right" valign="top">struct sol_i2c *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga43d88e4d8e1bafbcfdc36cbfe3928f5a">sol_i2c_open</a> (uint8_t bus, enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> speed) <a class="el" href="group__Macros.html#ga57f3ea0b29f2eb5c047347b788e34db0">SOL_ATTR_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ga43d88e4d8e1bafbcfdc36cbfe3928f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an I2C bus.  <a href="#ga43d88e4d8e1bafbcfdc36cbfe3928f5a">More...</a><br /></td></tr>
<tr class="separator:ga43d88e4d8e1bafbcfdc36cbfe3928f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f1c39293b17fde011fa146985f51bf"><td class="memItemLeft" align="right" valign="top">struct sol_i2c *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga90f1c39293b17fde011fa146985f51bf">sol_i2c_open_raw</a> (uint8_t bus, enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a> speed) <a class="el" href="group__Macros.html#ga57f3ea0b29f2eb5c047347b788e34db0">SOL_ATTR_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ga90f1c39293b17fde011fa146985f51bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an I2C bus.  <a href="#ga90f1c39293b17fde011fa146985f51bf">More...</a><br /></td></tr>
<tr class="separator:ga90f1c39293b17fde011fa146985f51bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598ad9006e87e32ce34d163a813efd2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga598ad9006e87e32ce34d163a813efd2b">sol_i2c_pending_cancel</a> (struct sol_i2c *i2c, struct sol_i2c_pending *<a class="el" href="download_8c.html#add7d3a20f2cd7ffcb80b6c9a3cb4b8f9">pending</a>)</td></tr>
<tr class="memdesc:ga598ad9006e87e32ce34d163a813efd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending operation.  <a href="#ga598ad9006e87e32ce34d163a813efd2b">More...</a><br /></td></tr>
<tr class="separator:ga598ad9006e87e32ce34d163a813efd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbc27121339b1e4c422fdab483d9e71"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gacfbc27121339b1e4c422fdab483d9e71">sol_i2c_read</a> (struct sol_i2c *i2c, uint8_t *data, size_t count, void(*read_cb)(void *cb_data, struct sol_i2c *i2c, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:gacfbc27121339b1e4c422fdab483d9e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform successive asynchronous I2C byte read operations, with no specified register.  <a href="#gacfbc27121339b1e4c422fdab483d9e71">More...</a><br /></td></tr>
<tr class="separator:gacfbc27121339b1e4c422fdab483d9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022d31e09906af1a1934a03c49f41315"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga022d31e09906af1a1934a03c49f41315">sol_i2c_read_register</a> (struct sol_i2c *i2c, uint8_t reg, uint8_t *data, size_t count, void(*read_reg_cb)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:ga022d31e09906af1a1934a03c49f41315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a asynchronous I2C read operation on a given device register.  <a href="#ga022d31e09906af1a1934a03c49f41315">More...</a><br /></td></tr>
<tr class="separator:ga022d31e09906af1a1934a03c49f41315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3bc641d763b31d2e0db61761a67c5b"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabf3bc641d763b31d2e0db61761a67c5b">sol_i2c_read_register_multiple</a> (struct sol_i2c *i2c, uint8_t reg, uint8_t *values, size_t count, uint8_t times, void(*read_reg_multiple_cb)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:gabf3bc641d763b31d2e0db61761a67c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous read of an arbitrary number of bytes from a register in repeated bursts of a given length (that start always on the provided register address)  <a href="#gabf3bc641d763b31d2e0db61761a67c5b">More...</a><br /></td></tr>
<tr class="separator:gabf3bc641d763b31d2e0db61761a67c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae778e276d19675d0113711629a9cb40a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gae778e276d19675d0113711629a9cb40a">sol_i2c_set_slave_address</a> (struct sol_i2c *i2c, uint8_t slave_address)</td></tr>
<tr class="memdesc:gae778e276d19675d0113711629a9cb40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a (slave) device address on a I2C bus to deliver commands to.  <a href="#gae778e276d19675d0113711629a9cb40a">More...</a><br /></td></tr>
<tr class="separator:gae778e276d19675d0113711629a9cb40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf328baecae0e32b78fe133d67273ed9a"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf328baecae0e32b78fe133d67273ed9a">sol_i2c_write</a> (struct sol_i2c *i2c, uint8_t *data, size_t count, void(*write_cb)(void *cb_data, struct sol_i2c *i2c, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:gaf328baecae0e32b78fe133d67273ed9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform successive asynchronous I2C byte write operations, with no specified register.  <a href="#gaf328baecae0e32b78fe133d67273ed9a">More...</a><br /></td></tr>
<tr class="separator:gaf328baecae0e32b78fe133d67273ed9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07bd4788ce4eb74e1d0e395a98e5c4be"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga07bd4788ce4eb74e1d0e395a98e5c4be">sol_i2c_write_quick</a> (struct sol_i2c *i2c, bool rw, void(*write_quick_cb)(void *cb_data, struct sol_i2c *i2c, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:ga07bd4788ce4eb74e1d0e395a98e5c4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a I2C write quick operation.  <a href="#ga07bd4788ce4eb74e1d0e395a98e5c4be">More...</a><br /></td></tr>
<tr class="separator:ga07bd4788ce4eb74e1d0e395a98e5c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da92cd3bac0a28234f3f95865afa6cb"><td class="memItemLeft" align="right" valign="top">struct sol_i2c_pending *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6da92cd3bac0a28234f3f95865afa6cb">sol_i2c_write_register</a> (struct sol_i2c *i2c, uint8_t reg, const uint8_t *data, size_t count, void(*write_reg_cb)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status), const void *cb_data)</td></tr>
<tr class="memdesc:ga6da92cd3bac0a28234f3f95865afa6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a asynchronous I2C write operation on a given device register.  <a href="#ga6da92cd3bac0a28234f3f95865afa6cb">More...</a><br /></td></tr>
<tr class="separator:ga6da92cd3bac0a28234f3f95865afa6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>I²C (Inter-Integrated Circuit) API for Soletta. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga2a27a2238a08a352353426df1ff440d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for I2C bus speed. </p>
<p>Must be choosen when opening a bus with <a class="el" href="group__I2C.html#ga43d88e4d8e1bafbcfdc36cbfe3928f5a" title="Open an I2C bus. ">sol_i2c_open()</a> and <a class="el" href="group__I2C.html#ga90f1c39293b17fde011fa146985f51bf" title="Open an I2C bus. ">sol_i2c_open_raw()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6aae7266bcbc836ae6013609abeb7a1d3c"></a>SOL_I2C_SPEED_10KBIT&#160;</td><td class="fielddoc">
<p>flag for low speed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6a6f3c4ddd9f4a729c90aee29a8c806752"></a>SOL_I2C_SPEED_100KBIT&#160;</td><td class="fielddoc">
<p>flag for normal speed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6aa46e872c069c9605b2eb8b9313a04b4b"></a>SOL_I2C_SPEED_400KBIT&#160;</td><td class="fielddoc">
<p>flag for fast speed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6a15f9d8ee77c27344e5d3bf8d43c474d9"></a>SOL_I2C_SPEED_1MBIT&#160;</td><td class="fielddoc">
<p>flag for fast plus speed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2a27a2238a08a352353426df1ff440d6a12945c5903700e30972b38637f8c1ff4"></a>SOL_I2C_SPEED_3MBIT_400KBIT&#160;</td><td class="fielddoc">
<p>flag for high speed </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf77b39c4aee929e9c75c11f6359cf458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sol_i2c_bus_get </td>
          <td>(</td>
          <td class="paramtype">const struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the I2C bus id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bus id </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9810395724370f3f00acb5ab95d2969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_i2c_busy </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if I2C bus is busy, processing another operation. This function should be called before call any other I2C function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true is busy or false if idle </dd></dl>

</div>
</div>
<a class="anchor" id="gabca31deed9d3eb838a7e038aa7d4b300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_close </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabaf697f94177ca536843244fe34c3c1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_close_raw </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle to close</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call will not remove this I2C handle from cache. Use <a class="el" href="group__I2C.html#gabca31deed9d3eb838a7e038aa7d4b300" title="Close an I2C bus. ">sol_i2c_close()</a> for that. </dd></dl>

</div>
</div>
<a class="anchor" id="gafba3760a7aa59217fd08035b07f4296b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sol_i2c_get_slave_address </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (slave) device address set on an I2C bus (to deliver I2C commands) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The slave device address set on <em>bus</em>. <code>0x0</code> means <em>bus</em> was not set to any device yet </dd></dl>

</div>
</div>
<a class="anchor" id="ga43d88e4d8e1bafbcfdc36cbfe3928f5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c* sol_i2c_open </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The I2C bus number to open </td></tr>
    <tr><td class="paramname">speed</td><td>The speed to open I2C bus <em>bus</em> at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new I2C bus handle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This call will attempt to make pin muxing operations underneath, for the given platform that the code is running in. Use <a class="el" href="group__I2C.html#ga90f1c39293b17fde011fa146985f51bf" title="Open an I2C bus. ">sol_i2c_open_raw()</a> if you want to skip any pin mux operation. </dd>
<dd>
The same I2C bus is shared between every user, so only the first one opening the bus will be able to set the bus speed, if some I2C slave device need to work in lower speed you need to change it on every other user of the bus. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90f1c39293b17fde011fa146985f51bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c* sol_i2c_open_raw </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__I2C.html#ga2a27a2238a08a352353426df1ff440d6">sol_i2c_speed</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The I2C bus number to open </td></tr>
    <tr><td class="paramname">speed</td><td>The speed to open I2C bus <em>bus</em> at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new I2C bus handle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This call won't attempt to make any pin muxing operations underneath. Use <a class="el" href="group__I2C.html#ga43d88e4d8e1bafbcfdc36cbfe3928f5a" title="Open an I2C bus. ">sol_i2c_open()</a> for that, also this will not cache this I2C or try get an previous cached I2C handle. </dd></dl>

</div>
</div>
<a class="anchor" id="ga598ad9006e87e32ce34d163a813efd2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_i2c_pending_cancel </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sol_i2c_pending *&#160;</td>
          <td class="paramname"><em>pending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a pending operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>the I2C bus handle </td></tr>
    <tr><td class="paramname">pending</td><td>the operation handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacfbc27121339b1e4c422fdab483d9e71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_read </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform successive asynchronous I2C byte read operations, with no specified register. </p>
<p>This makes <em>count</em> read byte I2C operations on the device <em>bus</em> is set to operate on, at no specific register. Some devices are so simple that this interface is enough. For others, it is a shorthand if you want to read the same register as in the previous I2C command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the read operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the read operation </td></tr>
    <tr><td class="paramname">read_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Caller should guarantee that data will not be freed until callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga022d31e09906af1a1934a03c49f41315"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_read_register </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_reg_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a asynchronous I2C read operation on a given device register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The I2C register for the read operation </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the read operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the read operation </td></tr>
    <tr><td class="paramname">read_reg_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Caller should guarantee that data will not be freed until callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="gabf3bc641d763b31d2e0db61761a67c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_read_register_multiple </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>read_reg_multiple_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous read of an arbitrary number of bytes from a register in repeated bursts of a given length (that start always on the provided register address) </p>
<p>This is so because a lot of devices will, after a read operation, update its register values with new data to be read on subsequent operations, until the total data length the user requested is read. If the device has the auto-increment feature, <a class="el" href="group__I2C.html#ga022d31e09906af1a1934a03c49f41315" title="Perform a asynchronous I2C read operation on a given device register. ">sol_i2c_read_register()</a> might be a better call than this function.</p>
<p>This will issue multiple I2C read/write transactions with the first (write) message specifying the register to operate on and the second (read) message specifying the length (always <em>len</em> per read) and the destination of the read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The register to start reading from </td></tr>
    <tr><td class="paramname">values</td><td>Where to store the read bytes </td></tr>
    <tr><td class="paramname">count</td><td>The size of a single read block </td></tr>
    <tr><td class="paramname">times</td><td>How many reads of size <em>len</em> to perform (on success, <em>len</em> * <em>times</em> bytes will be read) </td></tr>
    <tr><td class="paramname">read_reg_multiple_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Caller should guarantee that data will not be freed until callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="gae778e276d19675d0113711629a9cb40a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_i2c_set_slave_address </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slave_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a (slave) device address on a I2C bus to deliver commands to. </p>
<p>All other I2C functions, after this call, will act on the given <em>slave_address</em> device address. Since other I2C calls might happen in between your own ones, though, it's highly advisable that you issue this call before using any of the I2C read/write functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">slave_address</td><td>The slave device address to deliver commands to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf328baecae0e32b78fe133d67273ed9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_write </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform successive asynchronous I2C byte write operations, with no specified register. </p>
<p>This makes <em>count</em> write byte I2C operations on the device <em>bus</em> is set to operate on, at no specific register. Some devices are so simple that this interface is enough. For others, it is a shorthand if you want to write the same register as in the previous I2C command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the write operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the write operation </td></tr>
    <tr><td class="paramname">write_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Caller should guarantee that data will not be freed until callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga07bd4788ce4eb74e1d0e395a98e5c4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_write_quick </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_quick_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a I2C write quick operation. </p>
<p>This sends a single bit to a device (command designed to turn on and off simple devices)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The I2C bus handle </td></tr>
    <tr><td class="paramname">rw</td><td>The value to write </td></tr>
    <tr><td class="paramname">write_quick_cb</td><td>The callback to be issued when the operation finishes. The status parameter should be equal to one in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>Data to be passed to <em>write_quick_cb</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga6da92cd3bac0a28234f3f95865afa6cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sol_i2c_pending* sol_i2c_write_register </td>
          <td>(</td>
          <td class="paramtype">struct sol_i2c *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_data, struct sol_i2c *i2c, uint8_t reg, uint8_t *data, ssize_t status)&#160;</td>
          <td class="paramname"><em>write_reg_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a asynchronous I2C write operation on a given device register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>bus The I2C bus handle </td></tr>
    <tr><td class="paramname">reg</td><td>The I2C register for the write operation </td></tr>
    <tr><td class="paramname">data</td><td>The output buffer for the write operation </td></tr>
    <tr><td class="paramname">count</td><td>The bytes count for the write operation </td></tr>
    <tr><td class="paramname">write_reg_cb</td><td>The callback to be called when operation finish, the status parameter should be equal to count in case of success </td></tr>
    <tr><td class="paramname">cb_data</td><td>The first parameter of callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Caller should guarantee that data will not be freed until callback is called. Also there is no transfer queue, calling this function when there is another I2C operation running will return false.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pending handle if operation was started otherwise a NULL pointer </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
