<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Soletta™ Framework: String slice</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta™ Framework
   </div>
   <div id="projectbrief">
   Framework for making IoT devices<br /><br />
   <small>
   <a href="http://solettaproject.github.io/docs/">Full online documentation</a> | 
   <a href="index.html">C API Index</a>
   </small><br />
   </div>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">String slice<div class="ingroups"><a class="el" href="group__Datatypes.html">Data types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Slice of a string with explicit length.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__str__slice.html">sol_str_slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String slice type.  <a href="structsol__str__slice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6bc9c02e743cdae36f60806eca039fed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga6bc9c02e743cdae36f60806eca039fed">SOL_STR_SLICE_EMPTY</a>&#160;&#160;&#160;{ .len = 0, .data = &quot;&quot; }</td></tr>
<tr class="memdesc:ga6bc9c02e743cdae36f60806eca039fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to make easier to declare an empty string slice.  <a href="#ga6bc9c02e743cdae36f60806eca039fed">More...</a><br/></td></tr>
<tr class="separator:ga6bc9c02e743cdae36f60806eca039fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga286e4d6331e05cd18747d0d7deb06984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga286e4d6331e05cd18747d0d7deb06984">SOL_STR_SLICE_LITERAL</a>(_s)&#160;&#160;&#160;{ (sizeof(<a class="el" href="group__Str__Slice.html#gae90cc2b106b3e1c0e0e32b2abfa04e51">SOL_STR_STATIC_ASSERT_LITERAL</a>(_s)) - 1), (_s) }</td></tr>
<tr class="memdesc:ga286e4d6331e05cd18747d0d7deb06984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to make easier to declare a string slice from a string literal.  <a href="#ga286e4d6331e05cd18747d0d7deb06984">More...</a><br/></td></tr>
<tr class="separator:ga286e4d6331e05cd18747d0d7deb06984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10c9d829c4d0c50467106a14190d7611"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga10c9d829c4d0c50467106a14190d7611">SOL_STR_SLICE_PRINT</a>(_s)&#160;&#160;&#160;(int)(_s).len, (_s).data</td></tr>
<tr class="memdesc:ga10c9d829c4d0c50467106a14190d7611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to be used together with "%.*s" formatting in 'printf()' family of functions.  <a href="#ga10c9d829c4d0c50467106a14190d7611">More...</a><br/></td></tr>
<tr class="separator:ga10c9d829c4d0c50467106a14190d7611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5408488d546a6b48a17852eda5e14263"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga5408488d546a6b48a17852eda5e14263">SOL_STR_SLICE_STR</a>(_s, _len)&#160;&#160;&#160;(struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>){.len = (_len), .data = (_s) }</td></tr>
<tr class="memdesc:ga5408488d546a6b48a17852eda5e14263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to make easier to declare a string slice from a string.  <a href="#ga5408488d546a6b48a17852eda5e14263">More...</a><br/></td></tr>
<tr class="separator:ga5408488d546a6b48a17852eda5e14263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae90cc2b106b3e1c0e0e32b2abfa04e51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gae90cc2b106b3e1c0e0e32b2abfa04e51">SOL_STR_STATIC_ASSERT_LITERAL</a>(_s)&#160;&#160;&#160;(&quot;&quot; _s)</td></tr>
<tr class="memdesc:gae90cc2b106b3e1c0e0e32b2abfa04e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to assert that the parameter is a string literal.  <a href="#gae90cc2b106b3e1c0e0e32b2abfa04e51">More...</a><br/></td></tr>
<tr class="separator:gae90cc2b106b3e1c0e0e32b2abfa04e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga00b12417410f87f4d69a7e7fa1bf3fb3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga00b12417410f87f4d69a7e7fa1bf3fb3">sol_str_slice</a></td></tr>
<tr class="memdesc:ga00b12417410f87f4d69a7e7fa1bf3fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">String slice type.  <a href="#ga00b12417410f87f4d69a7e7fa1bf3fb3">More...</a><br/></td></tr>
<tr class="separator:ga00b12417410f87f4d69a7e7fa1bf3fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3dd28a97f9e08ef7bfe14059566ffdf6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga3dd28a97f9e08ef7bfe14059566ffdf6">sol_str_slice_case_eq</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> a, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> b)</td></tr>
<tr class="memdesc:ga3dd28a97f9e08ef7bfe14059566ffdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the content of both slices are equal.  <a href="#ga3dd28a97f9e08ef7bfe14059566ffdf6">More...</a><br/></td></tr>
<tr class="separator:ga3dd28a97f9e08ef7bfe14059566ffdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga325f80e2f43dcf071ef158a58c909990"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga325f80e2f43dcf071ef158a58c909990">sol_str_slice_contains</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> haystack, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> needle)</td></tr>
<tr class="memdesc:ga325f80e2f43dcf071ef158a58c909990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>haystack</code> contains <code>needle</code>.  <a href="#ga325f80e2f43dcf071ef158a58c909990">More...</a><br/></td></tr>
<tr class="separator:ga325f80e2f43dcf071ef158a58c909990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4ef16628eb50961dd7307c052fb768"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga1e4ef16628eb50961dd7307c052fb768">sol_str_slice_copy</a> (char *dst, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> src)</td></tr>
<tr class="memdesc:ga1e4ef16628eb50961dd7307c052fb768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of slice <code>src</code> into string <code>dst</code>.  <a href="#ga1e4ef16628eb50961dd7307c052fb768">More...</a><br/></td></tr>
<tr class="separator:ga1e4ef16628eb50961dd7307c052fb768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd2df3e13b5a2d9b0e35568366dfb62"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gafcd2df3e13b5a2d9b0e35568366dfb62">sol_str_slice_eq</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> a, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> b)</td></tr>
<tr class="memdesc:gafcd2df3e13b5a2d9b0e35568366dfb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the content of both slices are equal.  <a href="#gafcd2df3e13b5a2d9b0e35568366dfb62">More...</a><br/></td></tr>
<tr class="separator:gafcd2df3e13b5a2d9b0e35568366dfb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc4606ede8c6c6bf264e71b08f0338e7"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gafc4606ede8c6c6bf264e71b08f0338e7">sol_str_slice_from_blob</a> (const struct <a class="el" href="structsol__blob.html">sol_blob</a> *blob)</td></tr>
<tr class="memdesc:gafc4606ede8c6c6bf264e71b08f0338e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a slice from a <a class="el" href="structsol__blob.html">sol_blob</a>.  <a href="#gafc4606ede8c6c6bf264e71b08f0338e7">More...</a><br/></td></tr>
<tr class="separator:gafc4606ede8c6c6bf264e71b08f0338e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga403d23f24219db595e892573d3384c37"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga403d23f24219db595e892573d3384c37">sol_str_slice_from_str</a> (const char *s)</td></tr>
<tr class="memdesc:ga403d23f24219db595e892573d3384c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a slice from a string.  <a href="#ga403d23f24219db595e892573d3384c37">More...</a><br/></td></tr>
<tr class="separator:ga403d23f24219db595e892573d3384c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46c0b5366a490b25522a4616dca2c6f"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gac46c0b5366a490b25522a4616dca2c6f">sol_str_slice_remove_leading_whitespace</a> (struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:gac46c0b5366a490b25522a4616dca2c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice based on <code>slice</code> but without leading white spaces.  <a href="#gac46c0b5366a490b25522a4616dca2c6f">More...</a><br/></td></tr>
<tr class="separator:gac46c0b5366a490b25522a4616dca2c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed21c434f0fd35b428b13121d890c2c9"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gaed21c434f0fd35b428b13121d890c2c9">sol_str_slice_remove_trailing_whitespace</a> (struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:gaed21c434f0fd35b428b13121d890c2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice based on <code>slice</code> but without trailing white spaces.  <a href="#gaed21c434f0fd35b428b13121d890c2c9">More...</a><br/></td></tr>
<tr class="separator:gaed21c434f0fd35b428b13121d890c2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76bd8b299154e2291c671f6c55192375"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsol__vector.html">sol_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga76bd8b299154e2291c671f6c55192375">sol_str_slice_split</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const char *delim, size_t maxsplit)</td></tr>
<tr class="memdesc:ga76bd8b299154e2291c671f6c55192375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the words in a given string slice, using <code>delim</code> as delimiter string.  <a href="#ga76bd8b299154e2291c671f6c55192375">More...</a><br/></td></tr>
<tr class="separator:ga76bd8b299154e2291c671f6c55192375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfe14e986cd5aa51b63d59059b4fb55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga3cfe14e986cd5aa51b63d59059b4fb55">sol_str_slice_split_iterate</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *token, const char **itr, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> delim)</td></tr>
<tr class="memdesc:ga3cfe14e986cd5aa51b63d59059b4fb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an one step split iteration over a slice.  <a href="#ga3cfe14e986cd5aa51b63d59059b4fb55">More...</a><br/></td></tr>
<tr class="separator:ga3cfe14e986cd5aa51b63d59059b4fb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga452957e2ea411197e10a5503a9dd2f1c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga452957e2ea411197e10a5503a9dd2f1c">sol_str_slice_starts_with</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> prefix)</td></tr>
<tr class="memdesc:ga452957e2ea411197e10a5503a9dd2f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>slice</code> begins with <code>prefix</code>.  <a href="#ga452957e2ea411197e10a5503a9dd2f1c">More...</a><br/></td></tr>
<tr class="separator:ga452957e2ea411197e10a5503a9dd2f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c1e30c2e1c9f40003ce69741ebb071"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gaf4c1e30c2e1c9f40003ce69741ebb071">sol_str_slice_str_case_eq</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> a, const char *b)</td></tr>
<tr class="memdesc:gaf4c1e30c2e1c9f40003ce69741ebb071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the content of the slice is equal to the string.  <a href="#gaf4c1e30c2e1c9f40003ce69741ebb071">More...</a><br/></td></tr>
<tr class="separator:gaf4c1e30c2e1c9f40003ce69741ebb071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f4d08b88b025e80b53b5a29f6874438"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga0f4d08b88b025e80b53b5a29f6874438">sol_str_slice_str_contains</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> haystack, const char *needle)</td></tr>
<tr class="memdesc:ga0f4d08b88b025e80b53b5a29f6874438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>haystack</code> contains <code>needle</code>.  <a href="#ga0f4d08b88b025e80b53b5a29f6874438">More...</a><br/></td></tr>
<tr class="separator:ga0f4d08b88b025e80b53b5a29f6874438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d120c6bf5edb6ded99ecfa5700afb2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga80d120c6bf5edb6ded99ecfa5700afb2">sol_str_slice_str_eq</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> a, const char *b)</td></tr>
<tr class="memdesc:ga80d120c6bf5edb6ded99ecfa5700afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the content of the slice is equal to the string.  <a href="#ga80d120c6bf5edb6ded99ecfa5700afb2">More...</a><br/></td></tr>
<tr class="separator:ga80d120c6bf5edb6ded99ecfa5700afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73df3c88f46837811e41ca99686d7f6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gab73df3c88f46837811e41ca99686d7f6">sol_str_slice_str_split_iterate</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *token, const char **itr, const char *delim)</td></tr>
<tr class="memdesc:gab73df3c88f46837811e41ca99686d7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper over <a class="el" href="group__Str__Slice.html#ga3cfe14e986cd5aa51b63d59059b4fb55" title="Do an one step split iteration over a slice. ">sol_str_slice_split_iterate()</a>  <a href="#gab73df3c88f46837811e41ca99686d7f6">More...</a><br/></td></tr>
<tr class="separator:gab73df3c88f46837811e41ca99686d7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5776e87c37032d1d7839826063b3db07"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#ga5776e87c37032d1d7839826063b3db07">sol_str_slice_str_starts_with</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice, const char *prefix)</td></tr>
<tr class="memdesc:ga5776e87c37032d1d7839826063b3db07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>slice</code> begins with <code>prefix</code>.  <a href="#ga5776e87c37032d1d7839826063b3db07">More...</a><br/></td></tr>
<tr class="separator:ga5776e87c37032d1d7839826063b3db07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2eaefa8a2bde45e217835c8824296e1"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsol__blob.html">sol_blob</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gae2eaefa8a2bde45e217835c8824296e1">sol_str_slice_to_blob</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:gae2eaefa8a2bde45e217835c8824296e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a blob from a slice.  <a href="#gae2eaefa8a2bde45e217835c8824296e1">More...</a><br/></td></tr>
<tr class="separator:gae2eaefa8a2bde45e217835c8824296e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a06ca49d46b835a32f4765ac480f27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gaf5a06ca49d46b835a32f4765ac480f27">sol_str_slice_to_int</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> s, long int *<a class="el" href="server_8c.html#acda54b23a3b92ae2efa63634288c0496">value</a>)</td></tr>
<tr class="memdesc:gaf5a06ca49d46b835a32f4765ac480f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string slice to an integer.  <a href="#gaf5a06ca49d46b835a32f4765ac480f27">More...</a><br/></td></tr>
<tr class="separator:gaf5a06ca49d46b835a32f4765ac480f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91337d929f8c612000eb64c0688d812"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gac91337d929f8c612000eb64c0688d812">sol_str_slice_to_str</a> (const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:gac91337d929f8c612000eb64c0688d812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string from a string slice.  <a href="#gac91337d929f8c612000eb64c0688d812">More...</a><br/></td></tr>
<tr class="separator:gac91337d929f8c612000eb64c0688d812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcc097cf62d4570372460a99eae3ac10"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Str__Slice.html#gabcc097cf62d4570372460a99eae3ac10">sol_str_slice_trim</a> (struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> slice)</td></tr>
<tr class="memdesc:gabcc097cf62d4570372460a99eae3ac10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice based on <code>slice</code> but without either leading or trailing white spaces.  <a href="#gabcc097cf62d4570372460a99eae3ac10">More...</a><br/></td></tr>
<tr class="separator:gabcc097cf62d4570372460a99eae3ac10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Slice of a string with explicit length. </p>
<p>It doesn't necessarily ends with NULL byte like C strings. This representation is convenient for referencing substrings of a larger string without having to duplicate them.</p>
<p>So be careful with memory management when using slices. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga6bc9c02e743cdae36f60806eca039fed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_STR_SLICE_EMPTY&#160;&#160;&#160;{ .len = 0, .data = &quot;&quot; }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro to make easier to declare an empty string slice. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2coap_2simple-server_8c-example.html#a49">/src/samples/coap/simple-server.c</a>, and <a class="el" href="src_2samples_2http_2client_8c-example.html#a32">/src/samples/http/client.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="client_8c.html#aa73fb5506579d04702d9cfbcf2805c0d">create_post_data_params()</a>.</p>

</div>
</div>
<a class="anchor" id="ga286e4d6331e05cd18747d0d7deb06984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_STR_SLICE_LITERAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_s</td><td>)</td>
          <td>&#160;&#160;&#160;{ (sizeof(<a class="el" href="group__Str__Slice.html#gae90cc2b106b3e1c0e0e32b2abfa04e51">SOL_STR_STATIC_ASSERT_LITERAL</a>(_s)) - 1), (_s) }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro to make easier to declare a string slice from a string literal. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2coap_2oic-server_8c-example.html#a32">/src/samples/coap/oic-server.c</a>, and <a class="el" href="src_2samples_2coap_2simple-server_8c-example.html#a48">/src/samples/coap/simple-server.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="oic-server_8c.html#a99bec4e8baf109cdee1b201bb7cb6800">register_light_resource_type()</a>, and <a class="el" href="group__JSON.html#gaa636668c7fa4f3366e682c5779c68af5">sol_json_serialize_null()</a>.</p>

</div>
</div>
<a class="anchor" id="ga10c9d829c4d0c50467106a14190d7611"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_STR_SLICE_PRINT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_s</td><td>)</td>
          <td>&#160;&#160;&#160;(int)(_s).len, (_s).data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro to be used together with "%.*s" formatting in 'printf()' family of functions. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2coap_2iotivity-test-client_8c-example.html#a30">/src/samples/coap/iotivity-test-client.c</a>, <a class="el" href="src_2samples_2coap_2lwm2m-client_8c-example.html#a101">/src/samples/coap/lwm2m-client.c</a>, <a class="el" href="src_2samples_2coap_2oic-client_8c-example.html#a8">/src/samples/coap/oic-client.c</a>, <a class="el" href="src_2samples_2coap_2simple-client_8c-example.html#a22">/src/samples/coap/simple-client.c</a>, <a class="el" href="src_2samples_2common_2uart_8c-example.html#a10">/src/samples/common/uart.c</a>, <a class="el" href="src_2samples_2design_patterns_2stream_sample_8c-example.html#a75">/src/samples/design_patterns/stream_sample.c</a>, <a class="el" href="src_2samples_2http_2client_8c-example.html#a12">/src/samples/http/client.c</a>, <a class="el" href="src_2samples_2http_2server-sse_8c-example.html#a32">/src/samples/http/server-sse.c</a>, <a class="el" href="src_2samples_2http_2server_8c-example.html#a12">/src/samples/http/server.c</a>, <a class="el" href="src_2samples_2network_2echo-client_8c-example.html#a11">/src/samples/network/echo-client.c</a>, and <a class="el" href="src_2samples_2network_2network-status_8c-example.html#a18">/src/samples/network/network-status.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="network-status_8c.html#ad5b522136325bbfb049ada0084e68d19">_on_network_event()</a>, <a class="el" href="uart_8c.html#a1c8a75dae299b5c84afe1f2ec1735aea">consumer_read_available()</a>, <a class="el" href="client_8c.html#a39af2dca033223f27b0b455b5a049898">create_header_params()</a>, <a class="el" href="client_8c.html#aa73fb5506579d04702d9cfbcf2805c0d">create_post_data_params()</a>, <a class="el" href="iotivity-test-client_8c.html#a6cc09e22b723e2987b025a998783466f">found_resource()</a>, <a class="el" href="iotivity-test-client_8c.html#af55e2fb7249a370e69086939b24e838b">found_resource_print()</a>, <a class="el" href="oic-client_8c.html#acc5415346035d88f6c44e87668f11207">got_get_response()</a>, <a class="el" href="echo-client_8c.html#a3beed67a7e52d9793329804c3ca7af7c">on_can_read()</a>, <a class="el" href="stream__sample_8c.html#a29596b98823f06a7a9ec2c2874aa52b4">on_data()</a>, <a class="el" href="stream__sample_8c.html#a35dc30440509d1cc850f88847ee59abf">on_feed_done()</a>, <a class="el" href="server-sse_8c.html#ad181df11d66483eb7911a57090fddcd0">on_feed_done_cb()</a>, <a class="el" href="server_8c.html#ae15b6636fe22ea3bfcca92f512cbf3db">on_stdin()</a>, <a class="el" href="iotivity-test-client_8c.html#a610c93fddb16b691ad7e81e26f30389c">platform_info_cb()</a>, <a class="el" href="iotivity-test-client_8c.html#aed751137db1e85b968e1268d079f4180">print_response()</a>, <a class="el" href="uart_8c.html#a8694ec865bfd7b8d243ca28de0957684">producer_data_written()</a>, <a class="el" href="uart_8c.html#af9f6c5e151a851d960a38b4d4b1cb432">producer_make_data()</a>, <a class="el" href="simple-client_8c.html#a6a801d366045c75e33b88e887ddd2907">reply_cb()</a>, <a class="el" href="server-sse_8c.html#a517a630f84d84807e5bfd9a8b182174b">request_cb()</a>, <a class="el" href="iotivity-test-client_8c.html#a288da8b2554af5cd71a24d93bbf7c420">resource_notify()</a>, <a class="el" href="client_8c.html#acb727801a0f228685c9c31dd7a99688c">response_cb()</a>, <a class="el" href="uart_8c.html#ac7f3be202700792259fedf833dcf695a">send_blob()</a>, <a class="el" href="iotivity-test-client_8c.html#a9c7ece48e7da4ceb8f7261e1ad5a7a4c">server_info_cb()</a>, <a class="el" href="server_8c.html#a01f52f14b9e6dd3c57b905c4db4213bf">startup_server()</a>, <a class="el" href="lwm2m-client_8c.html#aba7b68ec30cfea70b5ee82c1cd03009b">write_access_control_tlv()</a>, <a class="el" href="lwm2m-client_8c.html#a23a0b548c8872a21f88ff3d2017e29cb">write_security_tlv()</a>, and <a class="el" href="lwm2m-client_8c.html#a3b1cc4c5d3b4f923ad40856eff993ad9">write_server_tlv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5408488d546a6b48a17852eda5e14263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_STR_SLICE_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>){.len = (_len), .data = (_s) }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro to make easier to declare a string slice from a string. </p>

<p>Referenced by <a class="el" href="group__Buffer.html#ga8514e78d12dbe8c959af39de05f7c547">sol_buffer_get_slice()</a>, <a class="el" href="group__Buffer.html#ga30d3b8cf7723ce4ffc156612fa5b7c38">sol_buffer_get_slice_at()</a>, <a class="el" href="group__JSON.html#ga551365a65faae1bff535314f787e2ed7">sol_json_token_to_slice()</a>, <a class="el" href="group__Str__Slice.html#gafc4606ede8c6c6bf264e71b08f0338e7">sol_str_slice_from_blob()</a>, <a class="el" href="group__Str__Slice.html#ga403d23f24219db595e892573d3384c37">sol_str_slice_from_str()</a>, and <a class="el" href="group__Str__Slice.html#ga0f4d08b88b025e80b53b5a29f6874438">sol_str_slice_str_contains()</a>.</p>

</div>
</div>
<a class="anchor" id="gae90cc2b106b3e1c0e0e32b2abfa04e51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_STR_STATIC_ASSERT_LITERAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_s</td><td>)</td>
          <td>&#160;&#160;&#160;(&quot;&quot; _s)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro to assert that the parameter is a string literal. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga00b12417410f87f4d69a7e7fa1bf3fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>  <a class="el" href="structsol__str__slice.html">sol_str_slice</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String slice type. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga3dd28a97f9e08ef7bfe14059566ffdf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sol_str_slice_case_eq </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the content of both slices are equal. </p>
<p>Similar to <a class="el" href="group__Str__Slice.html#ga3dd28a97f9e08ef7bfe14059566ffdf6">sol_str_slice_case_eq</a>, but ignoring the case of the characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First slice </td></tr>
    <tr><td class="paramname">b</td><td>Second slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents are equal, <code>false</code> otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Str__Slice.html#gafcd2df3e13b5a2d9b0e35568366dfb62" title="Checks if the content of both slices are equal. ">sol_str_slice_eq</a> </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, and <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

</div>
</div>
<a class="anchor" id="ga325f80e2f43dcf071ef158a58c909990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* sol_str_slice_contains </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>haystack</code> contains <code>needle</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>Slice that will be searched </td></tr>
    <tr><td class="paramname">needle</td><td>Slice to search for in <code>haystack</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the beginning of substring or <code>NULL</code> if not </dd></dl>

<p>Referenced by <a class="el" href="group__Str__Slice.html#ga0f4d08b88b025e80b53b5a29f6874438">sol_str_slice_str_contains()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e4ef16628eb50961dd7307c052fb768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sol_str_slice_copy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of slice <code>src</code> into string <code>dst</code>. </p>
<dl class="section note"><dt>Note</dt><dd><code>dst</code> must be large enough to receive the copy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source slice </td></tr>
    <tr><td class="paramname">dst</td><td>Destination string </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, and <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

</div>
</div>
<a class="anchor" id="gafcd2df3e13b5a2d9b0e35568366dfb62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sol_str_slice_eq </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the content of both slices are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First slice </td></tr>
    <tr><td class="paramname">b</td><td>Second slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents are equal, <code>false</code> otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Str__Slice.html#ga3dd28a97f9e08ef7bfe14059566ffdf6" title="Checks if the content of both slices are equal. ">sol_str_slice_case_eq</a> </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, and <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

</div>
</div>
<a class="anchor" id="gafc4606ede8c6c6bf264e71b08f0338e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> sol_str_slice_from_blob </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__blob.html">sol_blob</a> *&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populates a slice from a <a class="el" href="structsol__blob.html">sol_blob</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Source blob</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting slice </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2common_2uart_8c-example.html#a9">/src/samples/common/uart.c</a>, <a class="el" href="src_2samples_2crypto_2message-digest_8c-example.html#a19">/src/samples/crypto/message-digest.c</a>, <a class="el" href="src_2samples_2crypto_2sha256sum_8c-example.html#a20">/src/samples/crypto/sha256sum.c</a>, <a class="el" href="src_2samples_2design_patterns_2stream_sample_8c-example.html#a74">/src/samples/design_patterns/stream_sample.c</a>, and <a class="el" href="src_2samples_2http_2server-sse_8c-example.html#a28">/src/samples/http/server-sse.c</a>.</dd>
</dl>
<p>References <a class="el" href="group__Str__Slice.html#ga5408488d546a6b48a17852eda5e14263">SOL_STR_SLICE_STR</a>.</p>

<p>Referenced by <a class="el" href="message-digest_8c.html#aba0408da6b1969a990e9e82ed7bfc7fa">on_digest_ready()</a>, <a class="el" href="stream__sample_8c.html#a35dc30440509d1cc850f88847ee59abf">on_feed_done()</a>, <a class="el" href="server-sse_8c.html#ad181df11d66483eb7911a57090fddcd0">on_feed_done_cb()</a>, <a class="el" href="uart_8c.html#a8694ec865bfd7b8d243ca28de0957684">producer_data_written()</a>, <a class="el" href="uart_8c.html#af9f6c5e151a851d960a38b4d4b1cb432">producer_make_data()</a>, <a class="el" href="uart_8c.html#ac7f3be202700792259fedf833dcf695a">send_blob()</a>, and <a class="el" href="sha256sum_8c.html#ab94c68210a66948eef1c1b30ad8cd870">store_digest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga403d23f24219db595e892573d3384c37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> sol_str_slice_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populates a slice from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Source string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting slice </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2coap_2iotivity-test-client_8c-example.html#a104">/src/samples/coap/iotivity-test-client.c</a>, <a class="el" href="src_2samples_2coap_2lwm2m-bs-server_8c-example.html#a59">/src/samples/coap/lwm2m-bs-server.c</a>, <a class="el" href="src_2samples_2coap_2lwm2m-client_8c-example.html#a174">/src/samples/coap/lwm2m-client.c</a>, <a class="el" href="src_2samples_2coap_2lwm2m-server_8c-example.html#a72">/src/samples/coap/lwm2m-server.c</a>, <a class="el" href="src_2samples_2coap_2oic-server_8c-example.html#a31">/src/samples/coap/oic-server.c</a>, <a class="el" href="src_2samples_2coap_2simple-client_8c-example.html#a35">/src/samples/coap/simple-client.c</a>, <a class="el" href="src_2samples_2common_2uart_8c-example.html#a20">/src/samples/common/uart.c</a>, <a class="el" href="src_2samples_2crypto_2message-digest_8c-example.html#a39">/src/samples/crypto/message-digest.c</a>, <a class="el" href="src_2samples_2http_2client_8c-example.html#a25">/src/samples/http/client.c</a>, and <a class="el" href="src_2samples_2http_2server_8c-example.html#a35">/src/samples/http/server.c</a>.</dd>
</dl>
<p>References <a class="el" href="group__Str__Slice.html#ga5408488d546a6b48a17852eda5e14263">SOL_STR_SLICE_STR</a>.</p>

<p>Referenced by <a class="el" href="client_8c.html#aa73fb5506579d04702d9cfbcf2805c0d">create_post_data_params()</a>, <a class="el" href="iotivity-test-client_8c.html#a6cc09e22b723e2987b025a998783466f">found_resource()</a>, <a class="el" href="lwm2m-bs-server_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>, <a class="el" href="uart_8c.html#af9f6c5e151a851d960a38b4d4b1cb432">producer_make_data()</a>, <a class="el" href="oic-server_8c.html#a99bec4e8baf109cdee1b201bb7cb6800">register_light_resource_type()</a>, <a class="el" href="group__HTTP.html#ga6e1fb0f881d40c6df23650584d100642">sol_http_create_uri_from_str()</a>, <a class="el" href="group__Str__Slice.html#gab73df3c88f46837811e41ca99686d7f6">sol_str_slice_str_split_iterate()</a>, <a class="el" href="message-digest_8c.html#a8f65ca9f5a72be7fe776126fc632f8a9">startup()</a>, and <a class="el" href="server_8c.html#a01f52f14b9e6dd3c57b905c4db4213bf">startup_server()</a>.</p>

</div>
</div>
<a class="anchor" id="gac46c0b5366a490b25522a4616dca2c6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> sol_str_slice_remove_leading_whitespace </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice based on <code>slice</code> but without leading white spaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Source slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Slice without leading white spaces </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, and <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

<p>Referenced by <a class="el" href="group__Str__Slice.html#gabcc097cf62d4570372460a99eae3ac10">sol_str_slice_trim()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed21c434f0fd35b428b13121d890c2c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> sol_str_slice_remove_trailing_whitespace </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice based on <code>slice</code> but without trailing white spaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Source slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Slice without trailing white spaces </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, and <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

<p>Referenced by <a class="el" href="group__Str__Slice.html#gabcc097cf62d4570372460a99eae3ac10">sol_str_slice_trim()</a>.</p>

</div>
</div>
<a class="anchor" id="ga76bd8b299154e2291c671f6c55192375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsol__vector.html">sol_vector</a> sol_str_slice_split </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsplit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of the words in a given string slice, using <code>delim</code> as delimiter string. </p>
<p>If <em>maxsplit</em> is given, at most that number of splits are done (thus, the list will have at most <code>maxsplit+1</code> elements). If <code>maxsplit</code> is zero, then there is no limit on the number of splits (all possible splits are made).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Source slice </td></tr>
    <tr><td class="paramname">delim</td><td>Delimiter string </td></tr>
    <tr><td class="paramname">maxsplit</td><td>The maximum number of splits to make</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, vector of string slices of the words, <code>NULL</code> otherwise. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Str__Slice.html#ga3cfe14e986cd5aa51b63d59059b4fb55" title="Do an one step split iteration over a slice. ">sol_str_slice_split_iterate()</a> </dd>
<dd>
<a class="el" href="group__Str__Slice.html#gab73df3c88f46837811e41ca99686d7f6" title="Wrapper over sol_str_slice_split_iterate() ">sol_str_slice_str_split_iterate()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2http_2client_8c-example.html#a24">/src/samples/http/client.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="client_8c.html#aa73fb5506579d04702d9cfbcf2805c0d">create_post_data_params()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3cfe14e986cd5aa51b63d59059b4fb55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sol_str_slice_split_iterate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>itr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do an one step split iteration over a slice. </p>
<p>Usage example: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structsol__str__slice.html">sol_str_slice</a> slice = <a class="code" href="group__Str__Slice.html#ga286e4d6331e05cd18747d0d7deb06984">SOL_STR_SLICE_LITERAL</a>(<span class="stringliteral">&quot;one;two;three&quot;</span>);</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structsol__str__slice.html">sol_str_slice</a> token;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *itr = NULL;</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code" href="group__Str__Slice.html#ga3cfe14e986cd5aa51b63d59059b4fb55">sol_str_slice_split_iterate</a>(slice, &amp;token, &amp;itr, <span class="stringliteral">&quot;;&quot;</span>)) {</div>
<div class="line">   printf(<span class="stringliteral">&quot;%.*s\t&quot;</span>, <a class="code" href="group__Str__Slice.html#ga10c9d829c4d0c50467106a14190d7611">SOL_STR_SLICE_PRINT</a>(token));</div>
<div class="line">   <span class="comment">//It will print: one two three</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice the be splitted </td></tr>
    <tr><td class="paramname">token</td><td>A splitted token </td></tr>
    <tr><td class="paramname">itr</td><td>An iterator - It should be <code>NULL</code> on the first call. </td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if iteration should continue or <code>false</code> if iteration should be stopped. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Str__Slice.html#ga76bd8b299154e2291c671f6c55192375" title="Return a list of the words in a given string slice, using delim as delimiter string. ">sol_str_slice_split()</a> </dd>
<dd>
<a class="el" href="group__Str__Slice.html#gab73df3c88f46837811e41ca99686d7f6" title="Wrapper over sol_str_slice_split_iterate() ">sol_str_slice_str_split_iterate()</a> </dd></dl>

<p>Referenced by <a class="el" href="group__Str__Slice.html#gab73df3c88f46837811e41ca99686d7f6">sol_str_slice_str_split_iterate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga452957e2ea411197e10a5503a9dd2f1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sol_str_slice_starts_with </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>slice</code> begins with <code>prefix</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>String slice </td></tr>
    <tr><td class="paramname">prefix</td><td>Prefix to look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>slice</code> begins with <code>prefix</code>, <code>false</code> otherwise </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, and <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

</div>
</div>
<a class="anchor" id="gaf4c1e30c2e1c9f40003ce69741ebb071"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sol_str_slice_str_case_eq </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the content of the slice is equal to the string. </p>
<p>Similar to <a class="el" href="group__Str__Slice.html#ga80d120c6bf5edb6ded99ecfa5700afb2">sol_str_slice_str_eq</a>, but ignoring the case of the characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The string slice </td></tr>
    <tr><td class="paramname">b</td><td>The string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents are equal, <code>false</code> otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Str__Slice.html#ga80d120c6bf5edb6ded99ecfa5700afb2" title="Checks if the content of the slice is equal to the string. ">sol_str_slice_str_eq</a> </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, and <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f4d08b88b025e80b53b5a29f6874438"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* sol_str_slice_str_contains </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>haystack</code> contains <code>needle</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>Slice that will be searched </td></tr>
    <tr><td class="paramname">needle</td><td>String to search for in <code>haystack</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the beginning of substring or <code>NULL</code> if not </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2common_2uart_8c-example.html#a28">/src/samples/common/uart.c</a>.</dd>
</dl>
<p>References <a class="el" href="group__Str__Slice.html#ga325f80e2f43dcf071ef158a58c909990">sol_str_slice_contains()</a>, and <a class="el" href="group__Str__Slice.html#ga5408488d546a6b48a17852eda5e14263">SOL_STR_SLICE_STR</a>.</p>

<p>Referenced by <a class="el" href="uart_8c.html#a1c8a75dae299b5c84afe1f2ec1735aea">consumer_read_available()</a>.</p>

</div>
</div>
<a class="anchor" id="ga80d120c6bf5edb6ded99ecfa5700afb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sol_str_slice_str_eq </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the content of the slice is equal to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The string slice </td></tr>
    <tr><td class="paramname">b</td><td>The string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents are equal, <code>false</code> otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Str__Slice.html#gaf4c1e30c2e1c9f40003ce69741ebb071" title="Checks if the content of the slice is equal to the string. ">sol_str_slice_str_case_eq</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="src_2samples_2design_patterns_2stream_sample_8c-example.html#a82">/src/samples/design_patterns/stream_sample.c</a>, and <a class="el" href="src_2samples_2http_2server-sse_8c-example.html#a29">/src/samples/http/server-sse.c</a>.</dd>
</dl>
<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, and <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

<p>Referenced by <a class="el" href="stream__sample_8c.html#a29596b98823f06a7a9ec2c2874aa52b4">on_data()</a>, <a class="el" href="server-sse_8c.html#ad181df11d66483eb7911a57090fddcd0">on_feed_done_cb()</a>, and <a class="el" href="group__MemDesc.html#ga976bbe363ddef0f9aab260035d1ad75b">sol_memdesc_find_structure_member()</a>.</p>

</div>
</div>
<a class="anchor" id="gab73df3c88f46837811e41ca99686d7f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sol_str_slice_str_split_iterate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>itr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper over <a class="el" href="group__Str__Slice.html#ga3cfe14e986cd5aa51b63d59059b4fb55" title="Do an one step split iteration over a slice. ">sol_str_slice_split_iterate()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>The slice the be splitted </td></tr>
    <tr><td class="paramname">token</td><td>A splitted token </td></tr>
    <tr><td class="paramname">itr</td><td>An iterator - It should be <code>NULL</code> on the first call. </td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Str__Slice.html#ga3cfe14e986cd5aa51b63d59059b4fb55" title="Do an one step split iteration over a slice. ">sol_str_slice_split_iterate()</a> </dd>
<dd>
<a class="el" href="group__Str__Slice.html#ga76bd8b299154e2291c671f6c55192375" title="Return a list of the words in a given string slice, using delim as delimiter string. ">sol_str_slice_split()</a> </dd></dl>

<p>References <a class="el" href="group__Str__Slice.html#ga403d23f24219db595e892573d3384c37">sol_str_slice_from_str()</a>, and <a class="el" href="group__Str__Slice.html#ga3cfe14e986cd5aa51b63d59059b4fb55">sol_str_slice_split_iterate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5776e87c37032d1d7839826063b3db07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sol_str_slice_str_starts_with </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>slice</code> begins with <code>prefix</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>String slice </td></tr>
    <tr><td class="paramname">prefix</td><td>Prefix to look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>slice</code> begins with <code>prefix</code>, <code>false</code> otherwise </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, and <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

</div>
</div>
<a class="anchor" id="gae2eaefa8a2bde45e217835c8824296e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsol__blob.html">sol_blob</a>* sol_str_slice_to_blob </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a blob from a slice. </p>
<p>This function creates <a class="el" href="group__Types.html#gafc93597dbfb82dd2b50ce0261d583895">SOL_BLOB_TYPE_DEFAULT</a>, this means that the memory used by the slice will be duplicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Source slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A blob or <code>NULL</code> on error </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>, <a class="el" href="group__Types.html#ga42c9abd2ff9950e7ac828c313fb758c9">sol_blob_new()</a>, and <a class="el" href="group__Types.html#gafc93597dbfb82dd2b50ce0261d583895">SOL_BLOB_TYPE_DEFAULT</a>.</p>

</div>
</div>
<a class="anchor" id="gaf5a06ca49d46b835a32f4765ac480f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_str_slice_to_int </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string slice to an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String slice </td></tr>
    <tr><td class="paramname">value</td><td>Where to store the integer value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on success, error code (always negative) otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gac91337d929f8c612000eb64c0688d812"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* sol_str_slice_to_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a string from a string slice. </p>
<dl class="section note"><dt>Note</dt><dd>Content is duplicated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Source slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New string created from the slice </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a38ae63b741a375104ae7cc3a5da911a4">sol_str_slice::data</a>, and <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>.</p>

</div>
</div>
<a class="anchor" id="gabcc097cf62d4570372460a99eae3ac10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> sol_str_slice_trim </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice based on <code>slice</code> but without either leading or trailing white spaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Source slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Slice without either leading or trailing white spaces </dd></dl>

<p>References <a class="el" href="group__Str__Slice.html#gac46c0b5366a490b25522a4616dca2c6f">sol_str_slice_remove_leading_whitespace()</a>, and <a class="el" href="group__Str__Slice.html#gaed21c434f0fd35b428b13121d890c2c9">sol_str_slice_remove_trailing_whitespace()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<a href="http://solettaproject.github.io/docs/">Full online documentation</a> | 
<a href="index.html">C API Index</a>
</small></address>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
