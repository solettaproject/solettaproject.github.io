<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Soletta™ Framework: Memory Description</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Soletta™ Framework
   </div>
   <div id="projectbrief">
   Framework for making IoT devices<br /><br />
   <small>
   <a href="http://solettaproject.github.io/docs/">Full online documentation</a> | 
   <a href="index.html">C API Index</a>
   </small><br />
   </div>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Memory Description<div class="ingroups"><a class="el" href="group__Datatypes.html">Data types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A memory description (memdesc) allows code to know how to handle it in runtime, such as decode/parse from some other representation (text/json), or serialize/encode.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__memdesc.html">sol_memdesc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type to describe a memory region.  <a href="structsol__memdesc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__memdesc__ops.html">sol_memdesc_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">override operations to be used in this memory description.  <a href="structsol__memdesc__ops.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__memdesc__ops__array.html">sol_memdesc_ops_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations specific to SOL_MEMDESC_TYPE_ARRAY.  <a href="structsol__memdesc__ops__array.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__memdesc__ops__enumeration.html">sol_memdesc_ops_enumeration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations specific to SOL_MEMDESC_TYPE_ENUMERATION.  <a href="structsol__memdesc__ops__enumeration.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__memdesc__serialize__options.html">sol_memdesc_serialize_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options on how to serialize a memory given its description.  <a href="structsol__memdesc__serialize__options.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__memdesc__structure__member.html">sol_memdesc_structure_member</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a structure member.  <a href="structsol__memdesc__structure__member.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaaade55a327e92316544062bd1ec58404"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gaaade55a327e92316544062bd1ec58404">_SOL_MEMDESC_CHECK</a>(desc)&#160;&#160;&#160;((desc) &amp;&amp;  <a class="el" href="group__MemDesc.html#ga8ac0dea7fb4518661b7ed675725262b6">_SOL_MEMDESC_CHECK_API_VERSION</a>(desc) &amp;&amp; (desc)-&gt;type != <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac3dfe9f64528572b8fd1b1e54c72307c">SOL_MEMDESC_TYPE_UNKNOWN</a>)</td></tr>
<tr class="memdesc:gaaade55a327e92316544062bd1ec58404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check for a valid struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a>.  <a href="#gaaade55a327e92316544062bd1ec58404">More...</a><br/></td></tr>
<tr class="separator:gaaade55a327e92316544062bd1ec58404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ac0dea7fb4518661b7ed675725262b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga8ac0dea7fb4518661b7ed675725262b6">_SOL_MEMDESC_CHECK_API_VERSION</a>(desc)&#160;&#160;&#160;((desc)-&gt;api_version == <a class="el" href="group__MemDesc.html#ga20a25d21b3f9a0a8294e8ffba179f5f1">SOL_MEMDESC_API_VERSION_COMPILED</a>)</td></tr>
<tr class="memdesc:ga8ac0dea7fb4518661b7ed675725262b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check api-version if needed.  <a href="#ga8ac0dea7fb4518661b7ed675725262b6">More...</a><br/></td></tr>
<tr class="separator:ga8ac0dea7fb4518661b7ed675725262b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23a9bd736adbad2e078c526fbe8287e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga23a9bd736adbad2e078c526fbe8287e9">_SOL_MEMDESC_CHECK_STRUCTURE</a>(structure_desc)&#160;&#160;&#160;(<a class="el" href="group__MemDesc.html#gaaade55a327e92316544062bd1ec58404">_SOL_MEMDESC_CHECK</a>(structure_desc) &amp;&amp; (structure_desc)-&gt;structure_members &amp;&amp; <a class="el" href="group__MemDesc.html#gaaade55a327e92316544062bd1ec58404">_SOL_MEMDESC_CHECK</a>(&amp;((structure_desc)-&gt;structure_members-&gt;base)))</td></tr>
<tr class="memdesc:ga23a9bd736adbad2e078c526fbe8287e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check for a valid struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a> of type SOL_MEMDESC_TYPE_STRUCTURE.  <a href="#ga23a9bd736adbad2e078c526fbe8287e9">More...</a><br/></td></tr>
<tr class="separator:ga23a9bd736adbad2e078c526fbe8287e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd4878e2100438124e598a6dd5ede3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">_SOL_MEMDESC_CHECK_STRUCTURE_MEMBER</a>(structure_desc, member_desc)</td></tr>
<tr class="memdesc:ga6bd4878e2100438124e598a6dd5ede3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check for a valid struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a> of type SOL_MEMDESC_TYPE_STRUCTURE and if member is within structure boundaries.  <a href="#ga6bd4878e2100438124e598a6dd5ede3e">More...</a><br/></td></tr>
<tr class="separator:ga6bd4878e2100438124e598a6dd5ede3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd1329c4c24b7873600a329d2fdac242"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gadd1329c4c24b7873600a329d2fdac242">SOL_MEMDESC_DESCRIPTION</a></td></tr>
<tr class="memdesc:gadd1329c4c24b7873600a329d2fdac242"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is selected at compile time to allow reducing binary size if this cpp symbol is undefined.  <a href="#gadd1329c4c24b7873600a329d2fdac242">More...</a><br/></td></tr>
<tr class="separator:gadd1329c4c24b7873600a329d2fdac242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebcbe2dfd97f02c6bc6dfab4ba074600"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gaebcbe2dfd97f02c6bc6dfab4ba074600">SOL_MEMDESC_FOREACH_ARRAY_ELEMENT_IN_RANGE</a>(desc, memory, start_idx, end_idx, itr_idx, element)</td></tr>
<tr class="memdesc:gaebcbe2dfd97f02c6bc6dfab4ba074600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to loop of array elements in a given range.  <a href="#gaebcbe2dfd97f02c6bc6dfab4ba074600">More...</a><br/></td></tr>
<tr class="separator:gaebcbe2dfd97f02c6bc6dfab4ba074600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77caa7c74a7f7652cc117d0d73cc9fbb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga77caa7c74a7f7652cc117d0d73cc9fbb">SOL_MEMDESC_FOREACH_STRUCTURE_MEMBER</a>(structure_desc, member_desc)</td></tr>
<tr class="memdesc:ga77caa7c74a7f7652cc117d0d73cc9fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to loop over all structure members.  <a href="#ga77caa7c74a7f7652cc117d0d73cc9fbb">More...</a><br/></td></tr>
<tr class="separator:ga77caa7c74a7f7652cc117d0d73cc9fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7b8e9a4657412275f8e265b2a2429a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga9b7b8e9a4657412275f8e265b2a2429a">SOL_MEMDESC_FOREACH_STRUCTURE_MEMBER_MEMORY</a>(structure_desc, member_desc, structure_memory, member_memory)</td></tr>
<tr class="memdesc:ga9b7b8e9a4657412275f8e265b2a2429a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to loop over all structure members and associated memory.  <a href="#ga9b7b8e9a4657412275f8e265b2a2429a">More...</a><br/></td></tr>
<tr class="separator:ga9b7b8e9a4657412275f8e265b2a2429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d4285c0636aed91c2ac996f06dc703"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga78d4285c0636aed91c2ac996f06dc703">SOL_MEMDESC_SET_DESCRIPTION</a>(...)</td></tr>
<tr class="memdesc:ga78d4285c0636aed91c2ac996f06dc703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to set the description member of struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a> if that is available (conditional to <a class="el" href="group__MemDesc.html#ga78d4285c0636aed91c2ac996f06dc703" title="Helper to set the description member of struct sol_memdesc if that is available (conditional to SOL_M...">SOL_MEMDESC_SET_DESCRIPTION</a>).  <a href="#ga78d4285c0636aed91c2ac996f06dc703">More...</a><br/></td></tr>
<tr class="separator:ga78d4285c0636aed91c2ac996f06dc703"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2b13d962dab50f6cfcff80523b38162f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga2b13d962dab50f6cfcff80523b38162f">sol_memdesc</a></td></tr>
<tr class="memdesc:ga2b13d962dab50f6cfcff80523b38162f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type to describe a memory region.  <a href="#ga2b13d962dab50f6cfcff80523b38162f">More...</a><br/></td></tr>
<tr class="separator:ga2b13d962dab50f6cfcff80523b38162f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90e26b23ad997f8683b47747e8648d7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsol__memdesc__ops.html">sol_memdesc_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gaf90e26b23ad997f8683b47747e8648d7">sol_memdesc_ops</a></td></tr>
<tr class="memdesc:gaf90e26b23ad997f8683b47747e8648d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">override operations to be used in this memory description.  <a href="#gaf90e26b23ad997f8683b47747e8648d7">More...</a><br/></td></tr>
<tr class="separator:gaf90e26b23ad997f8683b47747e8648d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7db4ac58d1217cadfd4db464f9775ad"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structsol__memdesc__ops__array.html">sol_memdesc_ops_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gab7db4ac58d1217cadfd4db464f9775ad">sol_memdesc_ops_array</a></td></tr>
<tr class="memdesc:gab7db4ac58d1217cadfd4db464f9775ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations specific to SOL_MEMDESC_TYPE_ARRAY.  <a href="#gab7db4ac58d1217cadfd4db464f9775ad">More...</a><br/></td></tr>
<tr class="separator:gab7db4ac58d1217cadfd4db464f9775ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae11f38d64f3e8b448d4ea8bab4f5ba95"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structsol__memdesc__ops__enumeration.html">sol_memdesc_ops_enumeration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gae11f38d64f3e8b448d4ea8bab4f5ba95">sol_memdesc_ops_enumeration</a></td></tr>
<tr class="memdesc:gae11f38d64f3e8b448d4ea8bab4f5ba95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations specific to SOL_MEMDESC_TYPE_ENUMERATION.  <a href="#gae11f38d64f3e8b448d4ea8bab4f5ba95">More...</a><br/></td></tr>
<tr class="separator:gae11f38d64f3e8b448d4ea8bab4f5ba95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69412858d81bbdda411ce0bb0da46ffe"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structsol__memdesc__serialize__options.html">sol_memdesc_serialize_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga69412858d81bbdda411ce0bb0da46ffe">sol_memdesc_serialize_options</a></td></tr>
<tr class="memdesc:ga69412858d81bbdda411ce0bb0da46ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options on how to serialize a memory given its description.  <a href="#ga69412858d81bbdda411ce0bb0da46ffe">More...</a><br/></td></tr>
<tr class="separator:ga69412858d81bbdda411ce0bb0da46ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac479d00071729f2130277d8f9a515635"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structsol__memdesc__structure__member.html">sol_memdesc_structure_member</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gac479d00071729f2130277d8f9a515635">sol_memdesc_structure_member</a></td></tr>
<tr class="memdesc:gac479d00071729f2130277d8f9a515635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a structure member.  <a href="#gac479d00071729f2130277d8f9a515635">More...</a><br/></td></tr>
<tr class="separator:gac479d00071729f2130277d8f9a515635"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3c52ec00c38f79c775c72083f1d4841c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga3c52ec00c38f79c775c72083f1d4841c">sol_memdesc_type</a> { <br/>
&#160;&#160;<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac3dfe9f64528572b8fd1b1e54c72307c">SOL_MEMDESC_TYPE_UNKNOWN</a> = 0, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae2c3d8d3c93ec6d9aa54611f20c3e913">SOL_MEMDESC_TYPE_UINT8</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca01cb1624e4fabe02114fa5db9f03e345">SOL_MEMDESC_TYPE_UINT16</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca6561c68e389c6cfc4db7dd848811b637">SOL_MEMDESC_TYPE_UINT32</a>, 
<br/>
&#160;&#160;<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca8049e62c1731887c367367849c5d2f1f">SOL_MEMDESC_TYPE_UINT64</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae6f4caf8058e1173a76190e21042d3b9">SOL_MEMDESC_TYPE_ULONG</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca02dab4ccfc66e5524390735f92c9c0de">SOL_MEMDESC_TYPE_SIZE</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4cb250083cc795901380d17d0085738e">SOL_MEMDESC_TYPE_INT8</a>, 
<br/>
&#160;&#160;<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca881abb5136329d48343ea1c575e5ed23">SOL_MEMDESC_TYPE_INT16</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841caf0154175f40e717fcd34175e241003aa">SOL_MEMDESC_TYPE_INT32</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4ec317e7bf1386eb384b4fdd5e090ba4">SOL_MEMDESC_TYPE_INT64</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac0d8914705ada08d7cfbb5ee0fd630fc">SOL_MEMDESC_TYPE_LONG</a>, 
<br/>
&#160;&#160;<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca63234dcd358b64ae311f7de5e7b680b6">SOL_MEMDESC_TYPE_SSIZE</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca057f63f473f1d5aae2ebaff562cc7dc6">SOL_MEMDESC_TYPE_BOOL</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cab0b3a2427ce1d2595ce57a8feeb72dc6">SOL_MEMDESC_TYPE_DOUBLE</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca536154bbc17985de4c78e9c5c690fed1">SOL_MEMDESC_TYPE_STRING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca82c8ae1f328df6e0ccaa407afdf17ade">SOL_MEMDESC_TYPE_CONST_STRING</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacf54881cd157f17624a92d6b788b58e5">SOL_MEMDESC_TYPE_ENUMERATION</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cadd6adc5f6c11a1f7195db39671109bb8">SOL_MEMDESC_TYPE_PTR</a>, 
<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca2a345b2d1c1b976f12c3b1b178569deb">SOL_MEMDESC_TYPE_STRUCTURE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacffb2c3c105d58ea6d1caf9669fe119e">SOL_MEMDESC_TYPE_ARRAY</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga3c52ec00c38f79c775c72083f1d4841c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Designates the type of the memory description.  <a href="group__MemDesc.html#ga3c52ec00c38f79c775c72083f1d4841c">More...</a><br/></td></tr>
<tr class="separator:ga3c52ec00c38f79c775c72083f1d4841c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3a1fc6de62663eebd946ee6969cc162f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga3a1fc6de62663eebd946ee6969cc162f">sol_memdesc_append_array_element</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *array_desc, void *memory, const void *ptr_content)</td></tr>
<tr class="memdesc:ga3a1fc6de62663eebd946ee6969cc162f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the array element.  <a href="#ga3a1fc6de62663eebd946ee6969cc162f">More...</a><br/></td></tr>
<tr class="separator:ga3a1fc6de62663eebd946ee6969cc162f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96553ae7f8be728172d93aa3506ecaa1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga96553ae7f8be728172d93aa3506ecaa1">sol_memdesc_compare</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, const void *a_memory, const void *b_memory)</td></tr>
<tr class="memdesc:ga96553ae7f8be728172d93aa3506ecaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two memories using the given description.  <a href="#ga96553ae7f8be728172d93aa3506ecaa1">More...</a><br/></td></tr>
<tr class="separator:ga96553ae7f8be728172d93aa3506ecaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb60f862950fedb3b479bc3cb5cf18f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gadbb60f862950fedb3b479bc3cb5cf18f">sol_memdesc_copy</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, const void *src_memory, void *dst_memory)</td></tr>
<tr class="memdesc:gadbb60f862950fedb3b479bc3cb5cf18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy the memory using the given description.  <a href="#gadbb60f862950fedb3b479bc3cb5cf18f">More...</a><br/></td></tr>
<tr class="separator:gadbb60f862950fedb3b479bc3cb5cf18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcac5a1696e9471c850b801eb3ee560f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gadcac5a1696e9471c850b801eb3ee560f">sol_memdesc_enumeration_from_str</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *enumeration, void *ptr_return, const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> str)</td></tr>
<tr class="memdesc:gadcac5a1696e9471c850b801eb3ee560f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert enumeration value from string.  <a href="#gadcac5a1696e9471c850b801eb3ee560f">More...</a><br/></td></tr>
<tr class="separator:gadcac5a1696e9471c850b801eb3ee560f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd14ae0831a2d3e2813018c3ab84fcc6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gabd14ae0831a2d3e2813018c3ab84fcc6">sol_memdesc_enumeration_to_str</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *enumeration, const void *memory)</td></tr>
<tr class="memdesc:gabd14ae0831a2d3e2813018c3ab84fcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert enumeration value to string.  <a href="#gabd14ae0831a2d3e2813018c3ab84fcc6">More...</a><br/></td></tr>
<tr class="separator:gabd14ae0831a2d3e2813018c3ab84fcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga976bbe363ddef0f9aab260035d1ad75b"><td class="memItemLeft" align="right" valign="top">static const struct <br class="typebreak"/>
<a class="el" href="structsol__memdesc__structure__member.html">sol_memdesc_structure_member</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga976bbe363ddef0f9aab260035d1ad75b">sol_memdesc_find_structure_member</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *structure_desc, struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a> name)</td></tr>
<tr class="memdesc:ga976bbe363ddef0f9aab260035d1ad75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find structure member given its name.  <a href="#ga976bbe363ddef0f9aab260035d1ad75b">More...</a><br/></td></tr>
<tr class="separator:ga976bbe363ddef0f9aab260035d1ad75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6013b38a9de317b68e62c23202afc1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga3b6013b38a9de317b68e62c23202afc1">sol_memdesc_free</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, void *memory)</td></tr>
<tr class="memdesc:ga3b6013b38a9de317b68e62c23202afc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the contents and the memory.  <a href="#ga3b6013b38a9de317b68e62c23202afc1">More...</a><br/></td></tr>
<tr class="separator:ga3b6013b38a9de317b68e62c23202afc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ee226f0aefb0ce1fd66db934eb25bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gae6ee226f0aefb0ce1fd66db934eb25bc">sol_memdesc_free_content</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, void *memory)</td></tr>
<tr class="memdesc:gae6ee226f0aefb0ce1fd66db934eb25bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">free the contents (internal memory) of a member.  <a href="#gae6ee226f0aefb0ce1fd66db934eb25bc">More...</a><br/></td></tr>
<tr class="separator:gae6ee226f0aefb0ce1fd66db934eb25bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d77924f51748a4d0385742f5f81c9e3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga3d77924f51748a4d0385742f5f81c9e3">sol_memdesc_get_array_element</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *array_desc, const void *memory, size_t idx)</td></tr>
<tr class="memdesc:ga3d77924f51748a4d0385742f5f81c9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the array element.  <a href="#ga3d77924f51748a4d0385742f5f81c9e3">More...</a><br/></td></tr>
<tr class="separator:ga3d77924f51748a4d0385742f5f81c9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e7dfb4e91de0b7a06be3c96f9dd6d1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga47e7dfb4e91de0b7a06be3c96f9dd6d1">sol_memdesc_get_array_length</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *array_desc, const void *memory)</td></tr>
<tr class="memdesc:ga47e7dfb4e91de0b7a06be3c96f9dd6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of an array.  <a href="#ga47e7dfb4e91de0b7a06be3c96f9dd6d1">More...</a><br/></td></tr>
<tr class="separator:ga47e7dfb4e91de0b7a06be3c96f9dd6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf480d2a64c26eb518f3cf15f7268c5ca"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gaf480d2a64c26eb518f3cf15f7268c5ca">sol_memdesc_get_as_int64</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, const void *memory)</td></tr>
<tr class="memdesc:gaf480d2a64c26eb518f3cf15f7268c5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to fetch the memory as the largest supported signed integer.  <a href="#gaf480d2a64c26eb518f3cf15f7268c5ca">More...</a><br/></td></tr>
<tr class="separator:gaf480d2a64c26eb518f3cf15f7268c5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89cefa454f6b3f918f283144ef6cc679"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga89cefa454f6b3f918f283144ef6cc679">sol_memdesc_get_as_uint64</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, const void *memory)</td></tr>
<tr class="memdesc:ga89cefa454f6b3f918f283144ef6cc679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to fetch the memory as the largest supported unsigned integer.  <a href="#ga89cefa454f6b3f918f283144ef6cc679">More...</a><br/></td></tr>
<tr class="separator:ga89cefa454f6b3f918f283144ef6cc679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8008efeff8fcf62a94609e9e2d86a493"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga8008efeff8fcf62a94609e9e2d86a493">sol_memdesc_get_size</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc)</td></tr>
<tr class="memdesc:ga8008efeff8fcf62a94609e9e2d86a493"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the size in bytes of the memory description.  <a href="#ga8008efeff8fcf62a94609e9e2d86a493">More...</a><br/></td></tr>
<tr class="separator:ga8008efeff8fcf62a94609e9e2d86a493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade28d2eccec2ec988f66ff69b53db2f6"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gade28d2eccec2ec988f66ff69b53db2f6">sol_memdesc_get_structure_member_memory</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *structure_desc, const struct <a class="el" href="structsol__memdesc__structure__member.html">sol_memdesc_structure_member</a> *member_desc, const void *structure_memory)</td></tr>
<tr class="memdesc:gade28d2eccec2ec988f66ff69b53db2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the pointer to the struct member memory description inside the given container.  <a href="#gade28d2eccec2ec988f66ff69b53db2f6">More...</a><br/></td></tr>
<tr class="separator:gade28d2eccec2ec988f66ff69b53db2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fda6ffc7674592fe679fa7dd937cdab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga1fda6ffc7674592fe679fa7dd937cdab">sol_memdesc_init_defaults</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, void *memory)</td></tr>
<tr class="memdesc:ga1fda6ffc7674592fe679fa7dd937cdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the memory.  <a href="#ga1fda6ffc7674592fe679fa7dd937cdab">More...</a><br/></td></tr>
<tr class="separator:ga1fda6ffc7674592fe679fa7dd937cdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e4ce689ed0c9f83771a5430a1e8c4a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga17e4ce689ed0c9f83771a5430a1e8c4a">sol_memdesc_is_signed_integer</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc)</td></tr>
<tr class="memdesc:ga17e4ce689ed0c9f83771a5430a1e8c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check if type is signed integer-compatible.  <a href="#ga17e4ce689ed0c9f83771a5430a1e8c4a">More...</a><br/></td></tr>
<tr class="separator:ga17e4ce689ed0c9f83771a5430a1e8c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0289ab11bdcd684ab575d2e50d42a453"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga0289ab11bdcd684ab575d2e50d42a453">sol_memdesc_is_unsigned_integer</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc)</td></tr>
<tr class="memdesc:ga0289ab11bdcd684ab575d2e50d42a453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to check if type is unsigned integer-compatible.  <a href="#ga0289ab11bdcd684ab575d2e50d42a453">More...</a><br/></td></tr>
<tr class="separator:ga0289ab11bdcd684ab575d2e50d42a453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabab7495cb1b24521cc73b2062a0cd5b1"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gabab7495cb1b24521cc73b2062a0cd5b1">sol_memdesc_new_with_defaults</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc)</td></tr>
<tr class="memdesc:gabab7495cb1b24521cc73b2062a0cd5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the memory required by this description and initialize it.  <a href="#gabab7495cb1b24521cc73b2062a0cd5b1">More...</a><br/></td></tr>
<tr class="separator:gabab7495cb1b24521cc73b2062a0cd5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga055d5baf195b172106eab95d5ef64b59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga055d5baf195b172106eab95d5ef64b59">sol_memdesc_resize_array</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *array_desc, void *memory, size_t length)</td></tr>
<tr class="memdesc:ga055d5baf195b172106eab95d5ef64b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the length of an array.  <a href="#ga055d5baf195b172106eab95d5ef64b59">More...</a><br/></td></tr>
<tr class="separator:ga055d5baf195b172106eab95d5ef64b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5678851794d61f8051c837466a43ffdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga5678851794d61f8051c837466a43ffdb">sol_memdesc_serialize</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, const void *memory, struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *buffer, const struct <a class="el" href="structsol__memdesc__serialize__options.html">sol_memdesc_serialize_options</a> *opts, struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *prefix)</td></tr>
<tr class="memdesc:ga5678851794d61f8051c837466a43ffdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a memory to a buffer using a description.  <a href="#ga5678851794d61f8051c837466a43ffdb">More...</a><br/></td></tr>
<tr class="separator:ga5678851794d61f8051c837466a43ffdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab759fad327ab0bb4f045b609c3a61c92"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gab759fad327ab0bb4f045b609c3a61c92">sol_memdesc_set_as_int64</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, void *memory, int64_t <a class="el" href="server_8c.html#acda54b23a3b92ae2efa63634288c0496">value</a>)</td></tr>
<tr class="memdesc:gab759fad327ab0bb4f045b609c3a61c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to set the memory as the largest supported signed integer.  <a href="#gab759fad327ab0bb4f045b609c3a61c92">More...</a><br/></td></tr>
<tr class="separator:gab759fad327ab0bb4f045b609c3a61c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6fdc09984d50cb4341eb48bd8749aa"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga3a6fdc09984d50cb4341eb48bd8749aa">sol_memdesc_set_as_uint64</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, void *memory, uint64_t <a class="el" href="server_8c.html#acda54b23a3b92ae2efa63634288c0496">value</a>)</td></tr>
<tr class="memdesc:ga3a6fdc09984d50cb4341eb48bd8749aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to set the memory as the largest supported unsigned integer.  <a href="#ga3a6fdc09984d50cb4341eb48bd8749aa">More...</a><br/></td></tr>
<tr class="separator:ga3a6fdc09984d50cb4341eb48bd8749aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495ada0bb18f030500f7ccc0c0d78cca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga495ada0bb18f030500f7ccc0c0d78cca">sol_memdesc_set_content</a> (const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *desc, void *memory, const void *ptr_content)</td></tr>
<tr class="memdesc:ga495ada0bb18f030500f7ccc0c0d78cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the content of this memory.  <a href="#ga495ada0bb18f030500f7ccc0c0d78cca">More...</a><br/></td></tr>
<tr class="separator:ga495ada0bb18f030500f7ccc0c0d78cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2404df0ccb9c89e2f0f4684d3283ce0d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__MemDesc.html#ga3c52ec00c38f79c775c72083f1d4841c">sol_memdesc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga2404df0ccb9c89e2f0f4684d3283ce0d">sol_memdesc_type_from_str</a> (const char *str)</td></tr>
<tr class="memdesc:ga2404df0ccb9c89e2f0f4684d3283ce0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Memdesc Type from string to sol_memdesc_type.  <a href="#ga2404df0ccb9c89e2f0f4684d3283ce0d">More...</a><br/></td></tr>
<tr class="separator:ga2404df0ccb9c89e2f0f4684d3283ce0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b2337a7cda7733582f3aa8c7540792"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gae9b2337a7cda7733582f3aa8c7540792">sol_memdesc_type_to_str</a> (enum <a class="el" href="group__MemDesc.html#ga3c52ec00c38f79c775c72083f1d4841c">sol_memdesc_type</a> type)</td></tr>
<tr class="memdesc:gae9b2337a7cda7733582f3aa8c7540792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a sol_memdesc_type to a string.  <a href="#gae9b2337a7cda7733582f3aa8c7540792">More...</a><br/></td></tr>
<tr class="separator:gae9b2337a7cda7733582f3aa8c7540792"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga20a25d21b3f9a0a8294e8ffba179f5f1"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga20a25d21b3f9a0a8294e8ffba179f5f1">SOL_MEMDESC_API_VERSION_COMPILED</a></td></tr>
<tr class="memdesc:ga20a25d21b3f9a0a8294e8ffba179f5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">the SOL_MEMDESC_API_VERSION this soletta build used.  <a href="#ga20a25d21b3f9a0a8294e8ffba179f5f1">More...</a><br/></td></tr>
<tr class="separator:ga20a25d21b3f9a0a8294e8ffba179f5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad75bd36de0cc58310c9512ec22d3905"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structsol__memdesc__ops.html">sol_memdesc_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gaad75bd36de0cc58310c9512ec22d3905">SOL_MEMDESC_OPS_PTR_VECTOR</a></td></tr>
<tr class="memdesc:gaad75bd36de0cc58310c9512ec22d3905"><td class="mdescLeft">&#160;</td><td class="mdescRight">operations to handle struct <a class="el" href="structsol__ptr__vector.html" title="Soletta pointer vector is a wrapper around vector with an API more convenient to handle pointers...">sol_ptr_vector</a>.  <a href="#gaad75bd36de0cc58310c9512ec22d3905">More...</a><br/></td></tr>
<tr class="separator:gaad75bd36de0cc58310c9512ec22d3905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aed8e663555d31873a9ff896a0b39ee"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structsol__memdesc__ops.html">sol_memdesc_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#ga9aed8e663555d31873a9ff896a0b39ee">SOL_MEMDESC_OPS_VECTOR</a></td></tr>
<tr class="memdesc:ga9aed8e663555d31873a9ff896a0b39ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">operations to handle struct <a class="el" href="structsol__vector.html" title="Soletta vector is an array that grows dynamically. ">sol_vector</a>.  <a href="#ga9aed8e663555d31873a9ff896a0b39ee">More...</a><br/></td></tr>
<tr class="separator:ga9aed8e663555d31873a9ff896a0b39ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf133ef43ccdc949c3c9c545608504a15"><td class="memItemLeft" align="right" valign="top">const struct <br class="typebreak"/>
<a class="el" href="structsol__memdesc__serialize__options.html">sol_memdesc_serialize_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MemDesc.html#gaf133ef43ccdc949c3c9c545608504a15">SOL_MEMDESC_SERIALIZE_OPTIONS_DEFAULT</a></td></tr>
<tr class="memdesc:gaf133ef43ccdc949c3c9c545608504a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default struct <a class="el" href="structsol__memdesc__serialize__options.html" title="Options on how to serialize a memory given its description. ">sol_memdesc_serialize_options</a>.  <a href="#gaf133ef43ccdc949c3c9c545608504a15">More...</a><br/></td></tr>
<tr class="separator:gaf133ef43ccdc949c3c9c545608504a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A memory description (memdesc) allows code to know how to handle it in runtime, such as decode/parse from some other representation (text/json), or serialize/encode. </p>
<p>It will, as well, offer special handling such as memory being duplicated and freed for strings, or defined per-description with struct <a class="el" href="structsol__memdesc.html#acabb04c96bc690acdf6255079b72eded" title="Override operations to use when operating on the memory. ">sol_memdesc::ops</a>. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaaade55a327e92316544062bd1ec58404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SOL_MEMDESC_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">desc</td><td>)</td>
          <td>&#160;&#160;&#160;((desc) &amp;&amp;  <a class="el" href="group__MemDesc.html#ga8ac0dea7fb4518661b7ed675725262b6">_SOL_MEMDESC_CHECK_API_VERSION</a>(desc) &amp;&amp; (desc)-&gt;type != <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac3dfe9f64528572b8fd1b1e54c72307c">SOL_MEMDESC_TYPE_UNKNOWN</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to check for a valid struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a>. </p>

</div>
</div>
<a class="anchor" id="ga8ac0dea7fb4518661b7ed675725262b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SOL_MEMDESC_CHECK_API_VERSION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">desc</td><td>)</td>
          <td>&#160;&#160;&#160;((desc)-&gt;api_version == <a class="el" href="group__MemDesc.html#ga20a25d21b3f9a0a8294e8ffba179f5f1">SOL_MEMDESC_API_VERSION_COMPILED</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to check api-version if needed. </p>

</div>
</div>
<a class="anchor" id="ga23a9bd736adbad2e078c526fbe8287e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SOL_MEMDESC_CHECK_STRUCTURE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">structure_desc</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="group__MemDesc.html#gaaade55a327e92316544062bd1ec58404">_SOL_MEMDESC_CHECK</a>(structure_desc) &amp;&amp; (structure_desc)-&gt;structure_members &amp;&amp; <a class="el" href="group__MemDesc.html#gaaade55a327e92316544062bd1ec58404">_SOL_MEMDESC_CHECK</a>(&amp;((structure_desc)-&gt;structure_members-&gt;base)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to check for a valid struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a> of type SOL_MEMDESC_TYPE_STRUCTURE. </p>

</div>
</div>
<a class="anchor" id="ga6bd4878e2100438124e598a6dd5ede3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _SOL_MEMDESC_CHECK_STRUCTURE_MEMBER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">structure_desc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">member_desc&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="group__MemDesc.html#gaaade55a327e92316544062bd1ec58404">_SOL_MEMDESC_CHECK</a>(&amp;(member_desc)-&gt;base) &amp;&amp; \</div>
<div class="line">    ((member_desc)-&gt;offset + <a class="code" href="group__MemDesc.html#ga8008efeff8fcf62a94609e9e2d86a493">sol_memdesc_get_size</a>(&amp;(member_desc)-&gt;base) &lt;= <a class="code" href="group__MemDesc.html#ga8008efeff8fcf62a94609e9e2d86a493">sol_memdesc_get_size</a>((structure_desc))))</div>
<div class="ttc" id="group__MemDesc_html_ga8008efeff8fcf62a94609e9e2d86a493"><div class="ttname"><a href="group__MemDesc.html#ga8008efeff8fcf62a94609e9e2d86a493">sol_memdesc_get_size</a></div><div class="ttdeci">static uint16_t sol_memdesc_get_size(const struct sol_memdesc *desc)</div><div class="ttdoc">get the size in bytes of the memory description. </div><div class="ttdef"><b>Definition:</b> sol-memdesc.h:697</div></div>
<div class="ttc" id="group__MemDesc_html_gaaade55a327e92316544062bd1ec58404"><div class="ttname"><a href="group__MemDesc.html#gaaade55a327e92316544062bd1ec58404">_SOL_MEMDESC_CHECK</a></div><div class="ttdeci">#define _SOL_MEMDESC_CHECK(desc)</div><div class="ttdoc">Helper to check for a valid struct sol_memdesc. </div><div class="ttdef"><b>Definition:</b> sol-memdesc.h:1041</div></div>
</div><!-- fragment -->
<p>Helper to check for a valid struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a> of type SOL_MEMDESC_TYPE_STRUCTURE and if member is within structure boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure_desc</td><td>the memory description of type SOL_MEMDESC_TYPE_STRUCTURE </td></tr>
    <tr><td class="paramname">member_desc</td><td>the struct <a class="el" href="structsol__memdesc__structure__member.html" title="Description of a structure member. ">sol_memdesc_structure_member</a> to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadd1329c4c24b7873600a329d2fdac242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_MEMDESC_DESCRIPTION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is selected at compile time to allow reducing binary size if this cpp symbol is undefined. </p>

</div>
</div>
<a class="anchor" id="gaebcbe2dfd97f02c6bc6dfab4ba074600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_MEMDESC_FOREACH_ARRAY_ELEMENT_IN_RANGE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">desc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">memory, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start_idx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">end_idx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">itr_idx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (itr_idx = start_idx, \</div>
<div class="line">        element = (itr_idx &lt; end_idx) ? <a class="code" href="group__MemDesc.html#ga3d77924f51748a4d0385742f5f81c9e3">sol_memdesc_get_array_element</a>((desc), (memory), itr_idx) : NULL; \</div>
<div class="line">        itr_idx &lt; end_idx &amp;&amp; element; \</div>
<div class="line">        itr_idx++, \</div>
<div class="line">        element = (itr_idx &lt; end_idx) ? <a class="code" href="group__MemDesc.html#ga3d77924f51748a4d0385742f5f81c9e3">sol_memdesc_get_array_element</a>((desc), (memory), itr_idx) : NULL)</div>
<div class="ttc" id="group__MemDesc_html_ga3d77924f51748a4d0385742f5f81c9e3"><div class="ttname"><a href="group__MemDesc.html#ga3d77924f51748a4d0385742f5f81c9e3">sol_memdesc_get_array_element</a></div><div class="ttdeci">void * sol_memdesc_get_array_element(const struct sol_memdesc *array_desc, const void *memory, size_t idx)</div><div class="ttdoc">Get the array element. </div></div>
</div><!-- fragment -->
<p>Macro to loop of array elements in a given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description of type SOL_MEMDESC_TYPE_ARRAY. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory holding the array. </td></tr>
    <tr><td class="paramname">start_idx</td><td>the starting index (inclusive). </td></tr>
    <tr><td class="paramname">end_idx</td><td>the ending index (non-inclusive, up to it). </td></tr>
    <tr><td class="paramname">itr_idx</td><td>where to store the current iteration index. </td></tr>
    <tr><td class="paramname">element</td><td>where to store the element or NULL on last iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga77caa7c74a7f7652cc117d0d73cc9fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_MEMDESC_FOREACH_STRUCTURE_MEMBER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">structure_desc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">member_desc&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (member_desc = (<a class="code" href="group__MemDesc.html#ga23a9bd736adbad2e078c526fbe8287e9">_SOL_MEMDESC_CHECK_STRUCTURE</a>((structure_desc)) &amp;&amp; <a class="code" href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">_SOL_MEMDESC_CHECK_STRUCTURE_MEMBER</a>((structure_desc), (structure_desc)-&gt;structure_members)) ? (structure_desc)-&gt;structure_members : NULL; <a class="code" href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">\</a></div>
<div class="line"><a class="code" href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">        _SOL_MEMDESC_CHECK_STRUCTURE_MEMBER</a>((structure_desc), member_desc); \</div>
<div class="line">        member_desc = <a class="code" href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">_SOL_MEMDESC_CHECK_STRUCTURE_MEMBER</a>((structure_desc), member_desc + 1) ? member_desc + 1 : NULL)</div>
<div class="ttc" id="group__MemDesc_html_ga23a9bd736adbad2e078c526fbe8287e9"><div class="ttname"><a href="group__MemDesc.html#ga23a9bd736adbad2e078c526fbe8287e9">_SOL_MEMDESC_CHECK_STRUCTURE</a></div><div class="ttdeci">#define _SOL_MEMDESC_CHECK_STRUCTURE(structure_desc)</div><div class="ttdoc">Helper to check for a valid struct sol_memdesc of type SOL_MEMDESC_TYPE_STRUCTURE. </div><div class="ttdef"><b>Definition:</b> sol-memdesc.h:1051</div></div>
<div class="ttc" id="group__MemDesc_html_ga6bd4878e2100438124e598a6dd5ede3e"><div class="ttname"><a href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">_SOL_MEMDESC_CHECK_STRUCTURE_MEMBER</a></div><div class="ttdeci">#define _SOL_MEMDESC_CHECK_STRUCTURE_MEMBER(structure_desc, member_desc)</div><div class="ttdoc">Helper to check for a valid struct sol_memdesc of type SOL_MEMDESC_TYPE_STRUCTURE and if member is wi...</div><div class="ttdef"><b>Definition:</b> sol-memdesc.h:1066</div></div>
</div><!-- fragment -->
<p>Macro to loop over all structure members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure_desc</td><td>the memory description of type SOL_MEMDESC_TYPE_STRUCTURE </td></tr>
    <tr><td class="paramname">member_desc</td><td>where to store the struct <a class="el" href="structsol__memdesc__structure__member.html" title="Description of a structure member. ">sol_memdesc_structure_member</a>. NULL when iteration ends. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__MemDesc.html#ga976bbe363ddef0f9aab260035d1ad75b">sol_memdesc_find_structure_member()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b7b8e9a4657412275f8e265b2a2429a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_MEMDESC_FOREACH_STRUCTURE_MEMBER_MEMORY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">structure_desc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">member_desc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">structure_memory, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">member_memory&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (member_desc = (<a class="code" href="group__MemDesc.html#ga23a9bd736adbad2e078c526fbe8287e9">_SOL_MEMDESC_CHECK_STRUCTURE</a>((structure_desc)) &amp;&amp; <a class="code" href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">_SOL_MEMDESC_CHECK_STRUCTURE_MEMBER</a>((structure_desc), (structure_desc)-&gt;structure_members)) ? (structure_desc)-&gt;structure_members : NULL, \</div>
<div class="line">        member_memory = member_desc ? <a class="code" href="group__MemDesc.html#gade28d2eccec2ec988f66ff69b53db2f6">sol_memdesc_get_structure_member_memory</a>((structure_desc), member_desc, (structure_memory)) : NULL; <a class="code" href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">\</a></div>
<div class="line"><a class="code" href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">        _SOL_MEMDESC_CHECK_STRUCTURE_MEMBER</a>((structure_desc), member_desc) &amp;&amp; member_memory; \</div>
<div class="line">        member_desc = <a class="code" href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">_SOL_MEMDESC_CHECK_STRUCTURE_MEMBER</a>((structure_desc), member_desc + 1) ? member_desc + 1 : NULL, \</div>
<div class="line">        member_memory = member_desc ? <a class="code" href="group__MemDesc.html#gade28d2eccec2ec988f66ff69b53db2f6">sol_memdesc_get_structure_member_memory</a>((structure_desc), member_desc, (structure_memory)) : NULL)</div>
<div class="ttc" id="group__MemDesc_html_ga23a9bd736adbad2e078c526fbe8287e9"><div class="ttname"><a href="group__MemDesc.html#ga23a9bd736adbad2e078c526fbe8287e9">_SOL_MEMDESC_CHECK_STRUCTURE</a></div><div class="ttdeci">#define _SOL_MEMDESC_CHECK_STRUCTURE(structure_desc)</div><div class="ttdoc">Helper to check for a valid struct sol_memdesc of type SOL_MEMDESC_TYPE_STRUCTURE. </div><div class="ttdef"><b>Definition:</b> sol-memdesc.h:1051</div></div>
<div class="ttc" id="group__MemDesc_html_ga6bd4878e2100438124e598a6dd5ede3e"><div class="ttname"><a href="group__MemDesc.html#ga6bd4878e2100438124e598a6dd5ede3e">_SOL_MEMDESC_CHECK_STRUCTURE_MEMBER</a></div><div class="ttdeci">#define _SOL_MEMDESC_CHECK_STRUCTURE_MEMBER(structure_desc, member_desc)</div><div class="ttdoc">Helper to check for a valid struct sol_memdesc of type SOL_MEMDESC_TYPE_STRUCTURE and if member is wi...</div><div class="ttdef"><b>Definition:</b> sol-memdesc.h:1066</div></div>
<div class="ttc" id="group__MemDesc_html_gade28d2eccec2ec988f66ff69b53db2f6"><div class="ttname"><a href="group__MemDesc.html#gade28d2eccec2ec988f66ff69b53db2f6">sol_memdesc_get_structure_member_memory</a></div><div class="ttdeci">static void * sol_memdesc_get_structure_member_memory(const struct sol_memdesc *structure_desc, const struct sol_memdesc_structure_member *member_desc, const void *structure_memory)</div><div class="ttdoc">get the pointer to the struct member memory description inside the given container. </div><div class="ttdef"><b>Definition:</b> sol-memdesc.h:1149</div></div>
</div><!-- fragment -->
<p>Macro to loop over all structure members and associated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure_desc</td><td>the memory description of type SOL_MEMDESC_TYPE_STRUCTURE </td></tr>
    <tr><td class="paramname">member_desc</td><td>where to store the struct <a class="el" href="structsol__memdesc__structure__member.html" title="Description of a structure member. ">sol_memdesc_structure_member</a>. NULL when iteration ends. </td></tr>
    <tr><td class="paramname">structure_memory</td><td>the memory of the container structure. </td></tr>
    <tr><td class="paramname">member_memory</td><td>where to store the element memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga78d4285c0636aed91c2ac996f06dc703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_MEMDESC_SET_DESCRIPTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to set the description member of struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a> if that is available (conditional to <a class="el" href="group__MemDesc.html#ga78d4285c0636aed91c2ac996f06dc703" title="Helper to set the description member of struct sol_memdesc if that is available (conditional to SOL_M...">SOL_MEMDESC_SET_DESCRIPTION</a>). </p>
<p>It takes C statements and conditionally uses or eliminates them. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga2b13d962dab50f6cfcff80523b38162f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a>  <a class="el" href="structsol__memdesc.html">sol_memdesc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type to describe a memory region. </p>

</div>
</div>
<a class="anchor" id="gaf90e26b23ad997f8683b47747e8648d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsol__memdesc__ops.html">sol_memdesc_ops</a>  <a class="el" href="structsol__memdesc__ops.html">sol_memdesc_ops</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>override operations to be used in this memory description. </p>
<p>By default the operations will be done in a fixed way unless overriden by an <code>ops</code> structure, this may be used to correlate members in a structure, such as struct <a class="el" href="structsol__vector.html" title="Soletta vector is an array that grows dynamically. ">sol_vector</a> where length is a member and the contents is another, with element_size being specified in yet-another. Then things like "copy" will not be a simple copy of each member.</p>
<p>To map struct <a class="el" href="structsol__vector.html" title="Soletta vector is an array that grows dynamically. ">sol_vector</a>, use SOL_MEMDESC_OPS_VECTOR. to map struct <a class="el" href="structsol__ptr__vector.html" title="Soletta pointer vector is a wrapper around vector with an API more convenient to handle pointers...">sol_ptr_vector</a> use SOL_MEMDESC_OPS_PTR_VECTOR. </p>

</div>
</div>
<a class="anchor" id="gab7db4ac58d1217cadfd4db464f9775ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsol__memdesc__ops__array.html">sol_memdesc_ops_array</a>  <a class="el" href="structsol__memdesc__ops__array.html">sol_memdesc_ops_array</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operations specific to SOL_MEMDESC_TYPE_ARRAY. </p>
<p>This provides array-specific operations to use when dealing with a memory description.</p>
<dl class="section see"><dt>See Also</dt><dd>struct <a class="el" href="structsol__memdesc__ops.html" title="override operations to be used in this memory description. ">sol_memdesc_ops</a> </dd>
<dd>
struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae11f38d64f3e8b448d4ea8bab4f5ba95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsol__memdesc__ops__enumeration.html">sol_memdesc_ops_enumeration</a>  <a class="el" href="structsol__memdesc__ops__enumeration.html">sol_memdesc_ops_enumeration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operations specific to SOL_MEMDESC_TYPE_ENUMERATION. </p>
<p>This provides enumeration-specific operations to use when dealing with a memory description.</p>
<dl class="section see"><dt>See Also</dt><dd>struct <a class="el" href="structsol__memdesc__ops.html" title="override operations to be used in this memory description. ">sol_memdesc_ops</a> </dd>
<dd>
struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga69412858d81bbdda411ce0bb0da46ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsol__memdesc__serialize__options.html">sol_memdesc_serialize_options</a>  <a class="el" href="structsol__memdesc__serialize__options.html">sol_memdesc_serialize_options</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options on how to serialize a memory given its description. </p>

</div>
</div>
<a class="anchor" id="gac479d00071729f2130277d8f9a515635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsol__memdesc__structure__member.html">sol_memdesc_structure_member</a>  <a class="el" href="structsol__memdesc__structure__member.html">sol_memdesc_structure_member</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Description of a structure member. </p>
<p>This description extends the base description and adds name, offset and some flags.</p>
<dl class="section see"><dt>See Also</dt><dd>struct <a class="el" href="structsol__memdesc.html" title="Data type to describe a memory region. ">sol_memdesc</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga3c52ec00c38f79c775c72083f1d4841c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MemDesc.html#ga3c52ec00c38f79c775c72083f1d4841c">sol_memdesc_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Designates the type of the memory description. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841cac3dfe9f64528572b8fd1b1e54c72307c"></a>SOL_MEMDESC_TYPE_UNKNOWN</em>&#160;</td><td class="fielddoc">
<p>not to be used. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841cae2c3d8d3c93ec6d9aa54611f20c3e913"></a>SOL_MEMDESC_TYPE_UINT8</em>&#160;</td><td class="fielddoc">
<p>uint8_t equivalent (one unsigned byte). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::u8. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca01cb1624e4fabe02114fa5db9f03e345"></a>SOL_MEMDESC_TYPE_UINT16</em>&#160;</td><td class="fielddoc">
<p>uint16_t equivalent (two unsigned bytes). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::u16. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca6561c68e389c6cfc4db7dd848811b637"></a>SOL_MEMDESC_TYPE_UINT32</em>&#160;</td><td class="fielddoc">
<p>uint32_t equivalent (four unsigned bytes). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::u32. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca8049e62c1731887c367367849c5d2f1f"></a>SOL_MEMDESC_TYPE_UINT64</em>&#160;</td><td class="fielddoc">
<p>uint64_t equivalent (four unsigned bytes). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::u64. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841cae6f4caf8058e1173a76190e21042d3b9"></a>SOL_MEMDESC_TYPE_ULONG</em>&#160;</td><td class="fielddoc">
<p>unsigned long equivalent. </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::ul. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca02dab4ccfc66e5524390735f92c9c0de"></a>SOL_MEMDESC_TYPE_SIZE</em>&#160;</td><td class="fielddoc">
<p>size_t equivalent (four or eight unsigned bytes, depends on platform). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::sz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca4cb250083cc795901380d17d0085738e"></a>SOL_MEMDESC_TYPE_INT8</em>&#160;</td><td class="fielddoc">
<p>int8_t equivalent (one signed byte). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::i8. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca881abb5136329d48343ea1c575e5ed23"></a>SOL_MEMDESC_TYPE_INT16</em>&#160;</td><td class="fielddoc">
<p>int16_t equivalent (two signed bytes). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::i16. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841caf0154175f40e717fcd34175e241003aa"></a>SOL_MEMDESC_TYPE_INT32</em>&#160;</td><td class="fielddoc">
<p>int32_t equivalent (four signed bytes). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::i32. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca4ec317e7bf1386eb384b4fdd5e090ba4"></a>SOL_MEMDESC_TYPE_INT64</em>&#160;</td><td class="fielddoc">
<p>int64_t equivalent (eight signed bytes). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::i64. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841cac0d8914705ada08d7cfbb5ee0fd630fc"></a>SOL_MEMDESC_TYPE_LONG</em>&#160;</td><td class="fielddoc">
<p>signed long equivalent. </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::l. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca63234dcd358b64ae311f7de5e7b680b6"></a>SOL_MEMDESC_TYPE_SSIZE</em>&#160;</td><td class="fielddoc">
<p>ssize_t equivalent (four or eight signed bytes, depends on platform). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::ssz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca057f63f473f1d5aae2ebaff562cc7dc6"></a>SOL_MEMDESC_TYPE_BOOL</em>&#160;</td><td class="fielddoc">
<p>boolean equivalent. </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::b. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841cab0b3a2427ce1d2595ce57a8feeb72dc6"></a>SOL_MEMDESC_TYPE_DOUBLE</em>&#160;</td><td class="fielddoc">
<p>double precision floating point equivalent. </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::d. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca536154bbc17985de4c78e9c5c690fed1"></a>SOL_MEMDESC_TYPE_STRING</em>&#160;</td><td class="fielddoc">
<p>null-terminated C-string (<code>char*</code>). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::s. It may be null.</p>
<p>By default, strings are duplicated and freed as required. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca82c8ae1f328df6e0ccaa407afdf17ade" title="null-terminated C-string (const char*). ">SOL_MEMDESC_TYPE_CONST_STRING</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca82c8ae1f328df6e0ccaa407afdf17ade"></a>SOL_MEMDESC_TYPE_CONST_STRING</em>&#160;</td><td class="fielddoc">
<p>null-terminated C-string (<code>const</code> char*). </p>
<p>Initial content is specified in struct sol_memdesc::defcontent::s. It may be null.</p>
<p>By default, strings are NOT duplicated neither freed. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca536154bbc17985de4c78e9c5c690fed1" title="null-terminated C-string (char*). ">SOL_MEMDESC_TYPE_STRING</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841cacf54881cd157f17624a92d6b788b58e5"></a>SOL_MEMDESC_TYPE_ENUMERATION</em>&#160;</td><td class="fielddoc">
<p>enumeration </p>
<p>Enumerations assign an integer to some symbol, then we offer a translation table in struct <a class="el" href="structsol__memdesc.html#a92c674c655ee504ed7d3180917b83b48" title="null-terminated array of struct sol_str_table. ">sol_memdesc::enumeration_mapping</a> using struct <a class="el" href="structsol__str__table__int64.html" title="String/int64_t table type. ">sol_str_table_int64</a>. If that is not enough, then provide your own struct sol_memdesc::ops::enumeration::from_str and struct sol_memdesc::ops::enumeration::to_str, these will receive the actual pointer to memory and thus can work with any precision.</p>
<p>Since enumerations don' t have an implicit size, one <b>must</b> define struct <a class="el" href="structsol__memdesc.html#a9ff5e83df5faf7a676edc4c04788f06e" title="size in bytes of the member memory. ">sol_memdesc::size</a>, which is limited to 64-bits (8 bytes).</p>
<p>By default the value is based on struct sol_memdesc::defcontent::e (64-bit signed integer). One can change the behavior by setting a custom struct sol_memdesc::ops::init_defaults. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841cadd6adc5f6c11a1f7195db39671109bb8"></a>SOL_MEMDESC_TYPE_PTR</em>&#160;</td><td class="fielddoc">
<p>generic pointer (void *). </p>
<p>If struct <a class="el" href="structsol__memdesc.html#a31a3f36e91507a732281d63539bc67a5" title="Type of a memory pointer. ">sol_memdesc::pointed_item</a> is non-NULL, it will be managed as such (malloc/free). Note that the initial value is still defined as a pointer to the actual contents in struct sol_memdesc::defcontent::p. If that is non-NULL, then the pointer is allocated and that one will use defaults specified in struct sol_memdesc::pointed_item::defcontent, then values from struct sol_memdesc::defcontent::p is applied on top.</p>
<p>By default the value is based on struct sol_memdesc::defcontent::p.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca2a345b2d1c1b976f12c3b1b178569deb" title="structure with internal members. ">SOL_MEMDESC_TYPE_STRUCTURE</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841ca2a345b2d1c1b976f12c3b1b178569deb"></a>SOL_MEMDESC_TYPE_STRUCTURE</em>&#160;</td><td class="fielddoc">
<p>structure with internal members. </p>
<p>This is a recursive type with children described in struct <a class="el" href="structsol__memdesc.html#a054a9eb6d1ac849182867c622b362a86" title="null-terminated array of structure members. ">sol_memdesc::structure_members</a>, an array that is null-terminated (all element members are zeroed).</p>
<p>During initialization, each member will be considered according to its initial value. Then, if struct sol_memdesc::defcontent::p is non-NULL, it will be applied on top. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c52ec00c38f79c775c72083f1d4841cacffb2c3c105d58ea6d1caf9669fe119e"></a>SOL_MEMDESC_TYPE_ARRAY</em>&#160;</td><td class="fielddoc">
<p>an array with internal members. </p>
<p>This is a pointer to an array of items that are defined in struct <a class="el" href="structsol__memdesc.html#afa64977883720121d784b2b0dc552e62" title="Type of array item. ">sol_memdesc::array_item</a>. It will not be touched, you should manage it yourself with struct <a class="el" href="structsol__memdesc.html#acabb04c96bc690acdf6255079b72eded" title="Override operations to use when operating on the memory. ">sol_memdesc::ops</a>.</p>
<p>To map a struct <a class="el" href="structsol__vector.html" title="Soletta vector is an array that grows dynamically. ">sol_vector</a>, use <code></code>.size=sizeof(struct sol_vector), And provide a <code></code>.array_item with the description on what is to be in the element, like a structure or a pointer to one, this way <a class="el" href="group__MemDesc.html#ga1fda6ffc7674592fe679fa7dd937cdab" title="initialize the memory. ">sol_memdesc_init_defaults()</a> will set struct <a class="el" href="structsol__vector.html#aa9b01f2f0464b6c925f2ff8cd638a89f" title="Size of each element in bytes. ">sol_vector::elem_size</a> to size of array item. Then you must provide the following struct <a class="el" href="structsol__memdesc.html#acabb04c96bc690acdf6255079b72eded" title="Override operations to use when operating on the memory. ">sol_memdesc::ops</a>:</p>
<ul>
<li><code>init_defaults:</code> set <code>elem_size</code> from <code>sol_memdesc_get_size</code>(desc-&gt;array_item). </li>
<li><code>array.get_length:</code> return <code>len</code>. </li>
<li><code>array.get_element:</code> proxy return of <a class="el" href="group__Vector.html#ga1dbde2e4e4c048577f6c5428ef0f5a91" title="Return the element of the vector at the given index. ">sol_vector_get()</a>. </li>
<li><code>array.resize:</code> if shrinking, remember to call <code>sol_memdesc_free_content</code>(desc-&gt;array_item, it) for every item that will be removed, then call <a class="el" href="group__Vector.html#ga649c24fa0cc2b93c6adb71b08dde15a6" title="Remove an range of element from the vector. ">sol_vector_del_range()</a>. If growing, call <a class="el" href="group__Vector.html#gabe2283f5a88920dff1cd611453fa7d6f" title="Append n elements to the end of the vector. ">sol_vector_append_n()</a> and initialze items with <code>sol_memdesc_init_defaults</code>(desc-&gt;array_item, it).</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#ga9aed8e663555d31873a9ff896a0b39ee" title="operations to handle struct sol_vector. ">SOL_MEMDESC_OPS_VECTOR</a> and <a class="el" href="group__MemDesc.html#gaad75bd36de0cc58310c9512ec22d3905" title="operations to handle struct sol_ptr_vector. ">SOL_MEMDESC_OPS_PTR_VECTOR</a>. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga3a1fc6de62663eebd946ee6969cc162f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sol_memdesc_append_array_element </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>array_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr_content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the array element. </p>
<p>This function must be applied to SOL_MEMDESC_TYPE_ARRAY and will call struct sol_memdesc::ops::array::get_element, struct sol_memdesc::ops::array::get_length and struct sol_memdesc::ops::array::resize to resize the array and add one item at the end. Then <a class="el" href="group__MemDesc.html#ga495ada0bb18f030500f7ccc0c0d78cca" title="set the content of this memory. ">sol_memdesc_set_content()</a> is called at the new element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_desc</td><td>the memory description of type SOL_MEMDESC_TYPE_ARRAY. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory holding the array. </td></tr>
    <tr><td class="paramname">ptr_content</td><td>a pointer to the given content, dependent on the type of array_item. If a SOL_MEMDESC_TYPE_BOOL, then it must be a pointer to a bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On error, negative errno is returned. 0 on success</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#ga47e7dfb4e91de0b7a06be3c96f9dd6d1" title="Get the length of an array. ">sol_memdesc_get_array_length()</a> </dd>
<dd>
<a class="el" href="group__MemDesc.html#ga3d77924f51748a4d0385742f5f81c9e3" title="Get the array element. ">sol_memdesc_get_array_element()</a> </dd>
<dd>
<a class="el" href="group__MemDesc.html#ga055d5baf195b172106eab95d5ef64b59" title="Resize the length of an array. ">sol_memdesc_resize_array()</a> </dd>
<dd>
<a class="el" href="group__MemDesc.html#ga495ada0bb18f030500f7ccc0c0d78cca" title="set the content of this memory. ">sol_memdesc_set_content()</a> </dd></dl>

<p>References <a class="el" href="structsol__memdesc.html#afa64977883720121d784b2b0dc552e62">sol_memdesc::array_item</a>, <a class="el" href="group__MemDesc.html#ga3d77924f51748a4d0385742f5f81c9e3">sol_memdesc_get_array_element()</a>, <a class="el" href="group__MemDesc.html#ga47e7dfb4e91de0b7a06be3c96f9dd6d1">sol_memdesc_get_array_length()</a>, <a class="el" href="group__MemDesc.html#ga055d5baf195b172106eab95d5ef64b59">sol_memdesc_resize_array()</a>, and <a class="el" href="group__MemDesc.html#ga495ada0bb18f030500f7ccc0c0d78cca">sol_memdesc_set_content()</a>.</p>

</div>
</div>
<a class="anchor" id="ga96553ae7f8be728172d93aa3506ecaa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_memdesc_compare </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a_memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two memories using the given description. </p>
<p>This function will compare <em>a_memory</em> to <em>b_memory</em> using the given description, with that members that need special treatment will have it, like strings will be strcmp(). Operations may be overriden per-memdesc as defined in struct <a class="el" href="structsol__memdesc.html#acabb04c96bc690acdf6255079b72eded" title="Override operations to use when operating on the memory. ">sol_memdesc::ops</a>.</p>
<dl class="section note"><dt>Note</dt><dd>SOL_MEMDESC_TYPE_PTR can only compare to NULL or same pointer unless struct <a class="el" href="structsol__memdesc.html#a31a3f36e91507a732281d63539bc67a5" title="Type of a memory pointer. ">sol_memdesc::pointed_item</a> is provided, then the value of the pointed item is compared by recursively calling <a class="el" href="group__MemDesc.html#ga96553ae7f8be728172d93aa3506ecaa1" title="compare two memories using the given description. ">sol_memdesc_compare()</a> on the pointed memories. <code>NULL</code> is always considered to be smaller than any value. This behavior can be changed with struct sol_memdesc::ops::compare.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">a_memory</td><td>the first memory to compare. </td></tr>
    <tr><td class="paramname">b_memory</td><td>the second memory to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On error, 0 and errno is set to non-zero. On success (errno == 0), 0 means equal, &lt;0 means a_memory is smaller, &gt;0 means b_memory is smaller. </dd></dl>

</div>
</div>
<a class="anchor" id="gadbb60f862950fedb3b479bc3cb5cf18f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_memdesc_copy </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src_memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy the memory using the given description. </p>
<p>This function will copy <em>src_memory</em> to <em>dst_memory</em> using the given description, with that members that need special treatment will have it, like strings will be duplicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">src_memory</td><td>the source/origin memory. </td></tr>
    <tr><td class="paramname">dst_memory</td><td>the destination/target memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#ga495ada0bb18f030500f7ccc0c0d78cca" title="set the content of this memory. ">sol_memdesc_set_content()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadcac5a1696e9471c850b801eb3ee560f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_memdesc_enumeration_from_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>enumeration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr_return</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert enumeration value from string. </p>
<p>The return is stored in <code>ptr_return</code>, which must be the size stated in struct <a class="el" href="structsol__memdesc.html#a9ff5e83df5faf7a676edc4c04788f06e" title="size in bytes of the member memory. ">sol_memdesc::size</a> as returned by <a class="el" href="group__MemDesc.html#ga8008efeff8fcf62a94609e9e2d86a493" title="get the size in bytes of the memory description. ">sol_memdesc_get_size()</a>.</p>
<p>The string is given in the form of a slice so it doesn't need to be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumeration</td><td>the memory description of the enumeration of type SOL_MEMDESC_TYPE_ENUMERATION. </td></tr>
    <tr><td class="paramname">str</td><td>the slice with the string to convert, doesn't need to be null-terminated. </td></tr>
    <tr><td class="paramname">ptr_return</td><td>where to store the converted value. Must be a pointer to a memory of size <a class="el" href="group__MemDesc.html#ga8008efeff8fcf62a94609e9e2d86a493" title="get the size in bytes of the memory description. ">sol_memdesc_get_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On error, negative errno is returned. 0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd14ae0831a2d3e2813018c3ab84fcc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sol_memdesc_enumeration_to_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>enumeration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert enumeration value to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumeration</td><td>the memory description of the enumeration of type SOL_MEMDESC_TYPE_ENUMERATION. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory of the enumeration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On error, NULL should be returned and errno set. On success non-NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga976bbe363ddef0f9aab260035d1ad75b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const struct <a class="el" href="structsol__memdesc__structure__member.html">sol_memdesc_structure_member</a>* sol_memdesc_find_structure_member </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>structure_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__str__slice.html">sol_str_slice</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find structure member given its name. </p>
<p>The name is taken as a slice since sometimes it's not available as a null-terminated strings (such as loading from other protocols such as JSON).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure_desc</td><td>a description of type SOL_MEMDESC_TYPE_STRUCTURE. </td></tr>
    <tr><td class="paramname">name</td><td>the name to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer on success or NULL on errors (with errno set).</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Str__Slice.html#ga403d23f24219db595e892573d3384c37" title="Populates a slice from a string. ">sol_str_slice_from_str()</a> </dd>
<dd>
<a class="el" href="group__Str__Slice.html#ga5408488d546a6b48a17852eda5e14263" title="Helper macro to make easier to declare a string slice from a string. ">SOL_STR_SLICE_STR()</a> </dd>
<dd>
<a class="el" href="group__Str__Slice.html#ga286e4d6331e05cd18747d0d7deb06984" title="Helper macro to make easier to declare a string slice from a string literal. ">SOL_STR_SLICE_LITERAL()</a> </dd></dl>

<p>References <a class="el" href="structsol__str__slice.html#a9b9f38d8d946af896daf76fab04473b7">sol_str_slice::len</a>, <a class="el" href="structsol__memdesc__structure__member.html#a880f60a943172b17e7a113b49bd15062">sol_memdesc_structure_member::name</a>, <a class="el" href="group__MemDesc.html#ga77caa7c74a7f7652cc117d0d73cc9fbb">SOL_MEMDESC_FOREACH_STRUCTURE_MEMBER</a>, and <a class="el" href="group__Str__Slice.html#ga80d120c6bf5edb6ded99ecfa5700afb2">sol_str_slice_str_eq()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b6013b38a9de317b68e62c23202afc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sol_memdesc_free </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the contents and the memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory to free the contents and the memory itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#gae6ee226f0aefb0ce1fd66db934eb25bc" title="free the contents (internal memory) of a member. ">sol_memdesc_free_content()</a> </dd></dl>

<p>References <a class="el" href="group__MemDesc.html#gae6ee226f0aefb0ce1fd66db934eb25bc">sol_memdesc_free_content()</a>.</p>

<p>Referenced by <a class="el" href="group__MemDesc.html#gabab7495cb1b24521cc73b2062a0cd5b1">sol_memdesc_new_with_defaults()</a>.</p>

</div>
</div>
<a class="anchor" id="gae6ee226f0aefb0ce1fd66db934eb25bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_memdesc_free_content </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free the contents (internal memory) of a member. </p>
<p>This function will take care of special handling needed for each member, like strings that must be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory to free the internal contents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#ga3b6013b38a9de317b68e62c23202afc1" title="Free the contents and the memory. ">sol_memdesc_free()</a> </dd></dl>

<p>Referenced by <a class="el" href="group__MemDesc.html#ga3b6013b38a9de317b68e62c23202afc1">sol_memdesc_free()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3d77924f51748a4d0385742f5f81c9e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sol_memdesc_get_array_element </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>array_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the array element. </p>
<p>This function must be applied to SOL_MEMDESC_TYPE_ARRAY and will call struct sol_memdesc::ops::array::get_element.</p>
<dl class="section note"><dt>Note</dt><dd>for speed purposes, this function will not guarantee out-of-bounds checking, please ensure the index is less than <a class="el" href="group__MemDesc.html#ga47e7dfb4e91de0b7a06be3c96f9dd6d1" title="Get the length of an array. ">sol_memdesc_get_array_length()</a> before calling it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_desc</td><td>the memory description of type SOL_MEMDESC_TYPE_ARRAY. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory holding the array. </td></tr>
    <tr><td class="paramname">idx</td><td>the index of the element inside the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On error NULL is returned and errno is set. On success the memory of the item is returned.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#ga47e7dfb4e91de0b7a06be3c96f9dd6d1" title="Get the length of an array. ">sol_memdesc_get_array_length()</a> </dd></dl>

<p>Referenced by <a class="el" href="group__MemDesc.html#ga3a1fc6de62663eebd946ee6969cc162f">sol_memdesc_append_array_element()</a>.</p>

</div>
</div>
<a class="anchor" id="ga47e7dfb4e91de0b7a06be3c96f9dd6d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sol_memdesc_get_array_length </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>array_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of an array. </p>
<p>This function must be applied to SOL_MEMDESC_TYPE_ARRAY and will call struct sol_memdesc::ops::array::get_length.</p>
<p>The returned value is about the number of items according to struct <a class="el" href="structsol__memdesc.html#afa64977883720121d784b2b0dc552e62" title="Type of array item. ">sol_memdesc::array_item</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_desc</td><td>the memory description of type SOL_MEMDESC_TYPE_ARRAY. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory holding the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On error, negative errno is returned. Zero or more for success. </dd></dl>

<p>Referenced by <a class="el" href="group__MemDesc.html#ga3a1fc6de62663eebd946ee6969cc162f">sol_memdesc_append_array_element()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf480d2a64c26eb518f3cf15f7268c5ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t sol_memdesc_get_as_int64 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to fetch the memory as the largest supported signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory to get content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number as int64_t. On errors, errno is set to non-zero.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#ga17e4ce689ed0c9f83771a5430a1e8c4a" title="Helper to check if type is signed integer-compatible. ">sol_memdesc_is_signed_integer()</a>. </dd></dl>

<p>References <a class="el" href="structsol__memdesc.html#a31f4956897b405f3f4f6a487a1962055">sol_memdesc::api_version</a>, <a class="el" href="structsol__memdesc.html#a76e268c142cb3a91a769ece1a41e604e">sol_memdesc::defcontent</a>, <a class="el" href="structsol__memdesc.html#a98b1eca762ba6ded7f1afcc4d8cc23e2">sol_memdesc::e</a>, <a class="el" href="structsol__memdesc__structure__member.html#a0759699bdfeb2c29e77f21e2c6fff706">sol_memdesc_structure_member::offset</a>, <a class="el" href="structsol__memdesc.html#a9ff5e83df5faf7a676edc4c04788f06e">sol_memdesc::size</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacffb2c3c105d58ea6d1caf9669fe119e">SOL_MEMDESC_TYPE_ARRAY</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca057f63f473f1d5aae2ebaff562cc7dc6">SOL_MEMDESC_TYPE_BOOL</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca82c8ae1f328df6e0ccaa407afdf17ade">SOL_MEMDESC_TYPE_CONST_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cab0b3a2427ce1d2595ce57a8feeb72dc6">SOL_MEMDESC_TYPE_DOUBLE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacf54881cd157f17624a92d6b788b58e5">SOL_MEMDESC_TYPE_ENUMERATION</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca881abb5136329d48343ea1c575e5ed23">SOL_MEMDESC_TYPE_INT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841caf0154175f40e717fcd34175e241003aa">SOL_MEMDESC_TYPE_INT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4ec317e7bf1386eb384b4fdd5e090ba4">SOL_MEMDESC_TYPE_INT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4cb250083cc795901380d17d0085738e">SOL_MEMDESC_TYPE_INT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac0d8914705ada08d7cfbb5ee0fd630fc">SOL_MEMDESC_TYPE_LONG</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cadd6adc5f6c11a1f7195db39671109bb8">SOL_MEMDESC_TYPE_PTR</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca02dab4ccfc66e5524390735f92c9c0de">SOL_MEMDESC_TYPE_SIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca63234dcd358b64ae311f7de5e7b680b6">SOL_MEMDESC_TYPE_SSIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca536154bbc17985de4c78e9c5c690fed1">SOL_MEMDESC_TYPE_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca2a345b2d1c1b976f12c3b1b178569deb">SOL_MEMDESC_TYPE_STRUCTURE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca01cb1624e4fabe02114fa5db9f03e345">SOL_MEMDESC_TYPE_UINT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca6561c68e389c6cfc4db7dd848811b637">SOL_MEMDESC_TYPE_UINT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca8049e62c1731887c367367849c5d2f1f">SOL_MEMDESC_TYPE_UINT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae2c3d8d3c93ec6d9aa54611f20c3e913">SOL_MEMDESC_TYPE_UINT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae6f4caf8058e1173a76190e21042d3b9">SOL_MEMDESC_TYPE_ULONG</a>, and <a class="el" href="structsol__memdesc.html#ae65472aa93393f50c84de6c43cf20d5b">sol_memdesc::type</a>.</p>

</div>
</div>
<a class="anchor" id="ga89cefa454f6b3f918f283144ef6cc679"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sol_memdesc_get_as_uint64 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to fetch the memory as the largest supported unsigned integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory to get content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number as uint64_t. On errors, errno is set to non-zero.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#ga0289ab11bdcd684ab575d2e50d42a453" title="Helper to check if type is unsigned integer-compatible. ">sol_memdesc_is_unsigned_integer()</a>. </dd></dl>

<p>References <a class="el" href="structsol__memdesc.html#a31f4956897b405f3f4f6a487a1962055">sol_memdesc::api_version</a>, <a class="el" href="structsol__memdesc.html#a76e268c142cb3a91a769ece1a41e604e">sol_memdesc::defcontent</a>, <a class="el" href="structsol__memdesc.html#a98b1eca762ba6ded7f1afcc4d8cc23e2">sol_memdesc::e</a>, <a class="el" href="structsol__memdesc__structure__member.html#a0759699bdfeb2c29e77f21e2c6fff706">sol_memdesc_structure_member::offset</a>, <a class="el" href="structsol__memdesc.html#a9ff5e83df5faf7a676edc4c04788f06e">sol_memdesc::size</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacffb2c3c105d58ea6d1caf9669fe119e">SOL_MEMDESC_TYPE_ARRAY</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca057f63f473f1d5aae2ebaff562cc7dc6">SOL_MEMDESC_TYPE_BOOL</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca82c8ae1f328df6e0ccaa407afdf17ade">SOL_MEMDESC_TYPE_CONST_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cab0b3a2427ce1d2595ce57a8feeb72dc6">SOL_MEMDESC_TYPE_DOUBLE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacf54881cd157f17624a92d6b788b58e5">SOL_MEMDESC_TYPE_ENUMERATION</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca881abb5136329d48343ea1c575e5ed23">SOL_MEMDESC_TYPE_INT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841caf0154175f40e717fcd34175e241003aa">SOL_MEMDESC_TYPE_INT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4ec317e7bf1386eb384b4fdd5e090ba4">SOL_MEMDESC_TYPE_INT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4cb250083cc795901380d17d0085738e">SOL_MEMDESC_TYPE_INT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac0d8914705ada08d7cfbb5ee0fd630fc">SOL_MEMDESC_TYPE_LONG</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cadd6adc5f6c11a1f7195db39671109bb8">SOL_MEMDESC_TYPE_PTR</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca02dab4ccfc66e5524390735f92c9c0de">SOL_MEMDESC_TYPE_SIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca63234dcd358b64ae311f7de5e7b680b6">SOL_MEMDESC_TYPE_SSIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca536154bbc17985de4c78e9c5c690fed1">SOL_MEMDESC_TYPE_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca2a345b2d1c1b976f12c3b1b178569deb">SOL_MEMDESC_TYPE_STRUCTURE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca01cb1624e4fabe02114fa5db9f03e345">SOL_MEMDESC_TYPE_UINT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca6561c68e389c6cfc4db7dd848811b637">SOL_MEMDESC_TYPE_UINT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca8049e62c1731887c367367849c5d2f1f">SOL_MEMDESC_TYPE_UINT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae2c3d8d3c93ec6d9aa54611f20c3e913">SOL_MEMDESC_TYPE_UINT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae6f4caf8058e1173a76190e21042d3b9">SOL_MEMDESC_TYPE_ULONG</a>, and <a class="el" href="structsol__memdesc.html#ae65472aa93393f50c84de6c43cf20d5b">sol_memdesc::type</a>.</p>

</div>
</div>
<a class="anchor" id="ga8008efeff8fcf62a94609e9e2d86a493"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t sol_memdesc_get_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the size in bytes of the memory description. </p>
<p>This will use the intrinsic size of each type and for SOL_MEMDESC_TYPE_STRUCTURE and SOL_MEMDESC_TYPE_ARRAY it will use the explicit one at struct <a class="el" href="structsol__memdesc.html#a9ff5e83df5faf7a676edc4c04788f06e" title="size in bytes of the member memory. ">sol_memdesc::size</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on errors (and errno is set to EINVAL) or the size in bytes. </dd></dl>

<p>References <a class="el" href="structsol__memdesc.html#a31f4956897b405f3f4f6a487a1962055">sol_memdesc::api_version</a>, <a class="el" href="structsol__memdesc.html#a9ff5e83df5faf7a676edc4c04788f06e">sol_memdesc::size</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacffb2c3c105d58ea6d1caf9669fe119e">SOL_MEMDESC_TYPE_ARRAY</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca057f63f473f1d5aae2ebaff562cc7dc6">SOL_MEMDESC_TYPE_BOOL</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca82c8ae1f328df6e0ccaa407afdf17ade">SOL_MEMDESC_TYPE_CONST_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cab0b3a2427ce1d2595ce57a8feeb72dc6">SOL_MEMDESC_TYPE_DOUBLE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacf54881cd157f17624a92d6b788b58e5">SOL_MEMDESC_TYPE_ENUMERATION</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca881abb5136329d48343ea1c575e5ed23">SOL_MEMDESC_TYPE_INT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841caf0154175f40e717fcd34175e241003aa">SOL_MEMDESC_TYPE_INT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4ec317e7bf1386eb384b4fdd5e090ba4">SOL_MEMDESC_TYPE_INT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4cb250083cc795901380d17d0085738e">SOL_MEMDESC_TYPE_INT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac0d8914705ada08d7cfbb5ee0fd630fc">SOL_MEMDESC_TYPE_LONG</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cadd6adc5f6c11a1f7195db39671109bb8">SOL_MEMDESC_TYPE_PTR</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca02dab4ccfc66e5524390735f92c9c0de">SOL_MEMDESC_TYPE_SIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca63234dcd358b64ae311f7de5e7b680b6">SOL_MEMDESC_TYPE_SSIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca536154bbc17985de4c78e9c5c690fed1">SOL_MEMDESC_TYPE_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca2a345b2d1c1b976f12c3b1b178569deb">SOL_MEMDESC_TYPE_STRUCTURE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca01cb1624e4fabe02114fa5db9f03e345">SOL_MEMDESC_TYPE_UINT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca6561c68e389c6cfc4db7dd848811b637">SOL_MEMDESC_TYPE_UINT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca8049e62c1731887c367367849c5d2f1f">SOL_MEMDESC_TYPE_UINT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae2c3d8d3c93ec6d9aa54611f20c3e913">SOL_MEMDESC_TYPE_UINT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae6f4caf8058e1173a76190e21042d3b9">SOL_MEMDESC_TYPE_ULONG</a>, and <a class="el" href="structsol__memdesc.html#ae65472aa93393f50c84de6c43cf20d5b">sol_memdesc::type</a>.</p>

<p>Referenced by <a class="el" href="group__MemDesc.html#gade28d2eccec2ec988f66ff69b53db2f6">sol_memdesc_get_structure_member_memory()</a>, and <a class="el" href="group__MemDesc.html#gabab7495cb1b24521cc73b2062a0cd5b1">sol_memdesc_new_with_defaults()</a>.</p>

</div>
</div>
<a class="anchor" id="gade28d2eccec2ec988f66ff69b53db2f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sol_memdesc_get_structure_member_memory </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>structure_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc__structure__member.html">sol_memdesc_structure_member</a> *&#160;</td>
          <td class="paramname"><em>member_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>structure_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the pointer to the struct member memory description inside the given container. </p>
<p>This will use the struct sol_memdesc::offset to find the offset inside the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure_desc</td><td>the memory description of the structure. </td></tr>
    <tr><td class="paramname">member_desc</td><td>the memory description of the structure member. </td></tr>
    <tr><td class="paramname">structure_memory</td><td>the memory of the container (the pointer to the start of the structure that holds the member).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> on errors or the pointer inside <em>structure_memory</em> on success. </dd></dl>

<p>References <a class="el" href="structsol__memdesc.html#a31f4956897b405f3f4f6a487a1962055">sol_memdesc::api_version</a>, <a class="el" href="structsol__memdesc__structure__member.html#a74c133273d2a923b0eeb0589a47d29d1">sol_memdesc_structure_member::base</a>, <a class="el" href="structsol__memdesc__structure__member.html#a0759699bdfeb2c29e77f21e2c6fff706">sol_memdesc_structure_member::offset</a>, and <a class="el" href="group__MemDesc.html#ga8008efeff8fcf62a94609e9e2d86a493">sol_memdesc_get_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1fda6ffc7674592fe679fa7dd937cdab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_memdesc_init_defaults </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize the memory. </p>
<p>This will use the default content specified in struct <a class="el" href="structsol__memdesc.html#a76e268c142cb3a91a769ece1a41e604e" title="default contents to be used if required == false. ">sol_memdesc::defcontent</a> according to the type spefified in struct <a class="el" href="structsol__memdesc.html#ae65472aa93393f50c84de6c43cf20d5b" title="basic type of the member memory. ">sol_memdesc::type</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#gabab7495cb1b24521cc73b2062a0cd5b1" title="Allocate the memory required by this description and initialize it. ">sol_memdesc_new_with_defaults()</a> </dd></dl>

<p>Referenced by <a class="el" href="group__MemDesc.html#gabab7495cb1b24521cc73b2062a0cd5b1">sol_memdesc_new_with_defaults()</a>.</p>

</div>
</div>
<a class="anchor" id="ga17e4ce689ed0c9f83771a5430a1e8c4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sol_memdesc_is_signed_integer </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to check if type is signed integer-compatible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is signed integer (int8_t, int16_t, int32_t, int64_t, long, ssize_t or enumeration). </dd></dl>

<p>References <a class="el" href="structsol__memdesc.html#a31f4956897b405f3f4f6a487a1962055">sol_memdesc::api_version</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacffb2c3c105d58ea6d1caf9669fe119e">SOL_MEMDESC_TYPE_ARRAY</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca057f63f473f1d5aae2ebaff562cc7dc6">SOL_MEMDESC_TYPE_BOOL</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca82c8ae1f328df6e0ccaa407afdf17ade">SOL_MEMDESC_TYPE_CONST_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cab0b3a2427ce1d2595ce57a8feeb72dc6">SOL_MEMDESC_TYPE_DOUBLE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacf54881cd157f17624a92d6b788b58e5">SOL_MEMDESC_TYPE_ENUMERATION</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca881abb5136329d48343ea1c575e5ed23">SOL_MEMDESC_TYPE_INT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841caf0154175f40e717fcd34175e241003aa">SOL_MEMDESC_TYPE_INT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4ec317e7bf1386eb384b4fdd5e090ba4">SOL_MEMDESC_TYPE_INT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4cb250083cc795901380d17d0085738e">SOL_MEMDESC_TYPE_INT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac0d8914705ada08d7cfbb5ee0fd630fc">SOL_MEMDESC_TYPE_LONG</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cadd6adc5f6c11a1f7195db39671109bb8">SOL_MEMDESC_TYPE_PTR</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca02dab4ccfc66e5524390735f92c9c0de">SOL_MEMDESC_TYPE_SIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca63234dcd358b64ae311f7de5e7b680b6">SOL_MEMDESC_TYPE_SSIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca536154bbc17985de4c78e9c5c690fed1">SOL_MEMDESC_TYPE_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca2a345b2d1c1b976f12c3b1b178569deb">SOL_MEMDESC_TYPE_STRUCTURE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca01cb1624e4fabe02114fa5db9f03e345">SOL_MEMDESC_TYPE_UINT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca6561c68e389c6cfc4db7dd848811b637">SOL_MEMDESC_TYPE_UINT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca8049e62c1731887c367367849c5d2f1f">SOL_MEMDESC_TYPE_UINT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae2c3d8d3c93ec6d9aa54611f20c3e913">SOL_MEMDESC_TYPE_UINT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae6f4caf8058e1173a76190e21042d3b9">SOL_MEMDESC_TYPE_ULONG</a>, and <a class="el" href="structsol__memdesc.html#ae65472aa93393f50c84de6c43cf20d5b">sol_memdesc::type</a>.</p>

</div>
</div>
<a class="anchor" id="ga0289ab11bdcd684ab575d2e50d42a453"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sol_memdesc_is_unsigned_integer </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to check if type is unsigned integer-compatible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is unsigned integer (uint8_t, uint16_t, uint32_t, uint64_t, unsigned long or size_t). </dd></dl>

<p>References <a class="el" href="structsol__memdesc.html#a31f4956897b405f3f4f6a487a1962055">sol_memdesc::api_version</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacffb2c3c105d58ea6d1caf9669fe119e">SOL_MEMDESC_TYPE_ARRAY</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca057f63f473f1d5aae2ebaff562cc7dc6">SOL_MEMDESC_TYPE_BOOL</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca82c8ae1f328df6e0ccaa407afdf17ade">SOL_MEMDESC_TYPE_CONST_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cab0b3a2427ce1d2595ce57a8feeb72dc6">SOL_MEMDESC_TYPE_DOUBLE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacf54881cd157f17624a92d6b788b58e5">SOL_MEMDESC_TYPE_ENUMERATION</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca881abb5136329d48343ea1c575e5ed23">SOL_MEMDESC_TYPE_INT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841caf0154175f40e717fcd34175e241003aa">SOL_MEMDESC_TYPE_INT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4ec317e7bf1386eb384b4fdd5e090ba4">SOL_MEMDESC_TYPE_INT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4cb250083cc795901380d17d0085738e">SOL_MEMDESC_TYPE_INT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac0d8914705ada08d7cfbb5ee0fd630fc">SOL_MEMDESC_TYPE_LONG</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cadd6adc5f6c11a1f7195db39671109bb8">SOL_MEMDESC_TYPE_PTR</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca02dab4ccfc66e5524390735f92c9c0de">SOL_MEMDESC_TYPE_SIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca63234dcd358b64ae311f7de5e7b680b6">SOL_MEMDESC_TYPE_SSIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca536154bbc17985de4c78e9c5c690fed1">SOL_MEMDESC_TYPE_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca2a345b2d1c1b976f12c3b1b178569deb">SOL_MEMDESC_TYPE_STRUCTURE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca01cb1624e4fabe02114fa5db9f03e345">SOL_MEMDESC_TYPE_UINT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca6561c68e389c6cfc4db7dd848811b637">SOL_MEMDESC_TYPE_UINT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca8049e62c1731887c367367849c5d2f1f">SOL_MEMDESC_TYPE_UINT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae2c3d8d3c93ec6d9aa54611f20c3e913">SOL_MEMDESC_TYPE_UINT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae6f4caf8058e1173a76190e21042d3b9">SOL_MEMDESC_TYPE_ULONG</a>, and <a class="el" href="structsol__memdesc.html#ae65472aa93393f50c84de6c43cf20d5b">sol_memdesc::type</a>.</p>

</div>
</div>
<a class="anchor" id="gabab7495cb1b24521cc73b2062a0cd5b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* sol_memdesc_new_with_defaults </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate the memory required by this description and initialize it. </p>
<p>This will allocate offset + size bytes, then fill these bytes with the content defined in struct <a class="el" href="structsol__memdesc.html#a76e268c142cb3a91a769ece1a41e604e" title="default contents to be used if required == false. ">sol_memdesc::defcontent</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error, newly allocated memory on success. Free using <a class="el" href="group__MemDesc.html#ga3b6013b38a9de317b68e62c23202afc1" title="Free the contents and the memory. ">sol_memdesc_free()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MemDesc.html#ga3b6013b38a9de317b68e62c23202afc1" title="Free the contents and the memory. ">sol_memdesc_free()</a> </dd></dl>

<p>References <a class="el" href="group__MemDesc.html#ga3b6013b38a9de317b68e62c23202afc1">sol_memdesc_free()</a>, <a class="el" href="group__MemDesc.html#ga8008efeff8fcf62a94609e9e2d86a493">sol_memdesc_get_size()</a>, and <a class="el" href="group__MemDesc.html#ga1fda6ffc7674592fe679fa7dd937cdab">sol_memdesc_init_defaults()</a>.</p>

</div>
</div>
<a class="anchor" id="ga055d5baf195b172106eab95d5ef64b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_memdesc_resize_array </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>array_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the length of an array. </p>
<p>This function must be applied to SOL_MEMDESC_TYPE_ARRAY and will call struct sol_memdesc::ops::array::resize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_desc</td><td>the memory description of type SOL_MEMDESC_TYPE_ARRAY. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory holding the array. </td></tr>
    <tr><td class="paramname">length</td><td>the new length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On error, negative errno is returned. 0 on success. </dd></dl>

<p>Referenced by <a class="el" href="group__MemDesc.html#ga3a1fc6de62663eebd946ee6969cc162f">sol_memdesc_append_array_element()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5678851794d61f8051c837466a43ffdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_memdesc_serialize </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc__serialize__options.html">sol_memdesc_serialize_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsol__buffer.html">sol_buffer</a> *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a memory to a buffer using a description. </p>
<p>If no options are provided, then it will serialize in a C-like pattern, however if struct member names are not valid C symbols, it will not be a valid C.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory to serialize. </td></tr>
    <tr><td class="paramname">buffer</td><td>where to serialize the memory. Must be pre-initialized, contents will be appended. </td></tr>
    <tr><td class="paramname">opts</td><td>if provided will modify how to serialize the memory. </td></tr>
    <tr><td class="paramname">prefix</td><td>some prefix to be added to lines, it will be modified during iteration to contain new indent strings. May be null so a local buffer is automatically created and destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gab759fad327ab0bb4f045b609c3a61c92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t sol_memdesc_set_as_int64 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to set the memory as the largest supported signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory to set content. </td></tr>
    <tr><td class="paramname">value</td><td>the number as int64_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on errors.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>sol_memdesc_is_signed(). </dd></dl>

<p>References <a class="el" href="structsol__memdesc.html#a31f4956897b405f3f4f6a487a1962055">sol_memdesc::api_version</a>, <a class="el" href="structsol__memdesc.html#a76e268c142cb3a91a769ece1a41e604e">sol_memdesc::defcontent</a>, <a class="el" href="structsol__memdesc.html#a98b1eca762ba6ded7f1afcc4d8cc23e2">sol_memdesc::e</a>, <a class="el" href="structsol__memdesc__structure__member.html#a0759699bdfeb2c29e77f21e2c6fff706">sol_memdesc_structure_member::offset</a>, <a class="el" href="structsol__memdesc.html#a9ff5e83df5faf7a676edc4c04788f06e">sol_memdesc::size</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacffb2c3c105d58ea6d1caf9669fe119e">SOL_MEMDESC_TYPE_ARRAY</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca057f63f473f1d5aae2ebaff562cc7dc6">SOL_MEMDESC_TYPE_BOOL</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca82c8ae1f328df6e0ccaa407afdf17ade">SOL_MEMDESC_TYPE_CONST_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cab0b3a2427ce1d2595ce57a8feeb72dc6">SOL_MEMDESC_TYPE_DOUBLE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacf54881cd157f17624a92d6b788b58e5">SOL_MEMDESC_TYPE_ENUMERATION</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca881abb5136329d48343ea1c575e5ed23">SOL_MEMDESC_TYPE_INT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841caf0154175f40e717fcd34175e241003aa">SOL_MEMDESC_TYPE_INT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4ec317e7bf1386eb384b4fdd5e090ba4">SOL_MEMDESC_TYPE_INT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4cb250083cc795901380d17d0085738e">SOL_MEMDESC_TYPE_INT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac0d8914705ada08d7cfbb5ee0fd630fc">SOL_MEMDESC_TYPE_LONG</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cadd6adc5f6c11a1f7195db39671109bb8">SOL_MEMDESC_TYPE_PTR</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca02dab4ccfc66e5524390735f92c9c0de">SOL_MEMDESC_TYPE_SIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca63234dcd358b64ae311f7de5e7b680b6">SOL_MEMDESC_TYPE_SSIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca536154bbc17985de4c78e9c5c690fed1">SOL_MEMDESC_TYPE_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca2a345b2d1c1b976f12c3b1b178569deb">SOL_MEMDESC_TYPE_STRUCTURE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca01cb1624e4fabe02114fa5db9f03e345">SOL_MEMDESC_TYPE_UINT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca6561c68e389c6cfc4db7dd848811b637">SOL_MEMDESC_TYPE_UINT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca8049e62c1731887c367367849c5d2f1f">SOL_MEMDESC_TYPE_UINT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae2c3d8d3c93ec6d9aa54611f20c3e913">SOL_MEMDESC_TYPE_UINT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae6f4caf8058e1173a76190e21042d3b9">SOL_MEMDESC_TYPE_ULONG</a>, <a class="el" href="group__Type__Checking.html#ga2d6569aa794c2f23e90691e60d2f3ad2">SSIZE_MAX</a>, and <a class="el" href="structsol__memdesc.html#ae65472aa93393f50c84de6c43cf20d5b">sol_memdesc::type</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a6fdc09984d50cb4341eb48bd8749aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sol_memdesc_set_as_uint64 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to set the memory as the largest supported unsigned integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory to set content. </td></tr>
    <tr><td class="paramname">value</td><td>the number as uint64_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on errors.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>sol_memdesc_is_unsigned(). </dd></dl>

<p>References <a class="el" href="structsol__memdesc.html#a31f4956897b405f3f4f6a487a1962055">sol_memdesc::api_version</a>, <a class="el" href="structsol__memdesc.html#a76e268c142cb3a91a769ece1a41e604e">sol_memdesc::defcontent</a>, <a class="el" href="structsol__memdesc.html#a98b1eca762ba6ded7f1afcc4d8cc23e2">sol_memdesc::e</a>, <a class="el" href="structsol__memdesc__structure__member.html#a0759699bdfeb2c29e77f21e2c6fff706">sol_memdesc_structure_member::offset</a>, <a class="el" href="structsol__memdesc.html#a9ff5e83df5faf7a676edc4c04788f06e">sol_memdesc::size</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacffb2c3c105d58ea6d1caf9669fe119e">SOL_MEMDESC_TYPE_ARRAY</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca057f63f473f1d5aae2ebaff562cc7dc6">SOL_MEMDESC_TYPE_BOOL</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca82c8ae1f328df6e0ccaa407afdf17ade">SOL_MEMDESC_TYPE_CONST_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cab0b3a2427ce1d2595ce57a8feeb72dc6">SOL_MEMDESC_TYPE_DOUBLE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cacf54881cd157f17624a92d6b788b58e5">SOL_MEMDESC_TYPE_ENUMERATION</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca881abb5136329d48343ea1c575e5ed23">SOL_MEMDESC_TYPE_INT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841caf0154175f40e717fcd34175e241003aa">SOL_MEMDESC_TYPE_INT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4ec317e7bf1386eb384b4fdd5e090ba4">SOL_MEMDESC_TYPE_INT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca4cb250083cc795901380d17d0085738e">SOL_MEMDESC_TYPE_INT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cac0d8914705ada08d7cfbb5ee0fd630fc">SOL_MEMDESC_TYPE_LONG</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cadd6adc5f6c11a1f7195db39671109bb8">SOL_MEMDESC_TYPE_PTR</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca02dab4ccfc66e5524390735f92c9c0de">SOL_MEMDESC_TYPE_SIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca63234dcd358b64ae311f7de5e7b680b6">SOL_MEMDESC_TYPE_SSIZE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca536154bbc17985de4c78e9c5c690fed1">SOL_MEMDESC_TYPE_STRING</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca2a345b2d1c1b976f12c3b1b178569deb">SOL_MEMDESC_TYPE_STRUCTURE</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca01cb1624e4fabe02114fa5db9f03e345">SOL_MEMDESC_TYPE_UINT16</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca6561c68e389c6cfc4db7dd848811b637">SOL_MEMDESC_TYPE_UINT32</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841ca8049e62c1731887c367367849c5d2f1f">SOL_MEMDESC_TYPE_UINT64</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae2c3d8d3c93ec6d9aa54611f20c3e913">SOL_MEMDESC_TYPE_UINT8</a>, <a class="el" href="group__MemDesc.html#gga3c52ec00c38f79c775c72083f1d4841cae6f4caf8058e1173a76190e21042d3b9">SOL_MEMDESC_TYPE_ULONG</a>, <a class="el" href="group__Type__Checking.html#ga2d6569aa794c2f23e90691e60d2f3ad2">SSIZE_MAX</a>, and <a class="el" href="structsol__memdesc.html#ae65472aa93393f50c84de6c43cf20d5b">sol_memdesc::type</a>.</p>

</div>
</div>
<a class="anchor" id="ga495ada0bb18f030500f7ccc0c0d78cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sol_memdesc_set_content </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsol__memdesc.html">sol_memdesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr_content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the content of this memory. </p>
<p>This function take care to set the content, disposing of the previous content if any and duplicating the new one as required, like for strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the memory description. </td></tr>
    <tr><td class="paramname">memory</td><td>the memory to set content. </td></tr>
    <tr><td class="paramname">ptr_content</td><td>a pointer to the given content, dependent on the type. If a SOL_MEMDESC_TYPE_BOOL, then it must be a pointer to a bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

<p>Referenced by <a class="el" href="group__MemDesc.html#ga3a1fc6de62663eebd946ee6969cc162f">sol_memdesc_append_array_element()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2404df0ccb9c89e2f0f4684d3283ce0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MemDesc.html#ga3c52ec00c38f79c775c72083f1d4841c">sol_memdesc_type</a> sol_memdesc_type_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Memdesc Type from string to sol_memdesc_type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string representing a valid type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type or SOL_MEMDESC_TYPE_UNKNOWN if invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="gae9b2337a7cda7733582f3aa8c7540792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sol_memdesc_type_to_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__MemDesc.html#ga3c52ec00c38f79c775c72083f1d4841c">sol_memdesc_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a sol_memdesc_type to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string or NULL, if the type is invalid. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga20a25d21b3f9a0a8294e8ffba179f5f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t SOL_MEMDESC_API_VERSION_COMPILED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the SOL_MEMDESC_API_VERSION this soletta build used. </p>
<p>This symbol is defined by soletta to match SOL_MEMDESC_API_VERSION, but unlike that macro this symbol will be relative to soletta build and is used in our macros and static-inline functions that must check for valid handles. </p>

</div>
</div>
<a class="anchor" id="gaad75bd36de0cc58310c9512ec22d3905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structsol__memdesc__ops.html">sol_memdesc_ops</a> SOL_MEMDESC_OPS_PTR_VECTOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operations to handle struct <a class="el" href="structsol__ptr__vector.html" title="Soletta pointer vector is a wrapper around vector with an API more convenient to handle pointers...">sol_ptr_vector</a>. </p>
<p>If one wants to use SOL_MEMDESC_TYPE_ARRAY with a struct <a class="el" href="structsol__ptr__vector.html" title="Soletta pointer vector is a wrapper around vector with an API more convenient to handle pointers...">sol_ptr_vector</a>, then use this operations to initialize, get length, get element and resize the array. </p>

</div>
</div>
<a class="anchor" id="ga9aed8e663555d31873a9ff896a0b39ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structsol__memdesc__ops.html">sol_memdesc_ops</a> SOL_MEMDESC_OPS_VECTOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operations to handle struct <a class="el" href="structsol__vector.html" title="Soletta vector is an array that grows dynamically. ">sol_vector</a>. </p>
<p>If one wants to use SOL_MEMDESC_TYPE_ARRAY with a struct <a class="el" href="structsol__vector.html" title="Soletta vector is an array that grows dynamically. ">sol_vector</a>, then use this operations to initialize, get length, get element and resize the array. </p>

</div>
</div>
<a class="anchor" id="gaf133ef43ccdc949c3c9c545608504a15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structsol__memdesc__serialize__options.html">sol_memdesc_serialize_options</a> SOL_MEMDESC_SERIALIZE_OPTIONS_DEFAULT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the default struct <a class="el" href="structsol__memdesc__serialize__options.html" title="Options on how to serialize a memory given its description. ">sol_memdesc_serialize_options</a>. </p>
<p>This symbol defines the original serialize options used by Soletta, it can be used to get default slices as well as serialization functions.</p>
<p>For instance, if you want to customize the serialization of a given structure member but not others, then you can override struct <a class="el" href="structsol__memdesc__serialize__options.html#a38dff3a50e1e6ba7f494b48f93bf14c0" title="function used to format a struct member. ">sol_memdesc_serialize_options::serialize_structure_member</a> and call SOL_MEMDESC_SERIALIZE_OPTIONS::serialize_structure_member whenever to use the standard output. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<a href="http://solettaproject.github.io/docs/">Full online documentation</a> | 
<a href="index.html">C API Index</a>
</small></address>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
