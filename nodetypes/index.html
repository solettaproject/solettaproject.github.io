<!doctype html>
<html lang="en">
<head>
<title>{ Soletta Cheat Sheet }</title>
<link rel="stylesheet" type="text/css" href="styles.css">
<script type="text/javascript" src="js/isotope.pkgd.min.js"></script>
<script type="text/javascript" src="js/Entry.js"></script>
<script type="text/javascript" src="js/Category.js"></script>
<script type="text/javascript" src="js/MenuItem.js"></script>
<script type="text/javascript">

function init()
{
    var group;
    var createdGroups = [];

var groupId = "0";
var category = new Category("keyboard", " ", "category" + groupId);
var menuItem = new MenuItem("keyboard", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("keyboard/boolean", "Provides boolean packets after each key press from a physical keyboard", [
],[
["OUT", "boolean", "A boolean packet when keyboard input arrives."],
],[
["binary_code", "int", "A key's actual ASCII code to capture.", ""],
["toggle", "boolean", "Whether to toggle the output value, if the same key is pressed in sequence.", "False"],
]);
entry.add(group);
var entry = new Entry("keyboard/int", "Provides int packets after each key press from a physical keyboard", [
],[
["OUT", "int", "An int range packet (with the given key pressed's code) when keyboard input arrives."],
],[
]);
entry.add(group);
var groupId = "1";
var category = new Category("int", " ", "category" + groupId);
var menuItem = new MenuItem("int", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("int/max", "Int Max", [
["IN", "int", "Two ports for max operation. Indexed from 0 to 1."],
],[
["OUT", "int", "Maximum value between IN[0] and IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/min", "Int Min", [
["IN", "int", "Two ports for min operation. Indexed from 0 to 1."],
],[
["OUT", "int", "Minimum value between IN[0] and IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/abs", "Calculates absolute value of a number.", [
["IN", "int", "Input number."],
],[
["OUT", "int", "Number's absolute value."],
],[
]);
entry.add(group);
var entry = new Entry("int/accumulator", "Increment or decrement it's internal value by 'step' whenever a packet is received and outputs the updated value. If the internal value is greater than 'max' after an increment, it's set to min and an empty packet is sent through OVERFLOW port as well, or if it's less than 'min' after a decrement, it's set to 'max' and an empty packet is sent through UNDERFLOW port.", [
["INC", "any", "Increment operation."],
["DEC", "any", "Decrement operation."],
["RESET", "any", "Reset accumulator to its initial state."],
],[
["OUT", "int", "Updated value after an input is processed."],
["OVERFLOW", "empty", "Sends an empty package whenever an overflow happens."],
["UNDERFLOW", "empty", "Sends an empty package whenever an underflow happens."],
],[
["setup_value", "int", "The initial value, range and step to be used in operations. Only positive step values are allowed.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("int/addition", "Arithmetic addition operation with ints", [
["OPERAND", "int", "Thirty two ports for addition operation. Indexed from 0 to 31."],
],[
["OUT", "int", "Sum of values received on ports OPERAND[0] to OPERAND[31]."],
],[
]);
entry.add(group);
var entry = new Entry("int/division", "Arithmetic division operation with ints", [
["DIVIDEND", "int", "Receives dividend value."],
["DIVISOR", "int", "Receives divisor value."],
],[
["OUT", "int", "Quotient from the division of DIVIDEND by DIVISOR."],
],[
]);
entry.add(group);
var entry = new Entry("int/modulo", "Arithmetic modulo operation with ints", [
["DIVIDEND", "int", "Receives dividend value."],
["DIVISOR", "int", "Receives divisor value."],
],[
["OUT", "int", "Remainder from the division of DIVIDEND by DIVISOR."],
],[
]);
entry.add(group);
var entry = new Entry("int/multiplication", "Arithmetic multiplication operation with ints", [
["OPERAND", "int", "Thirty two ports for multiplication operation. Indexed from 0 to 31."],
],[
["OUT", "int", "Product of values received on ports OPERAND[0] and OPERAND[31]."],
],[
]);
entry.add(group);
var entry = new Entry("int/subtraction", "Arithmetic subtraction operation with ints", [
["MINUEND", "int", "Receives minuend value."],
["SUBTRAHEND", "int", "Receives subtrahend value."],
],[
["OUT", "int", "Difference of values received on ports OPERAND[0] to OPERAND[31]."],
],[
]);
entry.add(group);
var entry = new Entry("int/bitwise-and", "Bitwise And", [
["IN", "int", "Two ports for AND operation. Indexed from 0 to 1."],
],[
["OUT", "int", "The result of a bitwise AND between IN[0] and IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("int/bitwise-not", "Bitwise Not", [
["IN", "int", "First port of NOT operation."],
],[
["OUT", "int", "Bitwise NOT of the value received in IN."],
],[
]);
entry.add(group);
var entry = new Entry("int/bitwise-or", "Bitwise Or", [
["IN", "int", "Two ports for OR operation. Indexed from 0 to 1."],
],[
["OUT", "int", "The result of a bitwise OR between IN[0] and IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("int/shift-left", "Bitwise Shift Left", [
["IN", "int", "Value to be shifted"],
["SHIFT", "int", "Number of bits to shift the value in IN (must be less than 32)"],
],[
["OUT", "int", "The value received in IN, shifted SHIFT bits to the left."],
],[
]);
entry.add(group);
var entry = new Entry("int/shift-right", "Bitwise Shift Right", [
["IN", "int", "Value to be shifted"],
["SHIFT", "int", "Number of bits to shift the value in IN (must be less than 32)"],
],[
["OUT", "int", "The value received in IN, shifted SHIFT bits to the right (No sign extension)."],
],[
]);
entry.add(group);
var entry = new Entry("int/bitwise-xor", "Bitwise Xor", [
["IN", "int", "Two ports for XOR operation. Indexed from 0 to 1."],
],[
["OUT", "int", "The result of a bitwise XOR between IN[0] xor IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("int/buffer", "Apply desired computation when buffer fills or timeout happens.", [
["IN", "int", "Input port."],
["TIMEOUT", "int", "Receives an int packet to set the timeout time to be used."],
["RESET", "any", "Reset buffer and timer to its initial state."],
],[
["OUT", "int", "Output port."],
],[
["samples", "int", "Number of samples that the buffer should hold.", "{'step': 1, 'max': 'INT32_MAX', 'val': 4, 'min': 'INT32_MIN'}"],
["timeout", "int", "Timeout time in milliseconds. Default is zero which means that timeout is disabled.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["operation", "string", "Operation to be applied in the buffer elements to compute the output.", "all_true"],
]);
entry.add(group);
var entry = new Entry("int/equal", "Check if an int is equal to other.", [
["IN", "int", "Two ports for equal comparison operation. Indexed from 0 to 1."],
],[
["OUT", "boolean", "True if value received on port IN[0] is equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/greater", "Check if an int is greater than other.", [
["IN", "int", "Two ports for greater comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is greater than value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/greater-or-equal", "Check if an int is greater than or equal to other.", [
["IN", "int", "Two ports for greater-or-equal comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is greater than or equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/less", "Check if an int is less than other.", [
["IN", "int", "Two ports for less comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is less than value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/less-or-equal", "Check if an int is less than or equal to other.", [
["IN", "int", "Two ports for less-or-equal comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is less than or equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/not-equal", "Check if an int is different from other.", [
["IN", "int", "Two ports for not-equal comparison operation. Indexed from 0 to 1"],
],[
["OUT", "boolean", "True if value received on port IN[0] is different from value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/constrain", "Constrain value to it's range", [
["IN", "int", "Value to be constrained."],
],[
["OUT", "int", "Value constrained considering range"],
],[
["range", "int", "Range values (min, max, step). Used only if use_input_range is disabled.", "{'step': 1, 'max': 1023, 'val': 0, 'min': 0}"],
["use_input_range", "boolean", "Use min, max and step values from package instead of options min, max and step. It's useful if you need to convert from many different sources to the same range and all of them inform these values correctly in each package.", "True"],
]);
entry.add(group);
var entry = new Entry("int/filter", "Filter ints in range", [
["IN", "int", "Data input port."],
],[
["OUT", "int", "Outputs the same variable as the input if it's in range, nothing otherwise."],
],[
["min", "int", "Minimum value (inclusive)", "{'step': 1, 'max': 'INT32_MAX', 'val': 'INT32_MIN', 'min': 'INT32_MIN'}"],
["max", "int", "Maximum value (inclusive)", "{'step': 1, 'max': 'INT32_MAX', 'val': 'INT32_MAX', 'min': 'INT32_MIN'}"],
["range_override", "boolean", "if true, the packet irange will have it's min and max changed to the min and max of this node.", "False"],
]);
entry.add(group);
var entry = new Entry("int/inrange", "check if value is between a min and max range.", [
["IN", "int", "value that will be checked if its in range or not."],
],[
["OUT", "boolean", "true if IN is in range"],
],[
["range", "int", "maximum range value.", "{'step': 1, 'max': 255, 'val': 0, 'min': -255}"],
]);
entry.add(group);
var entry = new Entry("int/map", "Map values to different range", [
["IN", "int", "Value to be converted."],
],[
["OUT", "int", "Value mapped considering input and output ranges"],
],[
["input_range", "int", "Input's range. Used only if use_input_range is disabled.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["output_range", "int", "Output's range.", ""],
["use_input_range", "boolean", "Use min and max values from input package instead of option input_range. It's useful if you need to convert from many different sources to the same range and all of them inform these values correctly in each package.", "True"],
]);
entry.add(group);
var groupId = "2";
var category = new Category("string", " ", "category" + groupId);
var menuItem = new MenuItem("string", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("string/compare", "Compare two strings", [
["IN", "string", "Two strings to be compared. Indexed from 0 to 1."],
],[
["OUT", "int", "It returns an integer less than, equal to, or greater than zero if string received on IN[0] is found to be less than, to match, or be greater than string on IN[1]."],
["EQUAL", "boolean", "TRUE if the string received on IN[0] is the same as the string on IN[1]."],
],[
["bytes", "int", "Amount of bytes to be compared between strings. If zero, the whole strings will be compared.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["ignore_case", "boolean", "Ignore case when comparing strings.", "False"],
]);
entry.add(group);
var entry = new Entry("string/concatenate", "Concatenate two strings", [
["IN", "string", "Two strings to be concatenated. Indexed from 0 to 1."],
],[
["OUT", "string", "String IN[0] concatenated to string IN[1]."],
],[
["bytes", "int", "Amount of bytes to be copied from string received on IN[1]. If zero, the whole string will be concatenated to the string received on IN[0]", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["separator", "string", "Separator string to be used between the two concatenated strings. It's set to null by default (no separator).", "None"],
]);
entry.add(group);
var entry = new Entry("string/length", "Calculate the length of a string", [
["IN", "string", "String to be measured."],
],[
["OUT", "int", "Send the string size, the number of bytes excluding terminating null byte. If maxlen is provided, it'll be at most this value."],
],[
["maxlen", "int", "Maximum length to be checked. If a string is greater than that, maxlen value will be sent. If zero, no limit is applied.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("string/split", "Split a string given a separator.", [
["IN", "string", "String to be split."],
["SEPARATOR", "string", "String received on 'IN' port will be split using these delimiter chars."],
["INDEX", "int", "A string can be split in many substrings. This value defines which substring should be sent. It must be non negative."],
],[
["LENGTH", "int", "Number of generated substrings."],
["OUT", "string", "Substring given a separator and an index."],
],[
["index", "int", "A string can be split in many substrings. This value defines which substring should be sent. It must be non negative. It can be overriden by values received on 'INDEX' port.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["separator", "string", "String received on 'IN' port will be split using these delimiters chars. It can be overriden by values received on 'SEPARATOR' port.", " "],
]);
entry.add(group);
var groupId = "3";
var category = new Category("constant", " ", "category" + groupId);
var menuItem = new MenuItem("constant", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("constant/boolean", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "boolean", "Constant value, sent only once, when connected to a node."],
],[
["value", "boolean", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/byte", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "byte", "Constant value, sent only once, when connected to a node."],
],[
["value", "byte", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/float", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "float", "Constant value, sent only once, when connected to a node."],
],[
["value", "float", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/empty", "Send an initial empty packet.", [
],[
["OUT", "empty", "A single pulse sent when connected to a node."],
],[
]);
entry.add(group);
var entry = new Entry("constant/int", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "int", "Constant value, sent only once, when connected to a node."],
],[
["value", "int", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/rgb", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "rgb", "Constant value, sent only once, when connected to a node."],
],[
["value", "rgb", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/direction-vector", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "direction-vector", "Constant value, sent only once, when connected to a node."],
],[
["value", "direction-vector", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/string", "Send an initial packet with a string set on options.", [
],[
["OUT", "string", "Constant value, sent only once, when connected to a node."],
],[
["value", "string", "String to be sent when node is connected.", ""],
]);
entry.add(group);
var groupId = "4";
var category = new Category("pwm", " ", "category" + groupId);
var menuItem = new MenuItem("pwm", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("pwm", "PWM", [
["ENABLED", "boolean", "True enables PWM, False disables it"],
["PERIOD", "int", "PWM period, in ns"],
["DUTY_CYCLE", "int", "Duty cycle, in ns"],
],[
],[
["chip", "int", "PWM chip", ""],
["pin", "int", "PWM pin channel", ""],
["enabled", "boolean", "Initial enabled state", "False"],
["inversed_polarity", "boolean", "PWM polarity (normal or inversed)", "False"],
["period", "int", "Initial period", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["duty_cycle", "int", "Initial duty cycle", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var groupId = "5";
var category = new Category("oic", " ", "category" + groupId);
var menuItem = new MenuItem("oic", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("oic/server-brightlight", "OIC Server (Legacy Brightlight)", [
["IN_STATE", "boolean", "True if on, False if off"],
["IN_POWER", "int", "Current sensed or set value for Brightness"],
],[
["OUT_STATE", "boolean", "True if on, False if off"],
["OUT_POWER", "int", "Current sensed or set value for Brightness"],
],[
]);
entry.add(group);
var entry = new Entry("oic/client-brightlight", "OIC Client (Legacy Brightlight)", [
["IN_STATE", "boolean", "True if on, False if off"],
["IN_POWER", "int", "Current sensed or set value for Brightness"],
],[
["FOUND", "boolean", "Outputs true if resource was found, false if not, or if unreachable"],
["OUT_STATE", "boolean", "True if on, False if off"],
["OUT_POWER", "int", "Current sensed or set value for Brightness"],
],[
["hwaddr", "string", "Hardware address of the device (MAC address, etc)", ""],
]);
entry.add(group);
var groupId = "6";
var category = new Category("color", " ", "category" + groupId);
var menuItem = new MenuItem("color", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("color/luminance-rgb", "Modifies a color changing its luminance.", [
["IN", "int", "Luminance to be applied in the color."],
],[
["OUT", "rgb", "Color with new luminance applied. The value is a multiplication of each component on option and rate between luminance value and its range."],
],[
["color", "rgb", "Initial color, with full luminance. Luminance will vary considering value received on IN port.", ""],
]);
entry.add(group);
var groupId = "7";
var category = new Category("byte", " ", "category" + groupId);
var menuItem = new MenuItem("byte", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("byte/bitwise-and", "Bitwise And", [
["IN", "byte", "Two ports for bitwise operation AND. Indexed from 0 to 1."],
],[
["OUT", "byte", "The result of a bitwise AND between IN[0] and IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("byte/bitwise-not", "Bitwise Not", [
["IN", "byte", "First port of NOT operation."],
],[
["OUT", "byte", "Bitwise NOT of the value received in IN."],
],[
]);
entry.add(group);
var entry = new Entry("byte/bitwise-or", "Bitwise Or", [
["IN", "byte", "Two ports for bitwise operation OR. Indexed from 0 to 1."],
],[
["OUT", "byte", "The result of a bitwise OR between IN[0] or IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("byte/shift-left", "Bitwise Shift Left", [
["IN", "byte", "Value to be shifted"],
["SHIFT", "byte", "Number of bits to shift the value in IN (must be less than 8)"],
],[
["OUT", "byte", "The value received in IN, shifted SHIFT bits to the left."],
],[
]);
entry.add(group);
var entry = new Entry("byte/shift-right", "Bitwise Shift Right", [
["IN", "byte", "Value to be shifted"],
["SHIFT", "byte", "Number of bits to shift the value in IN (must be less than 8)"],
],[
["OUT", "byte", "The value received in IN, shifted SHIFT bits to the right (No sign extension)."],
],[
]);
entry.add(group);
var entry = new Entry("byte/bitwise-xor", "Bitwise Xor", [
["IN", "byte", "Two ports for bitwise operation XOR. Indexed from 0 to 1."],
],[
["OUT", "byte", "The result of a bitwise XOR between IN[0] xor IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("byte/filter", "Filter bytes in range", [
["IN", "byte", "Data input port."],
],[
["OUT", "byte", "Outputs the same variable as the input if it's in range, nothing otherwise."],
],[
["min", "byte", "Minimum value (inclusive)", "0"],
["max", "byte", "Maximum value (inclusive)", "255"],
]);
entry.add(group);
var groupId = "8";
var category = new Category("gtk", " ", "category" + groupId);
var menuItem = new MenuItem("gtk", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("gtk/byte-editor", "A byte's individual bits editor that outputs int packets with the resulting value.", [
],[
["OUT", "byte", "The current reading for the editor, after a change"],
],[
]);
entry.add(group);
var entry = new Entry("gtk/label", "Text output for boolean/int packets.", [
["IN", "any", "Prints the packet's value to a label widget"],
],[
],[
]);
entry.add(group);
var entry = new Entry("gtk/led", "Gtk widget that immitates a led. It's turned on by a true boolea packet and off by a false one.", [
["IN", "any", "Controls whether the led is on or off"],
],[
],[
["rgb", "string", "The led's RGB color components", "0|0|255"],
]);
entry.add(group);
var entry = new Entry("gtk/pushbutton", "Emulates a pushbutton providing boolean packets", [
],[
["OUT", "boolean", "TRUE when pushed and FALSE when released."],
],[
]);
entry.add(group);
var entry = new Entry("gtk/pwm-editor", "Gtk widget that a provides (int and boolean) pwm packets to other nodes.", [
],[
["ENABLED", "boolean", "The current reading for enabled (after an input change)"],
["DUTY_CYCLE", "int", "The current reading for duty cycle (after an input change)"],
["PERIOD", "int", "The current reading for period (after an input change)"],
],[
["range", "int", "PWM editor range", "{'step': 1, 'max': 100, 'val': 0, 'min': 0}"],
]);
entry.add(group);
var entry = new Entry("gtk/pwm-viewer", "Gtk widget that provides a graphical visualization of PWM.", [
["ENABLED", "boolean", "Controls whether PWM is enabled or disabled."],
["DUTY_CYCLE", "int", "Set duty cycle value."],
["PERIOD", "int", "Set period."],
],[
],[
]);
entry.add(group);
var entry = new Entry("gtk/rgb-editor", "A color chooser widget that outputs int packets with RGB color space encoded in the int value.", [
],[
["OUT", "rgb", "The current reading for the editor, after a change"],
],[
]);
entry.add(group);
var entry = new Entry("gtk/slider", "Slider that provides (int) input packets to other nodes", [
],[
["OUT", "int", "The current reading for the slider (after an input change)"],
],[
["range", "int", "Slider's range", "{'step': 1, 'max': 100, 'val': 0, 'min': 0}"],
]);
entry.add(group);
var entry = new Entry("gtk/spinbutton", "Spinbutton that provides (int) input packets to other nodes", [
],[
["OUT", "int", "The current reading for the spinbutton (after an input change)"],
],[
["range", "int", "Spinbutton's range", "{'step': 1, 'max': 100, 'val': 0, 'min': 0}"],
]);
entry.add(group);
var entry = new Entry("gtk/toggle", "Toggle that provides boolean input packets to other nodes", [
],[
["OUT", "boolean", "The current reading for the toggle (after an input change)"],
],[
]);
entry.add(group);
var groupId = "9";
var category = new Category("hub", " ", "category" + groupId);
var menuItem = new MenuItem("hub", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("hub/blob", "Forward blob packets.", [
["IN", "blob", "Where to receive the blob packet to be forwarded."],
],[
["OUT", "blob", "Forwarded blob packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/boolean", "Forward boolean packets.", [
["IN", "boolean", "Where to receive the boolean packet to be forwarded."],
],[
["OUT", "boolean", "Forwarded boolean packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/byte", "Forward byte packets.", [
["IN", "byte", "Where to receive the byte packet to be forwarded."],
],[
["OUT", "byte", "Forwarded byte packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/empty", "Forward empty packets.", [
["IN", "any", "Where to receive the packet to be forwarded. Any packet can be received, but they'll be forwarded as empty packets."],
],[
["OUT", "empty", "Forwarded empty packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/error", "Forward error packets.", [
["IN", "error", "Where to receive the error packet to be forwarded. They're forwared via 'ERROR' port."],
],[
],[
]);
entry.add(group);
var entry = new Entry("hub/float", "Forward float packets.", [
["IN", "float", "Where to receive the float packet to be forwarded."],
],[
["OUT", "float", "Forwarded float packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/int", "Forward int packets.", [
["IN", "int", "Where to receive the int packet to be forwarded."],
],[
["OUT", "int", "Forwarded int packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/rgb", "Forward rgb packets.", [
["IN", "rgb", "Where to receive the rgb packet to be forwarded."],
],[
["OUT", "rgb", "Forwarded rgb packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/direction-vector", "Forward direction vector packets.", [
["IN", "direction-vector", "Where to receive the direction vector packet to be forwarded."],
],[
["OUT", "direction-vector", "Forwarded direction_vector packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/string", "Forward string packets.", [
["IN", "string", "Where to receive the string packet to be forwarded."],
],[
["OUT", "string", "Forwarded string packets."],
],[
]);
entry.add(group);
var groupId = "10";
var category = new Category("fs", " ", "category" + groupId);
var menuItem = new MenuItem("fs", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("fs/persist-boolean", "Persists the last input packet's data it receives in a given file, also repeating that packet on output port. Note that upon a new connection on the unique output port, if a previous stored packet is found, it will already be sent.", [
["IN", "boolean", "A boolean packet to persist (and repeat on output)"],
],[
["OUT", "boolean", "A boolean packet with the persisted value of the node"],
],[
["path", "string", "Path to file to persist a boolean packet in. The node won't create a new file, it must exist", ""],
]);
entry.add(group);
var entry = new Entry("fs/persist-byte", "Persists the last input packet's data it receives in a given file, also repeating that packet on output port. Note that upon a new connection on the unique output port, if a previous stored packet is found, it will already be sent.", [
["IN", "byte", "A byte packet to persist (and repeat on output)"],
],[
["OUT", "byte", "A byte packet with the persisted value of the node"],
],[
["path", "string", "Path to file to persist a byte packet in. The node won't create a new file, it must exist", ""],
]);
entry.add(group);
var entry = new Entry("fs/persist-float", "Persists the last input packet's data it receives in a given file, also repeating that packet on output port. Note that upon a new connection on the unique output port, if a previous stored packet is found, it will already be sent.", [
["IN", "float", "An float packet to persist (and repeat on output)"],
],[
["OUT", "float", "A float packet with the persisted value of the node"],
],[
["path", "string", "Path to file to persist a float packet in. The node won't create a new file, it must exist", ""],
]);
entry.add(group);
var entry = new Entry("fs/persist-int", "Persists the last input packet's data it receives in a given file, also repeating that packet on output port. Note that upon a new connection on the unique output port, if a previous stored packet is found, it will already be sent.", [
["IN", "int", "A int packet to persist (and repeat on output)"],
],[
["OUT", "int", "A int packet with the persisted value of the node"],
],[
["path", "string", "Path to file to persist a int packet in. The node won't create a new file, it must exist", ""],
]);
entry.add(group);
var entry = new Entry("fs/persist-string", "Persists the last input packet's data it receives in a given file system file, also repeating that packet on output port. Note that upon a new connection on the unique output port, if a previous stored packet is found, it will already be sent.", [
["IN", "string", "A string packet to persist (and repeat on output)"],
],[
["OUT", "string", "A string packet with the persisted value of the node"],
],[
["path", "string", "Path to file to persist a string packet in. The node won't create a new file, it must exist", ""],
]);
entry.add(group);
var groupId = "11";
var category = new Category("servo-motor", " ", "category" + groupId);
var menuItem = new MenuItem("servo-motor", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("servo-motor/controller", "Control RC servo motors.", [
["ANGLE", "float", "Set the angle of the shaft in degrees, from 0 to 180."],
["DUTY_CYCLE", "int", "Set duty cycle width in microseconds. Shoudln't be less or greater than min and max values, defined on options."],
],[
],[
["duty_cycle_range", "int", "Pulse width range, in microseconds, corresponding to the minimum (0-degree) angle on the servo until the maximum (180-degree) angle.", "{'step': 1, 'max': 2400, 'val': 0, 'min': 544}"],
["period", "int", "Period, in microseconds. A pulse repetition rate of 50 Hz should work with most servos.", "{'step': 1, 'max': 'INT32_MAX', 'val': 22000, 'min': 'INT32_MIN'}"],
["chip", "int", "PWM chip", ""],
["pin", "int", "PWM pin channel", ""],
]);
entry.add(group);
var groupId = "12";
var category = new Category("converter", " ", "category" + groupId);
var menuItem = new MenuItem("converter", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("converter/boolean-to-float", "Receives a boolean packet and convert to float.", [
["IN", "boolean", "Where to receive the boolean value to be converted."],
["FALSE_VALUE", "float", "DRange value of output when input is false."],
["TRUE_VALUE", "float", "DRange value of output when input is true."],
],[
["OUT", "float", "Float with value set on options or via value_set ports."],
],[
["false_value", "float", "DRange value of output when input is false.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 0.0, 'min': '-DBL_MAX'}"],
["true_value", "float", "DRange value of output when input is true.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 1.0, 'min': '-DBL_MAX'}"],
]);
entry.add(group);
var entry = new Entry("converter/boolean-to-byte", "Receives a boolean packet and convert to byte.", [
["IN", "boolean", "Where to receive the boolean value to be converted."],
["FALSE_VALUE", "byte", "Byte value of output when input is false."],
["TRUE_VALUE", "byte", "Byte value of output when input is true."],
],[
["OUT", "byte", "Byte with value set on options or via value_set ports."],
],[
["false_value", "byte", "Byte value of output when input is false.", "0"],
["true_value", "byte", "Byte value of output when input is true.", "1"],
]);
entry.add(group);
var entry = new Entry("converter/boolean-to-empty", "Receives a boolean packet and convert it to empty.", [
["PULSE_IF_TRUE", "boolean", "If received boolean is true generates a pulse."],
["PULSE_IF_FALSE", "boolean", "If received boolean is false generates a pulse."],
],[
["OUT", "empty", "Sends a pulse if boolean values received on each port match expected value."],
],[
]);
entry.add(group);
var entry = new Entry("converter/boolean-to-int", "Receives a boolean packet and convert to int.", [
["IN", "boolean", "Where to receive the boolean value to be converted."],
["FALSE_VALUE", "int", "IRange value of output when input is false."],
["TRUE_VALUE", "int", "IRange value of output when input is true."],
],[
["OUT", "int", "IRange with value set on options or via value_set ports."],
],[
["false_value", "int", "IRange value of output when input is false.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["true_value", "int", "IRange value of output when input is true.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("converter/boolean-to-string", "Receives a boolean packet and convert to string.", [
["IN", "boolean", "Where to receive the boolean value to be converted."],
["FALSE_VALUE", "string", "String to be sent on output when input is false."],
["TRUE_VALUE", "string", "String to be sent on output when input is true."],
],[
["OUT", "string", "Send string defined by option 'true_value' if input is true or by 'false_value' if input is false."],
],[
["false_value", "string", "String sent when input is false.", "False"],
["true_value", "string", "String sent when input is true.", "True"],
]);
entry.add(group);
var entry = new Entry("converter/byte-to-bits", "Receives byte packet and convert to a binary representaion in outputs.", [
["IN", "byte", "Where to receive the byte value to be converted."],
],[
["OUT", "boolean", "Byte turned to bits, index 0 is the least significant, 7 the most"],
],[
]);
entry.add(group);
var entry = new Entry("converter/byte-to-boolean", "Receives a byte packet and convert to boolean.", [
["IN", "byte", "Where to receive the byte value to be converted."],
["TRUE_MAX", "byte", "Defines maximum value of input to set output as true."],
["TRUE_MIN", "byte", "Defines minimum value of input to set output as true."],
],[
["OUT", "boolean", "Send true if input packet value is in range defined by min and max values or false otherwise."],
],[
["true_max", "byte", "Defines maximum value of input to set output as true.", "255"],
["true_min", "byte", "Defines minimum value of input to set output as true.", "1"],
]);
entry.add(group);
var entry = new Entry("converter/byte-to-float", "Receives a byte packet and convert to float.", [
["IN", "byte", "Where to receive the byte value to be converted."],
],[
["OUT", "float", "Byte converted to float."],
],[
]);
entry.add(group);
var entry = new Entry("converter/byte-to-empty", "Receives a byte packet and convert it to empty.", [
["IN", "byte", "Where to receive the byte value to be converted."],
["RANGE_MAX", "byte", "Byte maximum range value that generates a pulse."],
["RANGE_MIN", "byte", "Byte minimum range value that generates a pulse."],
],[
["OUT", "empty", "Send an empty packet when input packet value in range defined by min and max values."],
],[
["range_max", "byte", "Byte maximum value that generates a pulse.", "255"],
["range_min", "byte", "Byte minimum value that generates a pulse.", "1"],
]);
entry.add(group);
var entry = new Entry("converter/byte-to-int", "Receives a byte packet and convert to int.", [
["IN", "byte", "Where to receive the byte value to be converted."],
],[
["OUT", "int", "Byte converted to int."],
],[
]);
entry.add(group);
var entry = new Entry("converter/byte-to-rgb", "Receives byte packets and convert to RGB.", [
["RED", "byte", "Byte value for red component."],
["GREEN", "byte", "Byte value for green component."],
["BLUE", "byte", "Byte value for blue component."],
],[
["OUT", "rgb", "Bytes converted to RGB."],
],[
]);
entry.add(group);
var entry = new Entry("converter/byte-to-direction-vector", "Receives byte packets and convert to direction vector", [
["X", "byte", "Byte value for x component."],
["Y", "byte", "Byte value for y component."],
["Z", "byte", "Byte value for z component."],
],[
["OUT", "direction-vector", "Bytes converted to direction vector."],
],[
]);
entry.add(group);
var entry = new Entry("converter/byte-to-string", "Receives a byte packet and convert to string.", [
["IN", "byte", "Where to receive the byte value to be converted."],
],[
["OUT", "string", "Byte converted to string, prefixed with '0x', as 0x3e."],
],[
]);
entry.add(group);
var entry = new Entry("converter/float-to-boolean", "Receives an float packet and convert to boolean.", [
["IN", "float", "Where to receive the float value to be converted."],
["TRUE_RANGE", "float", "Defines minimum and maximum values of input to set output as true."],
],[
["OUT", "boolean", "Send true if input packet value is in range defined by min and max values or false otherwise."],
],[
["true_range", "float", "Defines minimum and maximum values of input to set output as true.", "{'step': 'DBL_MIN', 'max': 255, 'val': 0.0, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/float-to-byte", "Receives a float packet and convert to byte.", [
["IN", "float", "Where to receive the float value to be converted."],
],[
["OUT", "byte", "Float converted to byte. If float was greater than 255 or less than 0 the converted value will be at these limits."],
],[
]);
entry.add(group);
var entry = new Entry("converter/float-to-empty", "Receives a float packet and convert it to empty.", [
["IN", "float", "Where to receive the float value to be converted."],
["RANGE", "float", "Float range that generates a pulse."],
],[
["OUT", "empty", "Send an empty packet when input packet value is in range defined by min and max values."],
],[
["range", "float", "Float range that generates a pulse.", "{'step': 'DBL_MIN', 'max': 255, 'val': 0.0, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/float-to-int", "Receives a float packet and convert to int.", [
["IN", "float", "Where to receive the float value to be converted."],
],[
["OUT", "int", "Float converted to int. Value, min, max and step are converted."],
],[
]);
entry.add(group);
var entry = new Entry("converter/float-to-rgb", "Receives float packets and convert to RGB.", [
["RED", "float", "Float value for red component."],
["GREEN", "float", "Float value for green component."],
["BLUE", "float", "Float value for blue component."],
],[
["OUT", "rgb", "Float values converted to RGB."],
],[
["red_max", "int", "Max value of red component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["green_max", "int", "Max value of green component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["blue_max", "int", "Max value of blue component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("converter/float-to-direction-vector", "Receives float packets and converts to direction vector ones.", [
["X", "float", "Float value for x component."],
["Y", "float", "Float value for y component."],
["Z", "float", "Float value for z component."],
],[
["OUT", "direction-vector", "Float values converted to direction vector."],
],[
["out_range", "float", "Range of output packet.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 0.0, 'min': '-DBL_MAX'}"],
]);
entry.add(group);
var entry = new Entry("converter/float-to-string", "Receives a float packet and convert to string.", [
["IN", "float", "Where to receive the float value to be converted."],
],[
["OUT", "string", "Float converted to string with 6 digits after decimal-point character."],
],[
]);
entry.add(group);
var entry = new Entry("converter/empty-to-boolean", "Receives an empty packet and convert it to boolean.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "boolean", "Boolean value of output when an empty packet is received."],
],[
["OUT", "boolean", "Boolean defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "boolean", "Boolean value of output when an empty packet is received.", "True"],
]);
entry.add(group);
var entry = new Entry("converter/empty-to-rgb", "Receives an empty packet and convert it to rgb.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "rgb", "RGB value of output when an empty packet is received."],
],[
["OUT", "rgb", "RGB defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "rgb", "RGB value of output when an empty packet is received.", "{'red': 255, 'green_max': 255, 'blue': 255, 'green': 255, 'blue_max': 255, 'red_max': 255}"],
]);
entry.add(group);
var entry = new Entry("converter/empty-to-byte", "Receives an empty packet and convert it to byte.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "byte", "Byte value of output when an empty packet is received."],
],[
["OUT", "byte", "Byte defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "byte", "Byte value of output when an empty packet is received.", "1"],
]);
entry.add(group);
var entry = new Entry("converter/empty-to-float", "Receives an empty packet and convert it to float.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "float", "Float value of output when an empty packet is received."],
],[
["OUT", "float", "Float defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "float", "Float value of output when an empty packet is received.", "{'step': 1, 'max': 1, 'val': 1, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/empty-to-int", "Receives an empty packet and convert it to int.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "int", "Int value of output when an empty packet is received."],
],[
["OUT", "int", "Int defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "int", "Int value of output when an empty packet is received.", "{'step': 1, 'max': 1, 'val': 1, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/empty-to-string", "Receives an empty packet and convert it to string.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "string", "Output string sent when an empty packet is received."],
],[
["OUT", "string", "String defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "string", "Output string sent when an empty packet is received.", ""],
]);
entry.add(group);
var entry = new Entry("converter/int-to-boolean", "Receives an int packet and convert to boolean.", [
["IN", "int", "Where to receive the int value to be converted."],
["TRUE_RANGE", "int", "Defines minimum and maximum values of input to set output as true."],
],[
["OUT", "boolean", "Send true if input packet value is in range defined by min and max values or false otherwise."],
],[
["true_range", "int", "Defines minimum and maximum values of input to set output as true.", "{'step': 1, 'max': 255, 'val': 0, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/int-to-byte", "Receives an int packet and convert to byte.", [
["IN", "int", "Where to receive the int value to be converted."],
],[
["OUT", "byte", "Int converted to byte. If int was greater than 255 or less than 0 the converted value will be at these limits."],
],[
]);
entry.add(group);
var entry = new Entry("converter/int-compose", "Receives four bytes and composes them into an int. Any input port with no connections will be treated as a 0 value input.", [
["IN", "byte", "Array of bytes to turn into an int. Index 0 is the least significant, 3 is the most"],
],[
["OUT", "int", "Integer composed from the four input bytes"],
],[
]);
entry.add(group);
var entry = new Entry("converter/int-decompose", "Receives an int packet and decomposes it into four bytes. The received int will be treated as unsigned.", [
["IN", "int", "Where to receive the int value to be decomposed."],
],[
["OUT", "byte", "Int turned to bytes, index 0 is the least significant, 3 the most"],
],[
]);
entry.add(group);
var entry = new Entry("converter/int-to-float", "Receives an int packet and convert to float.", [
["IN", "int", "Where to receive the int value to be converted."],
],[
["OUT", "float", "Int converted to float. Value, min, max and step are converted."],
],[
]);
entry.add(group);
var entry = new Entry("converter/int-to-empty", "Receives an int packet and convert it to empty.", [
["IN", "int", "Where to receive the int value to be converted."],
["RANGE", "int", "Int range that generates a pulse."],
],[
["OUT", "empty", "Send an empty packet when input packet value is in range defined by min and max values."],
],[
["range", "int", "Int range that generates a pulse.", "{'step': 1, 'max': 255, 'val': 0, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/int-to-rgb", "Receives int packets and convert to RGB.", [
["RED", "int", "Int value for red component."],
["GREEN", "int", "Int value for green component."],
["BLUE", "int", "Int value for blue component."],
],[
["OUT", "rgb", "Int values converted to RGB."],
],[
["red_max", "int", "Max value of red component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["green_max", "int", "Max value of green component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["blue_max", "int", "Max value of blue component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("converter/direction-vector-to-rgb", "Receives direction vector packets and converts to RGB ones.", [
["IN", "direction-vector", "Input for direction vector packets to be converted."],
],[
["OUT", "rgb", "Direction vector values converted to RGB."],
],[
["red_max", "int", "Max value of red component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["green_max", "int", "Max value of green component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["blue_max", "int", "Max value of blue component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("converter/int-to-direction-vector", "Receives int packets and converts a to direction vector one.", [
["X", "int", "Int value for x component."],
["Y", "int", "Int value for y component."],
["Z", "int", "Int value for z component."],
],[
["OUT", "direction-vector", "Int values converted to direction vector."],
],[
["out_range", "float", "Range of output packet.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 0.0, 'min': '-DBL_MAX'}"],
]);
entry.add(group);
var entry = new Entry("converter/int-to-string", "Receives an int packet and convert to string.", [
["IN", "int", "Where to receive the int value to be converted."],
],[
["OUT", "string", "Int converted to string."],
],[
]);
entry.add(group);
var entry = new Entry("converter/rgb-to-byte", "Receives RGB packets and convert to bytes.", [
["IN", "rgb", "RGB to be decomposed."],
],[
["RED", "byte", "Byte value for red component."],
["GREEN", "byte", "Byte value for green component."],
["BLUE", "byte", "Byte value for blue component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/rgb-to-float", "Receives RGB packets and convert to float values.", [
["IN", "rgb", "RGB to be decomposed."],
],[
["RED", "float", "Float value for red component."],
["GREEN", "float", "Float value for green component."],
["BLUE", "float", "Float value for blue component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/rgb-to-int", "Receives RGB packets and convert to int values.", [
["IN", "rgb", "RGB to be decomposed."],
],[
["RED", "int", "Int value for red component."],
["GREEN", "int", "Int value for green component."],
["BLUE", "int", "Int value for blue component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/rgb-to-direction-vector", "Receives RGB packets and convert to direction vector ones.", [
["IN", "rgb", "RGB to be converted."],
],[
["OUT", "direction-vector", "Dimensional vector packet"],
],[
]);
entry.add(group);
var entry = new Entry("converter/direction-vector-to-byte", "Receives direction vector packets and converts to bytes.", [
["IN", "direction-vector", "direction vector to be decomposed."],
],[
["X", "byte", "Byte value for x component."],
["Y", "byte", "Byte value for y component."],
["Z", "byte", "Byte value for z component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/direction-vector-to-float", "Receives direction vector packets and converts to float values.", [
["IN", "direction-vector", "direction vector to be decomposed."],
],[
["X", "float", "Float value for x component."],
["Y", "float", "Float value for y component."],
["Z", "float", "Float value for z component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/direction-vector-to-int", "Receives direction vector packets and converts to RGB.", [
["IN", "direction-vector", "direction vector to be decomposed."],
],[
["X", "int", "Int value for x component."],
["Y", "int", "Int value for y component."],
["Z", "int", "Int value for z component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-boolean", "Receives a string packet and convert it to boolean.", [
["IN", "string", "Where to receive the string to be converted."],
],[
["OUT", "boolean", "Send true if received string is 'true' and false if 'false'. It ignores case. If string is different from those, no packet is sent."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-byte", "Receives a string packet and convert it to byte.", [
["IN", "string", "Where to receive the string to be converted."],
],[
["OUT", "byte", "Send converted value on success or do not send anything if a valid byte can't be parsed. It's expected to be on base 16 and may include '0x' prefix."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-float", "Receives a string packet and convert it to float.", [
["IN", "string", "Where to receive the string to be converted."],
],[
["OUT", "float", "Send converted value on success or do not send anything if a valid number can't be parsed."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-empty", "Receives a string packet and send an empty packet.", [
["IN", "string", "Where to receive the string."],
],[
["OUT", "empty", "Send a packet when any string is received."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-int", "Receives a string packet and convert it to int.", [
["IN", "string", "Where to receive the string to be converted."],
],[
["OUT", "int", "Send converted value on success or do not send anything if a valid number can't be parsed."],
],[
]);
entry.add(group);
var entry = new Entry("converter/error", "Extracts error code and string from an error packet.", [
["IN", "error", "Where to receive the error to be converted."],
],[
["CODE", "int", "Code extracted from error packet"],
["MESSAGE", "string", "Message extracted from error packet"],
],[
]);
entry.add(group);
var entry = new Entry("converter/bits-to-byte", "Receives boolean packets and convert these bits to a byte.", [
["IN", "boolean", "Array of bits to turn into a byte. Index 0 is the least significant, 7 is the most"],
],[
["OUT", "byte", "Send the byte converted from bits received."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-blob", "Receives a string packet and convert to blob (sub-type SOL_BLOB_TYPE_DEFAULT).", [
["IN", "string", "Where to receive the string value to be converted."],
],[
["OUT", "blob", "Send blob with the contents of the string received in the port IN."],
],[
]);
entry.add(group);
var groupId = "13";
var category = new Category("test", " ", "category" + groupId);
var menuItem = new MenuItem("test", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("test/result", "Node type used to indicate whether a test flow has passed or not", [
["PASS", "any", "Indicates that the tested flow has passed"],
["FAIL", "any", "Indicates that the tested flow has failed"],
["RESULT", "any", "Indicates the result of tested flow, TRUE means success and FALSE means failure"],
],[
],[
["timeout", "int", "Time allotted for a fbp test to run in ms. Expiration of the timer is considered a failure.", "{'step': 1, 'max': 'INT32_MAX', 'val': 500, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("test/boolean-validator", "Matches an expected sequence.", [
["IN", "boolean", "Where to receive the expected sequence."],
],[
["OUT", "boolean", "Outputs true if there is a match, false otherwise."],
],[
["sequence", "string", "Expected sequence to be matched, formatted as 'TFTFTTTFF' where 'T' is true and 'F' is false.", ""],
]);
entry.add(group);
var entry = new Entry("test/boolean-generator", "Provides predefined input for testing", [
],[
["OUT", "boolean", "Where the predefined sequence is outputted."],
],[
["sequence", "string", "String sequence to be generated, formatted as 'TFTFTTTFF' where 'T' is true and 'F' is false.", ""],
["interval", "int", "Interval between packets.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("test/int-validator", "Matches an expected sequence of integer values.", [
["IN", "int", "Where to receive the expected sequence."],
],[
["OUT", "boolean", "Outputs true if there is a match, false otherwise."],
],[
["sequence", "string", "Expected sequence to be matched, formatted as '1 2 3 -4 10 100 -1000'", ""],
]);
entry.add(group);
var entry = new Entry("test/int-generator", "Provides predefined input for testing", [
],[
["OUT", "int", "Where the predefined sequence is outputted."],
],[
["sequence", "string", "String sequence to be generated, formatted as '1 10 -2 1000'.", ""],
["interval", "int", "Interval between packets.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("test/float-generator", "Provides predefined input for testing", [
],[
["OUT", "float", "Where the predefined sequence is outputted."],
],[
["sequence", "string", "String sequence to be generated, formatted as '1.0 2 -1.7 35.864'", ""],
["interval", "float", "Interval between packets.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 0.0, 'min': '-DBL_MAX'}"],
]);
entry.add(group);
var entry = new Entry("test/float-validator", "Matches an expected sequence.", [
["IN", "float", "Where to receive the expected sequence."],
],[
["OUT", "boolean", "Outputs true if there is a match, false otherwise."],
],[
["sequence", "string", "Expected sequence to be matched, formatted as '1.0 2 -1.7 35.864'", ""],
]);
entry.add(group);
var entry = new Entry("test/blob-validator", "Matches an expected memory blob.", [
["IN", "blob", "Where to receive the expected sequence."],
],[
["OUT", "boolean", "Outputs true if there is a match, false otherwise."],
],[
["expected", "string", "Expected string to be matched", ""],
["expect_terminating_null_byte", "boolean", "If true, it will compare the received blob with 'expected' string with terminating null byte, otherwise it will compare with a not terminated string.", "False"],
]);
entry.add(group);
var groupId = "14";
var category = new Category("trigonometry", " ", "category" + groupId);
var menuItem = new MenuItem("trigonometry", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("trigonometry/cosine", "Calculates the cosine of an angle.", [
["IN", "float", "Angle in radians."],
],[
["OUT", "float", "Cosine of angle."],
],[
]);
entry.add(group);
var entry = new Entry("trigonometry/degrees-to-radian", "Convert degrees to radians.", [
["IN", "float", "Angle in degrees."],
],[
["OUT", "float", "Angle in radian."],
],[
]);
entry.add(group);
var entry = new Entry("trigonometry/radian-to-degrees", "Convert radians to degrees.", [
["IN", "float", "Angle in radians."],
],[
["OUT", "float", "Angle in degrees."],
],[
]);
entry.add(group);
var entry = new Entry("trigonometry/sine", "Calculates the sine of an angle.", [
["IN", "float", "Angle in radians."],
],[
["OUT", "float", "Sine of angle."],
],[
]);
entry.add(group);
var entry = new Entry("trigonometry/tangent", "Calculates the tangent of an angle.", [
["IN", "float", "Angle in radians."],
],[
["OUT", "float", "Tangent of angle."],
],[
]);
entry.add(group);
var groupId = "15";
var category = new Category("aio", " ", "category" + groupId);
var menuItem = new MenuItem("aio", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("aio/reader", "Analog input reader. Default range is 0 - 4095 (12 bits) and can be changed by 'mask' options to support different chip manufacturers.", [
],[
["OUT", "int", "Measured value."],
],[
["pin", "int", "Pin", ""],
["mask", "int", "Valid bits mask. This mask is used to filter the valid bits from the data received from hardware (which is manufacturer dependent), therefore should not be used as a way to change the output range because the mask is applied to the least significant bits.", "{'step': 1, 'max': 'INT32_MAX', 'val': 12, 'min': 'INT32_MIN'}"],
["poll_timeout", "int", "Polling time in milliseconds. This option will take no effect if hardware interruptions for GPIO is supported by the underlying system. Use it if you know that you don't have those interruptions available.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1000, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var groupId = "16";
var category = new Category("evdev", " ", "category" + groupId);
var menuItem = new MenuItem("evdev", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("evdev/boolean", "Provides a boolean packet after an evdev event", [
],[
["OUT", "boolean", "An evdev event happened"],
],[
["ev_code", "int", "The event code to be monitored", ""],
["path", "string", "The event path to be monitored", ""],
["on_press", "boolean", "The event is triggered on press", "True"],
["on_release", "boolean", "The event is triggered on release", "True"],
]);
entry.add(group);
var groupId = "17";
var category = new Category("calamari", " ", "category" + groupId);
var menuItem = new MenuItem("calamari", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("calamari/led", "Calamari PWM Led Output", [
["INTENSITY", "int", "Set PWM led intensity"],
],[
],[
["period", "int", "PWM period", "{'step': 1, 'max': 'INT32_MAX', 'val': 10000, 'min': 'INT32_MIN'}"],
["range", "int", "Range for PWM output.", "{'step': 1, 'max': 10000, 'val': 0, 'min': 0}"],
["address", "int", "Hardware address of the PWN output", ""],
]);
entry.add(group);
var entry = new Entry("calamari/lever", "SPI Lever in Calamari lure", [
["POLL_SIGNAL", "any", "Signal the SPI chip that a read must be performed"],
],[
["OUT", "int", "Current value queried from SPI chip"],
],[
["poll_interval", "int", "Intervel between polling the SPI chip in the lure.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["range", "int", "The range value. Used to convert the output.", "{'step': 1, 'max': 1023, 'val': 0, 'min': 0}"],
["bus", "int", "SPI bus.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["chip_select", "int", "SPI chip select.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("calamari/7seg", "Receives packages with values to be displayed on Calamari's 7 segments display", [
["SEGMENTS", "byte", "Define segments to be on and off."],
["VALUE", "int", "Set value to be displayed."],
],[
],[
["clock_pin", "int", "CLOCK GPIO pin", ""],
["clear_pin", "int", "CLEAR GPIO pin", ""],
["data_pin", "int", "DATA GPIO pin", ""],
["latch_pin", "int", "LATCH GPIO pin", ""],
]);
entry.add(group);
var entry = new Entry("calamari/rgb-led", "Receives packets indicating the color of Calamari's RGB LED", [
["RED", "boolean", "Turn red led ON/OFF"],
["GREEN", "boolean", "Turn green led ON/OFF"],
["BLUE", "boolean", "Turn blue led ON/OFF"],
],[
],[
["red_pin", "int", "Red LED GPIO pin", ""],
["green_pin", "int", "Green LED GPIO pin", ""],
["blue_pin", "int", "Blue LED GPIO pin", ""],
]);
entry.add(group);
var groupId = "18";
var category = new Category("app", " ", "category" + groupId);
var menuItem = new MenuItem("app", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("app/argc-argv", "Send command line arguments.", [
["IN", "int", "Argument index."],
],[
["OUT", "string", "Argument at position defined by packet received on port 'IN'."],
["ARGC", "int", "Number of arguments."],
],[
]);
entry.add(group);
var entry = new Entry("app/argv", "Send command line argument at specific position.", [
],[
["OUT", "string", "Command line argument at position defined by option 'index'."],
],[
["index", "int", "Argument position.", ""],
]);
entry.add(group);
var entry = new Entry("app/quit", "Quit the app.", [
["QUIT", "any", "Just quit with success code (0)."],
["CODE", "int", "Quit with code received by packet."],
["ERROR", "error", "Quit with error received by packet."],
],[
],[
]);
entry.add(group);
var groupId = "19";
var category = new Category("process", " ", "category" + groupId);
var menuItem = new MenuItem("process", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("process/stdin", "Current Process STDIN", [
],[
["OUT", "blob", "Binary data chunks (blobs) read. This is not buffered and no extra processing is done, you get what arrived on stdin, as it arrived."],
["CLOSED", "boolean", "True if STDIN is closed"],
],[
]);
entry.add(group);
var entry = new Entry("process/stdout", "Current Process STDOUT", [
["IN", "blob", "Binary data chunks (blobs) read. No extra processing is done, what arrived is written in stdout."],
],[
["CLOSED", "boolean", "True if STDOUT is closed"],
],[
]);
entry.add(group);
var entry = new Entry("process/stderr", "Current Process STDERR", [
["IN", "blob", "Binary data chunks (blobs) read. No extra processing is done, what arrived is written in stderr."],
],[
["CLOSED", "boolean", "True if STDERR is closed"],
],[
]);
entry.add(group);
var entry = new Entry("process/subprocess", "Spawn and monitor a subprocess", [
["START", "any", "Start the child process"],
["STOP", "any", "Stop the child process sending SIGTERM"],
["SIGNAL", "int", "Send the specified signal to the child process"],
["STDIN", "blob", "Data chunk that will be passed to the subprocess's stdin."],
],[
["STATUS", "int", "It will delivery a packet when the child process stops or terminates containing its exit code, similar to waitpid(2)."],
["STDOUT", "blob", "Binary data chunks (blobs) read. This is not buffered and no extra processing is done, you get what arrived from subprocess's stdout, as it arrived."],
["STDERR", "blob", "Binary data chunks (blobs) read. This is not buffered and no extra processing is done, you get what arrived from subprocess's stderr, as it arrived."],
["PID", "int", "Send the pid of the child process."],
],[
["command", "string", "The command that will be executed", ""],
["start", "boolean", "Select if the process should automatically start (true) or should start only after a packet come into the START port", "True"],
]);
entry.add(group);
var groupId = "20";
var category = new Category("udev", " ", "category" + groupId);
var menuItem = new MenuItem("udev", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("udev/boolean", "Provides boolean packets after a device attach or dettach", [
],[
["OUT", "boolean", "A boolean packet when udev changes. If it's attached true, otherwise false."],
],[
["address", "string", "The device's syspath that should be monitored", ""],
]);
entry.add(group);
var groupId = "21";
var category = new Category("piezo-speaker", " ", "category" + groupId);
var menuItem = new MenuItem("piezo-speaker", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("piezo-speaker/sound", "Receives string packages (or load-time configurations) with tunes to be played by a piezo buzzer/speaker over PWM", [
["TUNE", "string", "The tablature string to play on the node. The syntax for it is <note_array|beats_array|base_tempo_in_us>, as in 'ccggaa|111122|300' -- that plays do do sol sol la la in such a way that the first four notes last 300 ms and the last two hold for 600 ms. Possible individual notes are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'C', and beats can only be on the 1-9 range."],
["ENABLED", "boolean", "Start/stop buzzing"],
],[
],[
["tune", "string", "Pre-set tune to buzz with", ""],
["pin", "int", "PWM pin number", ""],
["chip", "int", "PWM chip number", ""],
["loop", "boolean", "Whether to loop indefinetely on the input tune", "True"],
]);
entry.add(group);
var groupId = "22";
var category = new Category("platform", " ", "category" + groupId);
var menuItem = new MenuItem("platform", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("platform", "Platform State", [
["TRIGGER", "any", "Triggers emission of current state."],
],[
["READY", "boolean", "True if platform is ready."],
],[
]);
entry.add(group);
var entry = new Entry("platform-service", "Platform Service State", [
["TRIGGER", "any", "Triggers emission of current service state."],
["START", "any", "Starts service when receives a signal"],
["STOP", "any", "Stops service when receives a signal"],
],[
["ACTIVE", "boolean", "True if platform service is active."],
],[
["service_name", "string", "the platform service name", ""],
]);
entry.add(group);
var groupId = "23";
var category = new Category("float", " ", "category" + groupId);
var menuItem = new MenuItem("float", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("float/addition", "Arithmetic addition operation with floats", [
["OPERAND", "float", "Thirty two ports for addition operation. Indexed from 0 to 31."],
],[
["OUT", "float", "Sum of values received on ports OPERAND[0] to OPERAND[31]."],
],[
]);
entry.add(group);
var entry = new Entry("float/division", "Arithmetic division operation with floats", [
["DIVIDEND", "float", "Recieves dividend value."],
["DIVISOR", "float", "Receives divisor value."],
],[
["OUT", "float", "Quotient from the division of DIVIDEND by DIVISOR."],
],[
]);
entry.add(group);
var entry = new Entry("float/modulo", "Arithmetic modulo operation with floats", [
["DIVIDEND", "float", "First port of modulo operation."],
["DIVISOR", "float", "Second port of modulo operation."],
],[
["OUT", "float", "Remainder from the division of DIVIDEND by DIVISOR."],
],[
]);
entry.add(group);
var entry = new Entry("float/multiplication", "Arithmetic multiplication operation with floats", [
["OPERAND", "float", "Thirty two ports for multiplication operation. Indexed from 0 to 31."],
],[
["OUT", "float", "Product of values received on ports OPERAND[0] to OPERAND[31]."],
],[
]);
entry.add(group);
var entry = new Entry("float/subtraction", "Arithmetic subtraction operation with floats", [
["MINUEND", "float", "Receives minuend value."],
["SUBTRAHEND", "float", "Receives subtrahend value."],
],[
["OUT", "float", "Difference of values received on ports MINUEND and SUBTRAHEND."],
],[
]);
entry.add(group);
var entry = new Entry("float/abs", "Calculates absolute value of a number.", [
["IN", "float", "Input number."],
],[
["OUT", "float", "Number's absolute value."],
],[
]);
entry.add(group);
var entry = new Entry("float/constrain", "Constrain value to it's range", [
["IN", "float", "Value to be constrained."],
],[
["OUT", "float", "Value constrained considering range"],
],[
["range", "float", "Range values (min, max, step). Used only if use_input_range is disabled.", "{'step': 'DBL_MIN', 'max': 1023, 'val': 0.0, 'min': 0}"],
["use_input_range", "boolean", "Use min, max and step values from package instead of options min, max and step. It's useful if you need to convert from many different sources to the same range and all of them inform these values correctly in each package.", "True"],
]);
entry.add(group);
var entry = new Entry("float/ln", "Calculates the natural logarithm of an input value.", [
["IN", "float", "Number to have natural logarithm calculated."],
],[
["OUT", "float", "The result of the natural logarithm operation."],
],[
]);
entry.add(group);
var entry = new Entry("float/map", "Map values to different range", [
["IN", "float", "Value to be converted."],
],[
["OUT", "float", "Value mapped considering input and output ranges"],
],[
["input_range", "float", "Input's range. Used only if use_input_range is disabled.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 0.0, 'min': '-DBL_MAX'}"],
["output_range", "float", "Output's range.", ""],
["use_input_range", "boolean", "Use min and max values from input package instead of option input_range. It's useful if you need to convert from many different sources to the same range and all of them inform these values correctly in each package.", "True"],
]);
entry.add(group);
var entry = new Entry("float/max", "Float Max", [
["IN", "float", "Two ports for max operation. Indexed from 0 to 1."],
],[
["OUT", "float", "Maximum value between IN[0] and IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/min", "Float Min", [
["IN", "float", "Two ports for min operation. Indexed from 0 to 1."],
],[
["OUT", "float", "Minimum value between IN[0] and IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/pow", "Calculates the value of a number raised to a power.", [
["BASE", "float", "Number to be raised."],
["EXPONENT", "float", "The power to which the base is raised."],
],[
["OUT", "float", "The result of the exponentiation."],
],[
]);
entry.add(group);
var entry = new Entry("float/sqrt", "Calculates the square root of a number.", [
["IN", "float", "Input number."],
],[
["OUT", "float", "Number's square root."],
],[
]);
entry.add(group);
var entry = new Entry("float/equal", "Check if an float is equal to other.", [
["IN", "float", "Two ports for equal comparison operation. Indexed from 0 to 1."],
],[
["OUT", "boolean", "True if value received on port IN[0] is equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/greater-or-equal", "Check if an float is greater than or equal to other.", [
["IN", "float", "Two ports for greater-or-equal comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is greater than or equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/greater", "Check if an float is greater than other.", [
["IN", "float", "Two ports for greater comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is greater than value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/less-or-equal", "Check if an float is less than or equal to other.", [
["IN", "float", "Two ports for less-or-equal comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is less than or equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/less", "Check if an float is less than other.", [
["IN", "float", "Two ports for less comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is less than value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/not-equal", "Check if an float is different from other.", [
["IN", "float", "Two ports for not-equal comparison operation. Indexed from 0 to 1"],
],[
["OUT", "boolean", "True if value received on port IN[0] is different from value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/filter", "Filter floats in range", [
["IN", "float", "Data input port."],
],[
["OUT", "float", "Outputs the same variable as the input if it's in range, nothing otherwise."],
],[
["min", "float", "Minimum value (inclusive)", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': '-DBL_MAX', 'min': '-DBL_MAX'}"],
["max", "float", "Maximum value (inclusive)", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 'DBL_MAX', 'min': '-DBL_MAX'}"],
["range_override", "boolean", "if true, the packet irange will have it's min and max changed to the min and max of this node.", "False"],
]);
entry.add(group);
var entry = new Entry("wave-generator/trapezoidal", "A waves generator node that, after each input tick, generates the next value of its defined function on its output port. That function is defined by the various options members it's got, and has the form that goes from a minimum to an maximum value. When at those two extreme values, it may hold (for a pulse or more) on them, before resuming the increment/decrement steps. Thus, it is capable of producing trapezoidal/triangular/sawtooth/square waves. This node won't send any initial packets after port connections are made on its output port solely -- it needs an explicit 'pulse' on its input port to produce packets.", [
["TICK", "any", "Iterate to next generator's function value, outputting a packet."],
],[
["OUT", "float", "The generator's current function value. This port won't send any initial packets after a connection is made. The node expects an explicit 'pulse' on its input port to produce packets."],
],[
["ticks_inc", "int", "In how many function iterations (ticks) it should go from max to min values. The value must be greater than or equal to 1 (which means go from max to min instantly). With this value, the node will calculate the 'increasing step' of the function for you.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
["max", "float", "The maximum value of the wave. This must be greater than min.", ""],
["ticks_dec", "int", "In how many function iterations (ticks) it should go from min to max values. The value must be greater than or equal to 1 (which means go from min to max instantly). With this value, the node will calculate the 'increasing step' of the function for you.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
["min", "float", "The minimum value of the wave. This must be less than max.", ""],
["tick_start", "int", "The starting point of the wave, in ticks (must be greater or equal to 0). Zero means to start at min value, when no ticks have happened yet. Use this to shift the starting point and overwrite the default behavior.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["ticks_at_max", "int", "The number of (extra) input ticks the wave will hold its output at max value when it reaches it. The value must be greater than or equal to 0.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["ticks_at_min", "int", "The number of (extra) input ticks the wave will hold its output at min value when it reaches it. The value must be greater than or equal to 0.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("wave-generator/sinusoidal", "A node that, after each input tick, generates the next value of the sine function on its output port. With fine tuning of it tick_start option, the cosine function can be achieved as well. A multiplier value can be supplied for the original [-1.0, 1.0] range, too. This node won't send any initial packets after port connections are made on its output port solely -- it needs an explicit 'pulse' on its input port to produce packets.", [
["TICK", "any", "Iterate to next generator's function value, outputting a packet."],
],[
["OUT", "float", "The generator's current function value. This port won't send any initial packets after a connection is made. The node expects an explicit 'pulse' on its input port to produce packets."],
],[
["ticks_per_period", "int", "In how many function iterations (ticks) it should go from the starting to the ending value of each function period (AKA function's resolution). The value must be greater than or equal to 1 (which means go from start to end in one step only), but note that waves very small values for this option tend to be useless.", ""],
["amplitude", "float", "The sine wave's amplitude. This must be a positive number, which will multiply the values in the pristine [-1.0, 1.0] range.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 1.0, 'min': '-DBL_MAX'}"],
["tick_start", "int", "The starting point of the wave, in ticks (must be greater or equal to 0). Zero means to start at the beginning of the sive wave, when no ticks have happened yet. Use this to shift the starting point and overwrite the default behavior.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("float/classify", "Classifies input float according to one of float classifications: Not a Number, Infinite, Zero, Subnormal or Normal. It has OUT ports for each classification and sends input float to its classification OUT port.", [
["IN", "float", "Float to be classified."],
],[
["NAN", "float", "If input is NaN, it will go through this port."],
["INFINITE", "float", "If input is Infinite (either positive or negative), it will go through this port."],
["ZERO", "float", "If input is Zero, it will go through this port."],
["SUBNORMAL", "float", "If input is Subnormal, it will go through this port."],
["NORMAL", "float", "If input is Normal, it will go through this port."],
],[
]);
entry.add(group);
var groupId = "24";
var category = new Category("network", " ", "category" + groupId);
var menuItem = new MenuItem("network", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("network/boolean", "Provides boolean packets after connect or disconnect from network", [
],[
["OUT", "boolean", "A boolean packet when network changes. If it's connect true, otherwise false."],
],[
["address", "string", "Which interface should be monitored (can be a regexp)", ""],
]);
entry.add(group);
var groupId = "25";
var category = new Category("filter-repeated", " ", "category" + groupId);
var menuItem = new MenuItem("filter-repeated", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("filter-repeated/boolean", "Filter repeated boolean packets.", [
["IN", "boolean", "Where to receive the boolean packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "boolean", "Filtered boolean packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/byte", "Filter repeated byte packets.", [
["IN", "byte", "Where to receive the byte packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "byte", "Filtered byte packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/error", "Filter repeated error packets.", [
["IN", "error", "Where to receive the error packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded. They're forwared via 'ERROR' port."],
],[
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/float", "Filter repeated float packets.", [
["IN", "float", "Where to receive the float packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "float", "Filtered float packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/int", "Filter repeated int packets.", [
["IN", "int", "Where to receive the int packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "int", "Filtered int packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/rgb", "Filter repeated rgb packets.", [
["IN", "rgb", "Where to receive the rgb packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "rgb", "Filtered rgb packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/direction-vector", "Filter repeated direction vector packets.", [
["IN", "direction-vector", "Where to receive the direction vector packet to be filtered. If the packet is equal to the previously received one, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "direction-vector", "Filtered direction vector packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/string", "Filter repeated string packets.", [
["IN", "string", "Where to receive the string packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "string", "Filtered string packets."],
],[
]);
entry.add(group);
var groupId = "26";
var category = new Category("grove", " ", "category" + groupId);
var menuItem = new MenuItem("grove", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("grove/temperature-sensor", "Gets sensor temperature in Celsius, Fahrenheit and Kelvin. Conversion to Kelvin is done using: 1/(log(((i-r)*Rc/r)/Rt)/B + 1/T - where i is input range, r is raw sensor value, Rc is potential divider resistor resitance, Rt is thermistor resistance, B is thermistor constant and T is thermistor reference temperature. Celsius and Fahrenheit values are simply derived from Kelvin value.", [
],[
["CELSIUS", "float", "Measured temperature in Celsius."],
["FAHRENHEIT", "float", "Measured temperature in Fahrenheit."],
["KELVIN", "float", "Measured temperature in Kelvin."],
["RAW", "int", "Raw measured temperature."],
],[
["pin", "int", "Pin", "{'step': 1, 'max': 'INT32_MAX', 'val': 2, 'min': 'INT32_MIN'}"],
["mask", "int", "Valid bits mask. This mask is used to filter the valid bits from the data received from hardware (which is manufacturer dependent), therefore should not be used as a way to change the output range because the mask is applied to the least significant bits.", "{'step': 1, 'max': 'INT32_MAX', 'val': 12, 'min': 'INT32_MIN'}"],
["poll_timeout", "int", "Polling time in milliseconds. This option will take no effect if hardware interruptions for GPIO is supported by the underlying system. Use it if you know that you don't have those interruptions available.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1000, 'min': 'INT32_MIN'}"],
["thermistor_constant", "int", "Thermistor constant", "{'step': 1, 'max': 'INT32_MAX', 'val': 3975, 'min': 'INT32_MIN'}"],
["resistance", "int", "Potential divider resistance", "{'step': 1, 'max': 'INT32_MAX', 'val': 10000, 'min': 'INT32_MIN'}"],
["reference_temperature", "float", "Thermistor reference temperature", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 298.15, 'min': '-DBL_MAX'}"],
["thermistor_resistance", "int", "Thermistor reference resistance", "{'step': 1, 'max': 'INT32_MAX', 'val': 10000, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("grove/light-sensor", "Get light sensor readings in Lux. However, it should be noted that this sensor is not precise, so the Lux readings are a rough estimation based on Grove Starter Kit booklet table, which relates raw sensor readings to Lux.", [
],[
["LUX", "float", "Measured illuminance in Lux (approximately)."],
["RAW", "int", "Raw measured illuminance."],
],[
["pin", "int", "Pin", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
["mask", "int", "Valid bits mask. This mask is used to filter the valid bits from the data received from hardware (which is manufacturer dependent), therefore should not be used as a way to change the output range because the mask is applied to the least significant bits.", "{'step': 1, 'max': 'INT32_MAX', 'val': 12, 'min': 'INT32_MIN'}"],
["poll_timeout", "int", "Polling time in milliseconds. This option will take no effect if hardware interruptions for GPIO is supported by the underlying system. Use it if you know that you don't have those interruptions available.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1000, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("grove/rotary-sensor", "Get rotary sensor reading in degrees and radians.", [
],[
["DEG", "float", "Measured rotation in degrees."],
["RAD", "float", "Measured rotation in radians."],
["RAW", "int", "Raw measured rotation."],
],[
["pin", "int", "Pin", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["mask", "int", "Valid bits mask. This mask is used to filter the valid bits from the data received from hardware (which is manufacturer dependent), therefore should not be used as a way to change the output range because the mask is applied to the least significant bits.", "{'step': 1, 'max': 'INT32_MAX', 'val': 12, 'min': 'INT32_MIN'}"],
["poll_timeout", "int", "Polling time in milliseconds. This option will take no effect if hardware interruptions for GPIO is supported by the underlying system. Use it if you know that you don't have those interruptions available.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1000, 'min': 'INT32_MIN'}"],
["angular_range", "int", "Angular range", "{'step': 1, 'max': 'INT32_MAX', 'val': 300, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("grove/lcd-string", "LCD grove controller (JHD131M1 model) for simple string displaying and backlight color setting. It uses two I2C addresses, one to control an HD44780 based display and one for RGB backlight. Display matrix is 16x2.", [
["IN", "string", "Set string to be displayed. If it's bigger than 16 characters, it breaks it to the second line. If it's bigger than 32 (what fits on the two display lines), it'll be cropped to this length."],
["COLOR", "rgb", "Set display's backlight color."],
],[
],[
]);
entry.add(group);
var entry = new Entry("grove/lcd-char", "LCD grove controller (JHD131M1 model) for custom character/cursor manipulation and backlight color setting. It uses two I2C addresses, one to control an HD44780 based display and one for RGB backlight. Display matrix is 16x2.", [
["AUTO_SCROLL", "boolean", "Set whether auto-scrolling is on or off. After it's set to on, the cursor position is held static until one sets it off again (or changes it explicitly)."],
["LEFT_TO_RIGHT", "boolean", "Set character entry direction to be left-to-right (true) or right-to-left (false)."],
["COLOR", "rgb", "Set display's backlight color."],
["COL", "int", "Set display's current column. Valid range is 0-16 (16 is a virtual position useful when writing on the last column in right-to-left mode)."],
["ROW", "int", "Set display's current row. Valid range is 0-1."],
["BLINK_CURSOR", "boolean", "Set whether the display's blinking cursor is on (true) or off (false)."],
["UNDERLINE_CURSOR", "boolean", "Set whether the display's underline cursor is on (true) or off (false)."],
["DISPLAY_ON", "boolean", "Set whether the display is on (true) or not (false). Naturally, it starts on by default."],
["PUT_CHAR", "byte", "Write given character at display's current row/column and advance them one position. The column will raise or lower depending on the entry direction, and no wrapping will occur -- if either top-left or bottom-right of the screen is hit, further char writes will update those limit cells until one changes the cursor position explicitly."],
["PUT_STRING", "string", "Write a sequence of characters at display's current row/column and advance the cursor's position. The cursor's position will change differently depending on the entry direction, and, if either top-left or bottom-right of the screen is hit, the string will be cropped at that point."],
["SCROLL_RIGHT", "any", "Shift/scroll right the whole display by one column, keeping the char cell states (lcd's RAM state) as it was. Thus, a subsequent shift left will bring the display to what it looked like before the first shift."],
["SCROLL_LEFT", "any", "Shift/scroll left the whole display by one column, keeping the char cell states (lcd's RAM state) as it was. Thus, a subsequent shift left will bring the display to what it looked like before the first shift."],
["CLEAR", "any", "Clear the whole display, also resetting cursor to the top-left position."],
],[
],[
["init_col", "int", "Initial column of the cursor.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["init_row", "int", "Initial row of the cursor.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["ltr", "boolean", "Whether to start on left-to-right (true) or right-to-left (false) cursor advancing.", "True"],
["blink_cursor", "boolean", "Set whether the display's blinking cursor is on (true) or off (false).", "False"],
["underline_cursor", "boolean", "Set whether the display's underline cursor is on (true) or off (false).", "False"],
["auto_scroll", "boolean", "Whether to start on auto scroll mode (true) or not (false).", "False"],
["color", "rgb", "Initial background color.", "{'red': 255, 'green_max': 255, 'blue': 255, 'green': 255, 'blue_max': 255, 'red_max': 255}"],
]);
entry.add(group);
var groupId = "27";
var category = new Category("gyroscope", " ", "category" + groupId);
var menuItem = new MenuItem("gyroscope", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("gyroscope/l3g4200d", "L3G4200D gyroscope input node, meant for i2c reading primitives testing. After each tick in its TICK port, a new reading is output on each of its output ports.", [
["TICK", "any", "Packets sent in here will trigger a gyroscope reading and produce packets on each of the the output ports."],
],[
["OUT", "direction-vector", "Angular speed in all X/Y/Z axes, in the selected output unit"],
],[
["i2c_bus", "int", "I2C bus number", ""],
["output_radians", "boolean", "Output in rad/s, instead of deg/s", "False"],
]);
entry.add(group);
var groupId = "28";
var category = new Category("accelerometer", " ", "category" + groupId);
var menuItem = new MenuItem("accelerometer", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("accelerometer/adxl345", "ADXL345 accelerometer input node, meant for i2c reading primitives testing. After each tick in its TICK port, a new reading is output on each of its output ports.", [
["TICK", "any", "Packets sent in here will trigger a accelerometer reading and produce packets on each of the the output ports."],
],[
["OUT", "direction-vector", "Acceleration in all X/Y/Z axes, in m/(s*s)"],
],[
["i2c_bus", "int", "I2C bus number", ""],
]);
entry.add(group);
var groupId = "29";
var category = new Category("file", " ", "category" + groupId);
var menuItem = new MenuItem("file", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("file/reader", "Reads a file from disk and dispatches on output port as a blob", [
["PATH", "string", "A string containing the file path."],
],[
["OUT", "blob", "A blob containing the file contents and its size."],
],[
["path", "string", "file name to read.", "None"],
]);
entry.add(group);
var entry = new Entry("file/writer", "Writes a file to disk", [
["PATH", "string", "A string containing the file path."],
["PERMISSIONS", "int", "file permissions in POSIX mode such as 0644."],
["IN", "blob", "A blob containing the file contents."],
],[
["BUSY", "boolean", "True if it's busy writing the file to disk."],
["SIZE", "int", "Bytes already written to disk."],
["DONE", "int", "Total bytes to write to disk."],
],[
["path", "string", "file name to write.", "None"],
["permissions", "int", "file permissions in POSIX mode such as 0644.", "{'step': 1, 'max': 'INT32_MAX', 'val': 420, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var groupId = "30";
var category = new Category("timer", " ", "category" + groupId);
var menuItem = new MenuItem("timer", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("timer", "Provides an empty packet on a timely manner", [
["RESET", "any", "Resets the timer without triggering a packet in the current iteration."],
["INTERVAL", "int", "Set the timer's tick interval in milliseconds."],
["ENABLED", "boolean", "Enables or disables the timer, based on the value of the packet received. When stopped, the timer will cease to emit packets from the OUT port. When enabled again, it does not resume from the point where it was stopped."],
],[
["OUT", "empty", "an empty packet when timer ticks."],
],[
["interval", "int", "Tick interval the timer will start with, in milliseconds.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1000, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var groupId = "31";
var category = new Category("console", " ", "category" + groupId);
var menuItem = new MenuItem("console", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("console", "Console Output", [
["IN", "any", "Prints the packet to console"],
],[
],[
["prefix", "string", "prefix messages with given string.", "None"],
["suffix", "string", "suffix messages with given string.", "None"],
["output_on_stdout", "boolean", "If true will output to stdout, otherwise stderr.", "True"],
["flush", "boolean", "If true will force flush after messages are printed.", "True"],
]);
entry.add(group);
var groupId = "32";
var category = new Category("random", " ", "category" + groupId);
var menuItem = new MenuItem("random", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("random/boolean", "Generate random booleans", [
["SEED", "int", "Seed value. Sequences are repeatable by using the same seed."],
["IN", "any", "Receives a pulse to generate a new random boolean."],
],[
["OUT", "boolean", "Random boolean. Do NOT use it for anything else than test purposes."],
],[
["seed", "int", "Seed value. Sequences are repeatable by using the same seed.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("random/byte", "Generate random bytes", [
["SEED", "int", "Seed value. Sequences are repeatable by using the same seed."],
["IN", "any", "Receives a pulse to generate a new random byte."],
],[
["OUT", "byte", "Random byte. Do NOT use it for anything else than test purposes."],
],[
["seed", "int", "Seed value. Sequences are repeatable by using the same seed.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("random/float", "Generate random float values", [
["SEED", "int", "Seed value. Sequences are repeatable by using the same seed."],
["IN", "any", "Receives a pulse to generate a new random float number."],
],[
["OUT", "float", "Random float value from 0 to INT32_MAX. Do NOT use it for anything else than test purposes."],
],[
["seed", "int", "Seed value. Sequences are repeatable by using the same seed.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("random/int", "Generate random int values", [
["SEED", "int", "Seed value. Sequences are repeatable by using the same seed."],
["IN", "any", "Receives a pulse to generate a new random int number."],
],[
["OUT", "int", "Random int value from 0 to INT32_MAX. Do NOT use it for anything else than test purposes."],
],[
["seed", "int", "Seed value. Sequences are repeatable by using the same seed.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var groupId = "33";
var category = new Category("boolean", " ", "category" + groupId);
var menuItem = new MenuItem("boolean", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("boolean/and", "Boolean And", [
["IN", "boolean", "Two ports for logical operation AND. Indexed from 0 to 1."],
],[
["OUT", "boolean", "True if both IN[0] and IN[1] are true."],
],[
]);
entry.add(group);
var entry = new Entry("boolean/counter", "Receives boolean packets from different connections and returns the number of them in TRUE and FALSE state", [
["IN", "boolean", "Input port"],
],[
["TRUE", "int", "Number of connections in TRUE state"],
["FALSE", "int", "Number of connections in FALSE state"],
],[
]);
entry.add(group);
var entry = new Entry("boolean/filter", "Receives a boolean packet and forwards it through the TRUE or FALSE ports depending on its value.", [
["IN", "boolean", "First port of AND operation."],
],[
["TRUE", "boolean", "Emits a packet with value TRUE when it recives a TRUE value on the IN port"],
["FALSE", "boolean", "Emits a packet with value FALSE when it recives a FALSE value on the IN port"],
],[
]);
entry.add(group);
var entry = new Entry("boolean/not", "Boolean Not", [
["IN", "boolean", "Where to receive the input of NOT operation."],
],[
["OUT", "boolean", "True if 'IN' is false, false otherwise."],
],[
]);
entry.add(group);
var entry = new Entry("boolean/or", "Boolean Or", [
["IN", "boolean", "Two ports for logical operation OR. Indexed from 0 to 1."],
],[
["OUT", "boolean", "True if either IN[0] or IN[1] is true."],
],[
]);
entry.add(group);
var entry = new Entry("boolean/toggle", "Receives an empty packet and toggle the boolean output.", [
["IN", "any", "Where to receive the toggle trigger"],
],[
["OUT", "boolean", "Current toggle state."],
],[
["initial_state", "boolean", "the initial state, defaults to false.", "False"],
]);
entry.add(group);
var entry = new Entry("boolean/xor", "Boolean XOR - exclusive or", [
["IN", "boolean", "Two ports for logical operation XOR. Indexed from 0 to 1."],
],[
["OUT", "boolean", "True whenever both inputs differ (one is true, the other is false). False if IN[0] and IN[1] are the same."],
],[
]);
entry.add(group);
var entry = new Entry("boolean/buffer", "Apply desired computation when buffer fills or timeout happens.", [
["IN", "boolean", "Input port."],
["TIMEOUT", "int", "Receives an int packet to set the timeout time to be used."],
["RESET", "any", "Reset buffer and timer to its initial state."],
],[
["OUT", "boolean", "Output port."],
],[
["samples", "int", "Number of samples that the buffer should hold.", ""],
["timeout", "int", "Timeout time in milliseconds. Default is zero which means that timeout is disabled.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["operation", "string", "Operation to be applied in the buffer elements to compute the output.", "all_true"],
]);
entry.add(group);
var groupId = "34";
var category = new Category("unix-socket", " ", "category" + groupId);
var menuItem = new MenuItem("unix-socket", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("unix-socket/boolean-writer", "Unix socket boolean writer", [
["IN", "boolean", "Unix socket boolean writer, port out."],
],[
],[
["path", "string", "Unix socket path", ""],
["server", "boolean", "Act like a server", "True"],
]);
entry.add(group);
var entry = new Entry("unix-socket/boolean-reader", "Unix socket boolean reader", [
],[
["OUT", "boolean", "Unix socket boolean reader, port out."],
],[
["server", "boolean", "Act like a server", "False"],
["path", "string", "Unix socket path", ""],
]);
entry.add(group);
var entry = new Entry("unix-socket/string-writer", "Unix socket string writer", [
["IN", "string", "Unix socket string writer, port out."],
],[
],[
["path", "string", "Unix socket path", ""],
["server", "boolean", "Act like a server", "True"],
]);
entry.add(group);
var entry = new Entry("unix-socket/string-reader", "Unix socket string reader", [
],[
["OUT", "string", "Unix socket string reader, port out."],
],[
["server", "boolean", "Act like a server", "False"],
["path", "string", "Unix socket path", ""],
]);
entry.add(group);
var entry = new Entry("unix-socket/rgb-writer", "Unix socket rgb writer", [
["IN", "rgb", "Unix socket rgb writer, port out."],
],[
],[
["path", "string", "Unix socket path", ""],
["server", "boolean", "Act like a server", "True"],
]);
entry.add(group);
var entry = new Entry("unix-socket/rgb-reader", "Unix socket rgb reader", [
],[
["OUT", "rgb", "Unix socket rgb reader, port out."],
],[
["server", "boolean", "Act like a server", "False"],
["path", "string", "Unix socket path", ""],
]);
entry.add(group);
var entry = new Entry("unix-socket/direction-vector-writer", "Unix socket direction vector writer", [
["IN", "direction-vector", "Unix socket direction vector writer, input port."],
],[
],[
["path", "string", "Unix socket path", ""],
["server", "boolean", "Act like a server", "True"],
]);
entry.add(group);
var entry = new Entry("unix-socket/direction-vector-reader", "Unix socket direction_vector reader", [
],[
["OUT", "direction-vector", "Unix socket direction vector reader, oupput port."],
],[
["server", "boolean", "Act like a server", "False"],
["path", "string", "Unix socket path", ""],
]);
entry.add(group);
var entry = new Entry("unix-socket/byte-writer", "Unix socket byte writer", [
["IN", "byte", "Unix socket byte writer, port out."],
],[
],[
["path", "string", "Unix socket path", ""],
["server", "boolean", "Act like a server", "True"],
]);
entry.add(group);
var entry = new Entry("unix-socket/byte-reader", "Unix socket byte reader", [
],[
["OUT", "byte", "Unix socket byte reader, port out."],
],[
["server", "boolean", "Act like a server", "False"],
["path", "string", "Unix socket path", ""],
]);
entry.add(group);
var entry = new Entry("unix-socket/int-writer", "Unix socket int writer", [
["IN", "int", "Unix socket int writer, port out."],
],[
],[
["path", "string", "Unix socket path", ""],
["server", "boolean", "Act like a server", "True"],
]);
entry.add(group);
var entry = new Entry("unix-socket/int-reader", "Unix socket int reader", [
],[
["OUT", "int", "Unix socket int reader, port out."],
],[
["server", "boolean", "Act like a server", "False"],
["path", "string", "Unix socket path", ""],
]);
entry.add(group);
var entry = new Entry("unix-socket/float-writer", "Unix socket float writer", [
["IN", "float", "Unix socket float writer, port out."],
],[
],[
["path", "string", "Unix socket path", ""],
["server", "boolean", "Act like a server", "True"],
]);
entry.add(group);
var entry = new Entry("unix-socket/float-reader", "Unix socket float reader", [
],[
["OUT", "float", "Unix socket float reader, port out."],
],[
["server", "boolean", "Act like a server", "False"],
["path", "string", "Unix socket path", ""],
]);
entry.add(group);
var groupId = "35";
var category = new Category("gpio", " ", "category" + groupId);
var menuItem = new MenuItem("gpio", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("gpio/reader", "GPIO reader", [
],[
["OUT", "boolean", "GPIO reader, port out"],
],[
["pin", "int", "GPIO pin", ""],
["poll_timeout", "int", "Polling time", "{'step': 1, 'max': 'INT32_MAX', 'val': 1000, 'min': 'INT32_MIN'}"],
["active_low", "boolean", "Is active low", "False"],
["edge_rising", "boolean", "Is edge rising", "False"],
["edge_falling", "boolean", "Is edge falling", "False"],
["pull", "string", "up for pull up, down for pull down, none for no pull", "none"],
]);
entry.add(group);
var entry = new Entry("gpio/writer", "GPIO writer", [
["IN", "boolean", "GPIO writer, port in"],
],[
],[
["pin", "int", "GPIO pin", ""],
["active_low", "boolean", "Is active low", "False"],
]);
entry.add(group);
var groupId = "36";
var category = new Category("wallclock", " ", "category" + groupId);
var menuItem = new MenuItem("wallclock", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("wallclock/hour", "Provides int packets on a timely manner (after each system clock hour changes)", [
],[
["OUT", "int", "An int range packet when wallclock hour ticks."],
],[
]);
entry.add(group);
var entry = new Entry("wallclock/minute", "Provides int packets on a timely manner (after each system clock minute changes)", [
],[
["OUT", "int", "An int range packet when wallclock minute ticks."],
],[
]);
entry.add(group);
var entry = new Entry("wallclock/monthday", "Provides int packets on a timely manner (after each system clock month day changes)", [
],[
["OUT", "int", "An int range packet when wallclock month day ticks."],
],[
]);
entry.add(group);
var entry = new Entry("wallclock/second", "Provides int packets on a timely manner (after each system clock second changes)", [
],[
["OUT", "int", "An int range packet when wallclock second ticks."],
],[
]);
entry.add(group);
var entry = new Entry("wallclock/weekday", "Provides int packets on a timely manner (after each system clock week day changes)", [
],[
["OUT", "int", "An int range packet when wallclock week day ticks."],
],[
]);
entry.add(group);
var groupId = "37";
var category = new Category("builtin", " ", "category" + groupId);
var menuItem = new MenuItem("builtin", "group" + groupId);

group = document.createElement("div");
group.setAttribute("class","Group");
group.setAttribute("id","group" + groupId);
document.getElementById("content").appendChild(group);
createdGroups.push("#group" + groupId);

var entry = new Entry("int/max", "Int Max", [
["IN", "int", "Two ports for max operation. Indexed from 0 to 1."],
],[
["OUT", "int", "Maximum value between IN[0] and IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/min", "Int Min", [
["IN", "int", "Two ports for min operation. Indexed from 0 to 1."],
],[
["OUT", "int", "Minimum value between IN[0] and IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/abs", "Calculates absolute value of a number.", [
["IN", "int", "Input number."],
],[
["OUT", "int", "Number's absolute value."],
],[
]);
entry.add(group);
var entry = new Entry("int/accumulator", "Increment or decrement it's internal value by 'step' whenever a packet is received and outputs the updated value. If the internal value is greater than 'max' after an increment, it's set to min and an empty packet is sent through OVERFLOW port as well, or if it's less than 'min' after a decrement, it's set to 'max' and an empty packet is sent through UNDERFLOW port.", [
["INC", "any", "Increment operation."],
["DEC", "any", "Decrement operation."],
["RESET", "any", "Reset accumulator to its initial state."],
],[
["OUT", "int", "Updated value after an input is processed."],
["OVERFLOW", "empty", "Sends an empty package whenever an overflow happens."],
["UNDERFLOW", "empty", "Sends an empty package whenever an underflow happens."],
],[
["setup_value", "int", "The initial value, range and step to be used in operations. Only positive step values are allowed.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("int/addition", "Arithmetic addition operation with ints", [
["OPERAND", "int", "Thirty two ports for addition operation. Indexed from 0 to 31."],
],[
["OUT", "int", "Sum of values received on ports OPERAND[0] to OPERAND[31]."],
],[
]);
entry.add(group);
var entry = new Entry("int/division", "Arithmetic division operation with ints", [
["DIVIDEND", "int", "Receives dividend value."],
["DIVISOR", "int", "Receives divisor value."],
],[
["OUT", "int", "Quotient from the division of DIVIDEND by DIVISOR."],
],[
]);
entry.add(group);
var entry = new Entry("int/modulo", "Arithmetic modulo operation with ints", [
["DIVIDEND", "int", "Receives dividend value."],
["DIVISOR", "int", "Receives divisor value."],
],[
["OUT", "int", "Remainder from the division of DIVIDEND by DIVISOR."],
],[
]);
entry.add(group);
var entry = new Entry("int/multiplication", "Arithmetic multiplication operation with ints", [
["OPERAND", "int", "Thirty two ports for multiplication operation. Indexed from 0 to 31."],
],[
["OUT", "int", "Product of values received on ports OPERAND[0] and OPERAND[31]."],
],[
]);
entry.add(group);
var entry = new Entry("int/subtraction", "Arithmetic subtraction operation with ints", [
["MINUEND", "int", "Receives minuend value."],
["SUBTRAHEND", "int", "Receives subtrahend value."],
],[
["OUT", "int", "Difference of values received on ports OPERAND[0] to OPERAND[31]."],
],[
]);
entry.add(group);
var entry = new Entry("int/bitwise-and", "Bitwise And", [
["IN", "int", "Two ports for AND operation. Indexed from 0 to 1."],
],[
["OUT", "int", "The result of a bitwise AND between IN[0] and IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("int/bitwise-not", "Bitwise Not", [
["IN", "int", "First port of NOT operation."],
],[
["OUT", "int", "Bitwise NOT of the value received in IN."],
],[
]);
entry.add(group);
var entry = new Entry("int/bitwise-or", "Bitwise Or", [
["IN", "int", "Two ports for OR operation. Indexed from 0 to 1."],
],[
["OUT", "int", "The result of a bitwise OR between IN[0] and IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("int/shift-left", "Bitwise Shift Left", [
["IN", "int", "Value to be shifted"],
["SHIFT", "int", "Number of bits to shift the value in IN (must be less than 32)"],
],[
["OUT", "int", "The value received in IN, shifted SHIFT bits to the left."],
],[
]);
entry.add(group);
var entry = new Entry("int/shift-right", "Bitwise Shift Right", [
["IN", "int", "Value to be shifted"],
["SHIFT", "int", "Number of bits to shift the value in IN (must be less than 32)"],
],[
["OUT", "int", "The value received in IN, shifted SHIFT bits to the right (No sign extension)."],
],[
]);
entry.add(group);
var entry = new Entry("int/bitwise-xor", "Bitwise Xor", [
["IN", "int", "Two ports for XOR operation. Indexed from 0 to 1."],
],[
["OUT", "int", "The result of a bitwise XOR between IN[0] xor IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("int/buffer", "Apply desired computation when buffer fills or timeout happens.", [
["IN", "int", "Input port."],
["TIMEOUT", "int", "Receives an int packet to set the timeout time to be used."],
["RESET", "any", "Reset buffer and timer to its initial state."],
],[
["OUT", "int", "Output port."],
],[
["samples", "int", "Number of samples that the buffer should hold.", "{'step': 1, 'max': 'INT32_MAX', 'val': 4, 'min': 'INT32_MIN'}"],
["timeout", "int", "Timeout time in milliseconds. Default is zero which means that timeout is disabled.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["operation", "string", "Operation to be applied in the buffer elements to compute the output.", "all_true"],
]);
entry.add(group);
var entry = new Entry("int/equal", "Check if an int is equal to other.", [
["IN", "int", "Two ports for equal comparison operation. Indexed from 0 to 1."],
],[
["OUT", "boolean", "True if value received on port IN[0] is equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/greater", "Check if an int is greater than other.", [
["IN", "int", "Two ports for greater comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is greater than value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/greater-or-equal", "Check if an int is greater than or equal to other.", [
["IN", "int", "Two ports for greater-or-equal comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is greater than or equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/less", "Check if an int is less than other.", [
["IN", "int", "Two ports for less comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is less than value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/less-or-equal", "Check if an int is less than or equal to other.", [
["IN", "int", "Two ports for less-or-equal comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is less than or equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/not-equal", "Check if an int is different from other.", [
["IN", "int", "Two ports for not-equal comparison operation. Indexed from 0 to 1"],
],[
["OUT", "boolean", "True if value received on port IN[0] is different from value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("int/constrain", "Constrain value to it's range", [
["IN", "int", "Value to be constrained."],
],[
["OUT", "int", "Value constrained considering range"],
],[
["range", "int", "Range values (min, max, step). Used only if use_input_range is disabled.", "{'step': 1, 'max': 1023, 'val': 0, 'min': 0}"],
["use_input_range", "boolean", "Use min, max and step values from package instead of options min, max and step. It's useful if you need to convert from many different sources to the same range and all of them inform these values correctly in each package.", "True"],
]);
entry.add(group);
var entry = new Entry("int/filter", "Filter ints in range", [
["IN", "int", "Data input port."],
],[
["OUT", "int", "Outputs the same variable as the input if it's in range, nothing otherwise."],
],[
["min", "int", "Minimum value (inclusive)", "{'step': 1, 'max': 'INT32_MAX', 'val': 'INT32_MIN', 'min': 'INT32_MIN'}"],
["max", "int", "Maximum value (inclusive)", "{'step': 1, 'max': 'INT32_MAX', 'val': 'INT32_MAX', 'min': 'INT32_MIN'}"],
["range_override", "boolean", "if true, the packet irange will have it's min and max changed to the min and max of this node.", "False"],
]);
entry.add(group);
var entry = new Entry("int/inrange", "check if value is between a min and max range.", [
["IN", "int", "value that will be checked if its in range or not."],
],[
["OUT", "boolean", "true if IN is in range"],
],[
["range", "int", "maximum range value.", "{'step': 1, 'max': 255, 'val': 0, 'min': -255}"],
]);
entry.add(group);
var entry = new Entry("int/map", "Map values to different range", [
["IN", "int", "Value to be converted."],
],[
["OUT", "int", "Value mapped considering input and output ranges"],
],[
["input_range", "int", "Input's range. Used only if use_input_range is disabled.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["output_range", "int", "Output's range.", ""],
["use_input_range", "boolean", "Use min and max values from input package instead of option input_range. It's useful if you need to convert from many different sources to the same range and all of them inform these values correctly in each package.", "True"],
]);
entry.add(group);
var entry = new Entry("string/compare", "Compare two strings", [
["IN", "string", "Two strings to be compared. Indexed from 0 to 1."],
],[
["OUT", "int", "It returns an integer less than, equal to, or greater than zero if string received on IN[0] is found to be less than, to match, or be greater than string on IN[1]."],
["EQUAL", "boolean", "TRUE if the string received on IN[0] is the same as the string on IN[1]."],
],[
["bytes", "int", "Amount of bytes to be compared between strings. If zero, the whole strings will be compared.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["ignore_case", "boolean", "Ignore case when comparing strings.", "False"],
]);
entry.add(group);
var entry = new Entry("string/concatenate", "Concatenate two strings", [
["IN", "string", "Two strings to be concatenated. Indexed from 0 to 1."],
],[
["OUT", "string", "String IN[0] concatenated to string IN[1]."],
],[
["bytes", "int", "Amount of bytes to be copied from string received on IN[1]. If zero, the whole string will be concatenated to the string received on IN[0]", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["separator", "string", "Separator string to be used between the two concatenated strings. It's set to null by default (no separator).", "None"],
]);
entry.add(group);
var entry = new Entry("string/length", "Calculate the length of a string", [
["IN", "string", "String to be measured."],
],[
["OUT", "int", "Send the string size, the number of bytes excluding terminating null byte. If maxlen is provided, it'll be at most this value."],
],[
["maxlen", "int", "Maximum length to be checked. If a string is greater than that, maxlen value will be sent. If zero, no limit is applied.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("string/split", "Split a string given a separator.", [
["IN", "string", "String to be split."],
["SEPARATOR", "string", "String received on 'IN' port will be split using these delimiter chars."],
["INDEX", "int", "A string can be split in many substrings. This value defines which substring should be sent. It must be non negative."],
],[
["LENGTH", "int", "Number of generated substrings."],
["OUT", "string", "Substring given a separator and an index."],
],[
["index", "int", "A string can be split in many substrings. This value defines which substring should be sent. It must be non negative. It can be overriden by values received on 'INDEX' port.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["separator", "string", "String received on 'IN' port will be split using these delimiters chars. It can be overriden by values received on 'SEPARATOR' port.", " "],
]);
entry.add(group);
var entry = new Entry("constant/boolean", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "boolean", "Constant value, sent only once, when connected to a node."],
],[
["value", "boolean", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/byte", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "byte", "Constant value, sent only once, when connected to a node."],
],[
["value", "byte", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/float", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "float", "Constant value, sent only once, when connected to a node."],
],[
["value", "float", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/empty", "Send an initial empty packet.", [
],[
["OUT", "empty", "A single pulse sent when connected to a node."],
],[
]);
entry.add(group);
var entry = new Entry("constant/int", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "int", "Constant value, sent only once, when connected to a node."],
],[
["value", "int", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/rgb", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "rgb", "Constant value, sent only once, when connected to a node."],
],[
["value", "rgb", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/direction-vector", "Send an initial packet with a constant value set on options.", [
],[
["OUT", "direction-vector", "Constant value, sent only once, when connected to a node."],
],[
["value", "direction-vector", "Value of constant.", ""],
]);
entry.add(group);
var entry = new Entry("constant/string", "Send an initial packet with a string set on options.", [
],[
["OUT", "string", "Constant value, sent only once, when connected to a node."],
],[
["value", "string", "String to be sent when node is connected.", ""],
]);
entry.add(group);
var entry = new Entry("pwm", "PWM", [
["ENABLED", "boolean", "True enables PWM, False disables it"],
["PERIOD", "int", "PWM period, in ns"],
["DUTY_CYCLE", "int", "Duty cycle, in ns"],
],[
],[
["chip", "int", "PWM chip", ""],
["pin", "int", "PWM pin channel", ""],
["enabled", "boolean", "Initial enabled state", "False"],
["inversed_polarity", "boolean", "PWM polarity (normal or inversed)", "False"],
["period", "int", "Initial period", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["duty_cycle", "int", "Initial duty cycle", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("color/luminance-rgb", "Modifies a color changing its luminance.", [
["IN", "int", "Luminance to be applied in the color."],
],[
["OUT", "rgb", "Color with new luminance applied. The value is a multiplication of each component on option and rate between luminance value and its range."],
],[
["color", "rgb", "Initial color, with full luminance. Luminance will vary considering value received on IN port.", ""],
]);
entry.add(group);
var entry = new Entry("byte/bitwise-and", "Bitwise And", [
["IN", "byte", "Two ports for bitwise operation AND. Indexed from 0 to 1."],
],[
["OUT", "byte", "The result of a bitwise AND between IN[0] and IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("byte/bitwise-not", "Bitwise Not", [
["IN", "byte", "First port of NOT operation."],
],[
["OUT", "byte", "Bitwise NOT of the value received in IN."],
],[
]);
entry.add(group);
var entry = new Entry("byte/bitwise-or", "Bitwise Or", [
["IN", "byte", "Two ports for bitwise operation OR. Indexed from 0 to 1."],
],[
["OUT", "byte", "The result of a bitwise OR between IN[0] or IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("byte/shift-left", "Bitwise Shift Left", [
["IN", "byte", "Value to be shifted"],
["SHIFT", "byte", "Number of bits to shift the value in IN (must be less than 8)"],
],[
["OUT", "byte", "The value received in IN, shifted SHIFT bits to the left."],
],[
]);
entry.add(group);
var entry = new Entry("byte/shift-right", "Bitwise Shift Right", [
["IN", "byte", "Value to be shifted"],
["SHIFT", "byte", "Number of bits to shift the value in IN (must be less than 8)"],
],[
["OUT", "byte", "The value received in IN, shifted SHIFT bits to the right (No sign extension)."],
],[
]);
entry.add(group);
var entry = new Entry("byte/bitwise-xor", "Bitwise Xor", [
["IN", "byte", "Two ports for bitwise operation XOR. Indexed from 0 to 1."],
],[
["OUT", "byte", "The result of a bitwise XOR between IN[0] xor IN[1]"],
],[
]);
entry.add(group);
var entry = new Entry("byte/filter", "Filter bytes in range", [
["IN", "byte", "Data input port."],
],[
["OUT", "byte", "Outputs the same variable as the input if it's in range, nothing otherwise."],
],[
["min", "byte", "Minimum value (inclusive)", "0"],
["max", "byte", "Maximum value (inclusive)", "255"],
]);
entry.add(group);
var entry = new Entry("hub/blob", "Forward blob packets.", [
["IN", "blob", "Where to receive the blob packet to be forwarded."],
],[
["OUT", "blob", "Forwarded blob packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/boolean", "Forward boolean packets.", [
["IN", "boolean", "Where to receive the boolean packet to be forwarded."],
],[
["OUT", "boolean", "Forwarded boolean packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/byte", "Forward byte packets.", [
["IN", "byte", "Where to receive the byte packet to be forwarded."],
],[
["OUT", "byte", "Forwarded byte packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/empty", "Forward empty packets.", [
["IN", "any", "Where to receive the packet to be forwarded. Any packet can be received, but they'll be forwarded as empty packets."],
],[
["OUT", "empty", "Forwarded empty packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/error", "Forward error packets.", [
["IN", "error", "Where to receive the error packet to be forwarded. They're forwared via 'ERROR' port."],
],[
],[
]);
entry.add(group);
var entry = new Entry("hub/float", "Forward float packets.", [
["IN", "float", "Where to receive the float packet to be forwarded."],
],[
["OUT", "float", "Forwarded float packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/int", "Forward int packets.", [
["IN", "int", "Where to receive the int packet to be forwarded."],
],[
["OUT", "int", "Forwarded int packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/rgb", "Forward rgb packets.", [
["IN", "rgb", "Where to receive the rgb packet to be forwarded."],
],[
["OUT", "rgb", "Forwarded rgb packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/direction-vector", "Forward direction vector packets.", [
["IN", "direction-vector", "Where to receive the direction vector packet to be forwarded."],
],[
["OUT", "direction-vector", "Forwarded direction_vector packets."],
],[
]);
entry.add(group);
var entry = new Entry("hub/string", "Forward string packets.", [
["IN", "string", "Where to receive the string packet to be forwarded."],
],[
["OUT", "string", "Forwarded string packets."],
],[
]);
entry.add(group);
var entry = new Entry("converter/boolean-to-float", "Receives a boolean packet and convert to float.", [
["IN", "boolean", "Where to receive the boolean value to be converted."],
["FALSE_VALUE", "float", "DRange value of output when input is false."],
["TRUE_VALUE", "float", "DRange value of output when input is true."],
],[
["OUT", "float", "Float with value set on options or via value_set ports."],
],[
["false_value", "float", "DRange value of output when input is false.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 0.0, 'min': '-DBL_MAX'}"],
["true_value", "float", "DRange value of output when input is true.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 1.0, 'min': '-DBL_MAX'}"],
]);
entry.add(group);
var entry = new Entry("converter/boolean-to-byte", "Receives a boolean packet and convert to byte.", [
["IN", "boolean", "Where to receive the boolean value to be converted."],
["FALSE_VALUE", "byte", "Byte value of output when input is false."],
["TRUE_VALUE", "byte", "Byte value of output when input is true."],
],[
["OUT", "byte", "Byte with value set on options or via value_set ports."],
],[
["false_value", "byte", "Byte value of output when input is false.", "0"],
["true_value", "byte", "Byte value of output when input is true.", "1"],
]);
entry.add(group);
var entry = new Entry("converter/boolean-to-empty", "Receives a boolean packet and convert it to empty.", [
["PULSE_IF_TRUE", "boolean", "If received boolean is true generates a pulse."],
["PULSE_IF_FALSE", "boolean", "If received boolean is false generates a pulse."],
],[
["OUT", "empty", "Sends a pulse if boolean values received on each port match expected value."],
],[
]);
entry.add(group);
var entry = new Entry("converter/boolean-to-int", "Receives a boolean packet and convert to int.", [
["IN", "boolean", "Where to receive the boolean value to be converted."],
["FALSE_VALUE", "int", "IRange value of output when input is false."],
["TRUE_VALUE", "int", "IRange value of output when input is true."],
],[
["OUT", "int", "IRange with value set on options or via value_set ports."],
],[
["false_value", "int", "IRange value of output when input is false.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["true_value", "int", "IRange value of output when input is true.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("converter/boolean-to-string", "Receives a boolean packet and convert to string.", [
["IN", "boolean", "Where to receive the boolean value to be converted."],
["FALSE_VALUE", "string", "String to be sent on output when input is false."],
["TRUE_VALUE", "string", "String to be sent on output when input is true."],
],[
["OUT", "string", "Send string defined by option 'true_value' if input is true or by 'false_value' if input is false."],
],[
["false_value", "string", "String sent when input is false.", "False"],
["true_value", "string", "String sent when input is true.", "True"],
]);
entry.add(group);
var entry = new Entry("converter/byte-to-bits", "Receives byte packet and convert to a binary representaion in outputs.", [
["IN", "byte", "Where to receive the byte value to be converted."],
],[
["OUT", "boolean", "Byte turned to bits, index 0 is the least significant, 7 the most"],
],[
]);
entry.add(group);
var entry = new Entry("converter/byte-to-boolean", "Receives a byte packet and convert to boolean.", [
["IN", "byte", "Where to receive the byte value to be converted."],
["TRUE_MAX", "byte", "Defines maximum value of input to set output as true."],
["TRUE_MIN", "byte", "Defines minimum value of input to set output as true."],
],[
["OUT", "boolean", "Send true if input packet value is in range defined by min and max values or false otherwise."],
],[
["true_max", "byte", "Defines maximum value of input to set output as true.", "255"],
["true_min", "byte", "Defines minimum value of input to set output as true.", "1"],
]);
entry.add(group);
var entry = new Entry("converter/byte-to-float", "Receives a byte packet and convert to float.", [
["IN", "byte", "Where to receive the byte value to be converted."],
],[
["OUT", "float", "Byte converted to float."],
],[
]);
entry.add(group);
var entry = new Entry("converter/byte-to-empty", "Receives a byte packet and convert it to empty.", [
["IN", "byte", "Where to receive the byte value to be converted."],
["RANGE_MAX", "byte", "Byte maximum range value that generates a pulse."],
["RANGE_MIN", "byte", "Byte minimum range value that generates a pulse."],
],[
["OUT", "empty", "Send an empty packet when input packet value in range defined by min and max values."],
],[
["range_max", "byte", "Byte maximum value that generates a pulse.", "255"],
["range_min", "byte", "Byte minimum value that generates a pulse.", "1"],
]);
entry.add(group);
var entry = new Entry("converter/byte-to-int", "Receives a byte packet and convert to int.", [
["IN", "byte", "Where to receive the byte value to be converted."],
],[
["OUT", "int", "Byte converted to int."],
],[
]);
entry.add(group);
var entry = new Entry("converter/byte-to-rgb", "Receives byte packets and convert to RGB.", [
["RED", "byte", "Byte value for red component."],
["GREEN", "byte", "Byte value for green component."],
["BLUE", "byte", "Byte value for blue component."],
],[
["OUT", "rgb", "Bytes converted to RGB."],
],[
]);
entry.add(group);
var entry = new Entry("converter/byte-to-direction-vector", "Receives byte packets and convert to direction vector", [
["X", "byte", "Byte value for x component."],
["Y", "byte", "Byte value for y component."],
["Z", "byte", "Byte value for z component."],
],[
["OUT", "direction-vector", "Bytes converted to direction vector."],
],[
]);
entry.add(group);
var entry = new Entry("converter/byte-to-string", "Receives a byte packet and convert to string.", [
["IN", "byte", "Where to receive the byte value to be converted."],
],[
["OUT", "string", "Byte converted to string, prefixed with '0x', as 0x3e."],
],[
]);
entry.add(group);
var entry = new Entry("converter/float-to-boolean", "Receives an float packet and convert to boolean.", [
["IN", "float", "Where to receive the float value to be converted."],
["TRUE_RANGE", "float", "Defines minimum and maximum values of input to set output as true."],
],[
["OUT", "boolean", "Send true if input packet value is in range defined by min and max values or false otherwise."],
],[
["true_range", "float", "Defines minimum and maximum values of input to set output as true.", "{'step': 'DBL_MIN', 'max': 255, 'val': 0.0, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/float-to-byte", "Receives a float packet and convert to byte.", [
["IN", "float", "Where to receive the float value to be converted."],
],[
["OUT", "byte", "Float converted to byte. If float was greater than 255 or less than 0 the converted value will be at these limits."],
],[
]);
entry.add(group);
var entry = new Entry("converter/float-to-empty", "Receives a float packet and convert it to empty.", [
["IN", "float", "Where to receive the float value to be converted."],
["RANGE", "float", "Float range that generates a pulse."],
],[
["OUT", "empty", "Send an empty packet when input packet value is in range defined by min and max values."],
],[
["range", "float", "Float range that generates a pulse.", "{'step': 'DBL_MIN', 'max': 255, 'val': 0.0, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/float-to-int", "Receives a float packet and convert to int.", [
["IN", "float", "Where to receive the float value to be converted."],
],[
["OUT", "int", "Float converted to int. Value, min, max and step are converted."],
],[
]);
entry.add(group);
var entry = new Entry("converter/float-to-rgb", "Receives float packets and convert to RGB.", [
["RED", "float", "Float value for red component."],
["GREEN", "float", "Float value for green component."],
["BLUE", "float", "Float value for blue component."],
],[
["OUT", "rgb", "Float values converted to RGB."],
],[
["red_max", "int", "Max value of red component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["green_max", "int", "Max value of green component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["blue_max", "int", "Max value of blue component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("converter/float-to-direction-vector", "Receives float packets and converts to direction vector ones.", [
["X", "float", "Float value for x component."],
["Y", "float", "Float value for y component."],
["Z", "float", "Float value for z component."],
],[
["OUT", "direction-vector", "Float values converted to direction vector."],
],[
["out_range", "float", "Range of output packet.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 0.0, 'min': '-DBL_MAX'}"],
]);
entry.add(group);
var entry = new Entry("converter/float-to-string", "Receives a float packet and convert to string.", [
["IN", "float", "Where to receive the float value to be converted."],
],[
["OUT", "string", "Float converted to string with 6 digits after decimal-point character."],
],[
]);
entry.add(group);
var entry = new Entry("converter/empty-to-boolean", "Receives an empty packet and convert it to boolean.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "boolean", "Boolean value of output when an empty packet is received."],
],[
["OUT", "boolean", "Boolean defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "boolean", "Boolean value of output when an empty packet is received.", "True"],
]);
entry.add(group);
var entry = new Entry("converter/empty-to-rgb", "Receives an empty packet and convert it to rgb.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "rgb", "RGB value of output when an empty packet is received."],
],[
["OUT", "rgb", "RGB defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "rgb", "RGB value of output when an empty packet is received.", "{'red': 255, 'green_max': 255, 'blue': 255, 'green': 255, 'blue_max': 255, 'red_max': 255}"],
]);
entry.add(group);
var entry = new Entry("converter/empty-to-byte", "Receives an empty packet and convert it to byte.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "byte", "Byte value of output when an empty packet is received."],
],[
["OUT", "byte", "Byte defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "byte", "Byte value of output when an empty packet is received.", "1"],
]);
entry.add(group);
var entry = new Entry("converter/empty-to-float", "Receives an empty packet and convert it to float.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "float", "Float value of output when an empty packet is received."],
],[
["OUT", "float", "Float defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "float", "Float value of output when an empty packet is received.", "{'step': 1, 'max': 1, 'val': 1, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/empty-to-int", "Receives an empty packet and convert it to int.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "int", "Int value of output when an empty packet is received."],
],[
["OUT", "int", "Int defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "int", "Int value of output when an empty packet is received.", "{'step': 1, 'max': 1, 'val': 1, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/empty-to-string", "Receives an empty packet and convert it to string.", [
["IN", "any", "Where to receive the empty packet."],
["OUTPUT_VALUE", "string", "Output string sent when an empty packet is received."],
],[
["OUT", "string", "String defined by OUTPUT_VALUE port or output_value option."],
],[
["output_value", "string", "Output string sent when an empty packet is received.", ""],
]);
entry.add(group);
var entry = new Entry("converter/int-to-boolean", "Receives an int packet and convert to boolean.", [
["IN", "int", "Where to receive the int value to be converted."],
["TRUE_RANGE", "int", "Defines minimum and maximum values of input to set output as true."],
],[
["OUT", "boolean", "Send true if input packet value is in range defined by min and max values or false otherwise."],
],[
["true_range", "int", "Defines minimum and maximum values of input to set output as true.", "{'step': 1, 'max': 255, 'val': 0, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/int-to-byte", "Receives an int packet and convert to byte.", [
["IN", "int", "Where to receive the int value to be converted."],
],[
["OUT", "byte", "Int converted to byte. If int was greater than 255 or less than 0 the converted value will be at these limits."],
],[
]);
entry.add(group);
var entry = new Entry("converter/int-compose", "Receives four bytes and composes them into an int. Any input port with no connections will be treated as a 0 value input.", [
["IN", "byte", "Array of bytes to turn into an int. Index 0 is the least significant, 3 is the most"],
],[
["OUT", "int", "Integer composed from the four input bytes"],
],[
]);
entry.add(group);
var entry = new Entry("converter/int-decompose", "Receives an int packet and decomposes it into four bytes. The received int will be treated as unsigned.", [
["IN", "int", "Where to receive the int value to be decomposed."],
],[
["OUT", "byte", "Int turned to bytes, index 0 is the least significant, 3 the most"],
],[
]);
entry.add(group);
var entry = new Entry("converter/int-to-float", "Receives an int packet and convert to float.", [
["IN", "int", "Where to receive the int value to be converted."],
],[
["OUT", "float", "Int converted to float. Value, min, max and step are converted."],
],[
]);
entry.add(group);
var entry = new Entry("converter/int-to-empty", "Receives an int packet and convert it to empty.", [
["IN", "int", "Where to receive the int value to be converted."],
["RANGE", "int", "Int range that generates a pulse."],
],[
["OUT", "empty", "Send an empty packet when input packet value is in range defined by min and max values."],
],[
["range", "int", "Int range that generates a pulse.", "{'step': 1, 'max': 255, 'val': 0, 'min': 1}"],
]);
entry.add(group);
var entry = new Entry("converter/int-to-rgb", "Receives int packets and convert to RGB.", [
["RED", "int", "Int value for red component."],
["GREEN", "int", "Int value for green component."],
["BLUE", "int", "Int value for blue component."],
],[
["OUT", "rgb", "Int values converted to RGB."],
],[
["red_max", "int", "Max value of red component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["green_max", "int", "Max value of green component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["blue_max", "int", "Max value of blue component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("converter/direction-vector-to-rgb", "Receives direction vector packets and converts to RGB ones.", [
["IN", "direction-vector", "Input for direction vector packets to be converted."],
],[
["OUT", "rgb", "Direction vector values converted to RGB."],
],[
["red_max", "int", "Max value of red component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["green_max", "int", "Max value of green component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
["blue_max", "int", "Max value of blue component. Minimum is set to zero.", "{'step': 1, 'max': 'INT32_MAX', 'val': 255, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("converter/int-to-direction-vector", "Receives int packets and converts a to direction vector one.", [
["X", "int", "Int value for x component."],
["Y", "int", "Int value for y component."],
["Z", "int", "Int value for z component."],
],[
["OUT", "direction-vector", "Int values converted to direction vector."],
],[
["out_range", "float", "Range of output packet.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 0.0, 'min': '-DBL_MAX'}"],
]);
entry.add(group);
var entry = new Entry("converter/int-to-string", "Receives an int packet and convert to string.", [
["IN", "int", "Where to receive the int value to be converted."],
],[
["OUT", "string", "Int converted to string."],
],[
]);
entry.add(group);
var entry = new Entry("converter/rgb-to-byte", "Receives RGB packets and convert to bytes.", [
["IN", "rgb", "RGB to be decomposed."],
],[
["RED", "byte", "Byte value for red component."],
["GREEN", "byte", "Byte value for green component."],
["BLUE", "byte", "Byte value for blue component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/rgb-to-float", "Receives RGB packets and convert to float values.", [
["IN", "rgb", "RGB to be decomposed."],
],[
["RED", "float", "Float value for red component."],
["GREEN", "float", "Float value for green component."],
["BLUE", "float", "Float value for blue component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/rgb-to-int", "Receives RGB packets and convert to int values.", [
["IN", "rgb", "RGB to be decomposed."],
],[
["RED", "int", "Int value for red component."],
["GREEN", "int", "Int value for green component."],
["BLUE", "int", "Int value for blue component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/rgb-to-direction-vector", "Receives RGB packets and convert to direction vector ones.", [
["IN", "rgb", "RGB to be converted."],
],[
["OUT", "direction-vector", "Dimensional vector packet"],
],[
]);
entry.add(group);
var entry = new Entry("converter/direction-vector-to-byte", "Receives direction vector packets and converts to bytes.", [
["IN", "direction-vector", "direction vector to be decomposed."],
],[
["X", "byte", "Byte value for x component."],
["Y", "byte", "Byte value for y component."],
["Z", "byte", "Byte value for z component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/direction-vector-to-float", "Receives direction vector packets and converts to float values.", [
["IN", "direction-vector", "direction vector to be decomposed."],
],[
["X", "float", "Float value for x component."],
["Y", "float", "Float value for y component."],
["Z", "float", "Float value for z component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/direction-vector-to-int", "Receives direction vector packets and converts to RGB.", [
["IN", "direction-vector", "direction vector to be decomposed."],
],[
["X", "int", "Int value for x component."],
["Y", "int", "Int value for y component."],
["Z", "int", "Int value for z component."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-boolean", "Receives a string packet and convert it to boolean.", [
["IN", "string", "Where to receive the string to be converted."],
],[
["OUT", "boolean", "Send true if received string is 'true' and false if 'false'. It ignores case. If string is different from those, no packet is sent."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-byte", "Receives a string packet and convert it to byte.", [
["IN", "string", "Where to receive the string to be converted."],
],[
["OUT", "byte", "Send converted value on success or do not send anything if a valid byte can't be parsed. It's expected to be on base 16 and may include '0x' prefix."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-float", "Receives a string packet and convert it to float.", [
["IN", "string", "Where to receive the string to be converted."],
],[
["OUT", "float", "Send converted value on success or do not send anything if a valid number can't be parsed."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-empty", "Receives a string packet and send an empty packet.", [
["IN", "string", "Where to receive the string."],
],[
["OUT", "empty", "Send a packet when any string is received."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-int", "Receives a string packet and convert it to int.", [
["IN", "string", "Where to receive the string to be converted."],
],[
["OUT", "int", "Send converted value on success or do not send anything if a valid number can't be parsed."],
],[
]);
entry.add(group);
var entry = new Entry("converter/error", "Extracts error code and string from an error packet.", [
["IN", "error", "Where to receive the error to be converted."],
],[
["CODE", "int", "Code extracted from error packet"],
["MESSAGE", "string", "Message extracted from error packet"],
],[
]);
entry.add(group);
var entry = new Entry("converter/bits-to-byte", "Receives boolean packets and convert these bits to a byte.", [
["IN", "boolean", "Array of bits to turn into a byte. Index 0 is the least significant, 7 is the most"],
],[
["OUT", "byte", "Send the byte converted from bits received."],
],[
]);
entry.add(group);
var entry = new Entry("converter/string-to-blob", "Receives a string packet and convert to blob (sub-type SOL_BLOB_TYPE_DEFAULT).", [
["IN", "string", "Where to receive the string value to be converted."],
],[
["OUT", "blob", "Send blob with the contents of the string received in the port IN."],
],[
]);
entry.add(group);
var entry = new Entry("trigonometry/cosine", "Calculates the cosine of an angle.", [
["IN", "float", "Angle in radians."],
],[
["OUT", "float", "Cosine of angle."],
],[
]);
entry.add(group);
var entry = new Entry("trigonometry/degrees-to-radian", "Convert degrees to radians.", [
["IN", "float", "Angle in degrees."],
],[
["OUT", "float", "Angle in radian."],
],[
]);
entry.add(group);
var entry = new Entry("trigonometry/radian-to-degrees", "Convert radians to degrees.", [
["IN", "float", "Angle in radians."],
],[
["OUT", "float", "Angle in degrees."],
],[
]);
entry.add(group);
var entry = new Entry("trigonometry/sine", "Calculates the sine of an angle.", [
["IN", "float", "Angle in radians."],
],[
["OUT", "float", "Sine of angle."],
],[
]);
entry.add(group);
var entry = new Entry("trigonometry/tangent", "Calculates the tangent of an angle.", [
["IN", "float", "Angle in radians."],
],[
["OUT", "float", "Tangent of angle."],
],[
]);
entry.add(group);
var entry = new Entry("aio/reader", "Analog input reader. Default range is 0 - 4095 (12 bits) and can be changed by 'mask' options to support different chip manufacturers.", [
],[
["OUT", "int", "Measured value."],
],[
["pin", "int", "Pin", ""],
["mask", "int", "Valid bits mask. This mask is used to filter the valid bits from the data received from hardware (which is manufacturer dependent), therefore should not be used as a way to change the output range because the mask is applied to the least significant bits.", "{'step': 1, 'max': 'INT32_MAX', 'val': 12, 'min': 'INT32_MIN'}"],
["poll_timeout", "int", "Polling time in milliseconds. This option will take no effect if hardware interruptions for GPIO is supported by the underlying system. Use it if you know that you don't have those interruptions available.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1000, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("app/argc-argv", "Send command line arguments.", [
["IN", "int", "Argument index."],
],[
["OUT", "string", "Argument at position defined by packet received on port 'IN'."],
["ARGC", "int", "Number of arguments."],
],[
]);
entry.add(group);
var entry = new Entry("app/argv", "Send command line argument at specific position.", [
],[
["OUT", "string", "Command line argument at position defined by option 'index'."],
],[
["index", "int", "Argument position.", ""],
]);
entry.add(group);
var entry = new Entry("app/quit", "Quit the app.", [
["QUIT", "any", "Just quit with success code (0)."],
["CODE", "int", "Quit with code received by packet."],
["ERROR", "error", "Quit with error received by packet."],
],[
],[
]);
entry.add(group);
var entry = new Entry("platform", "Platform State", [
["TRIGGER", "any", "Triggers emission of current state."],
],[
["READY", "boolean", "True if platform is ready."],
],[
]);
entry.add(group);
var entry = new Entry("platform-service", "Platform Service State", [
["TRIGGER", "any", "Triggers emission of current service state."],
["START", "any", "Starts service when receives a signal"],
["STOP", "any", "Stops service when receives a signal"],
],[
["ACTIVE", "boolean", "True if platform service is active."],
],[
["service_name", "string", "the platform service name", ""],
]);
entry.add(group);
var entry = new Entry("float/addition", "Arithmetic addition operation with floats", [
["OPERAND", "float", "Thirty two ports for addition operation. Indexed from 0 to 31."],
],[
["OUT", "float", "Sum of values received on ports OPERAND[0] to OPERAND[31]."],
],[
]);
entry.add(group);
var entry = new Entry("float/division", "Arithmetic division operation with floats", [
["DIVIDEND", "float", "Recieves dividend value."],
["DIVISOR", "float", "Receives divisor value."],
],[
["OUT", "float", "Quotient from the division of DIVIDEND by DIVISOR."],
],[
]);
entry.add(group);
var entry = new Entry("float/modulo", "Arithmetic modulo operation with floats", [
["DIVIDEND", "float", "First port of modulo operation."],
["DIVISOR", "float", "Second port of modulo operation."],
],[
["OUT", "float", "Remainder from the division of DIVIDEND by DIVISOR."],
],[
]);
entry.add(group);
var entry = new Entry("float/multiplication", "Arithmetic multiplication operation with floats", [
["OPERAND", "float", "Thirty two ports for multiplication operation. Indexed from 0 to 31."],
],[
["OUT", "float", "Product of values received on ports OPERAND[0] to OPERAND[31]."],
],[
]);
entry.add(group);
var entry = new Entry("float/subtraction", "Arithmetic subtraction operation with floats", [
["MINUEND", "float", "Receives minuend value."],
["SUBTRAHEND", "float", "Receives subtrahend value."],
],[
["OUT", "float", "Difference of values received on ports MINUEND and SUBTRAHEND."],
],[
]);
entry.add(group);
var entry = new Entry("float/abs", "Calculates absolute value of a number.", [
["IN", "float", "Input number."],
],[
["OUT", "float", "Number's absolute value."],
],[
]);
entry.add(group);
var entry = new Entry("float/constrain", "Constrain value to it's range", [
["IN", "float", "Value to be constrained."],
],[
["OUT", "float", "Value constrained considering range"],
],[
["range", "float", "Range values (min, max, step). Used only if use_input_range is disabled.", "{'step': 'DBL_MIN', 'max': 1023, 'val': 0.0, 'min': 0}"],
["use_input_range", "boolean", "Use min, max and step values from package instead of options min, max and step. It's useful if you need to convert from many different sources to the same range and all of them inform these values correctly in each package.", "True"],
]);
entry.add(group);
var entry = new Entry("float/ln", "Calculates the natural logarithm of an input value.", [
["IN", "float", "Number to have natural logarithm calculated."],
],[
["OUT", "float", "The result of the natural logarithm operation."],
],[
]);
entry.add(group);
var entry = new Entry("float/map", "Map values to different range", [
["IN", "float", "Value to be converted."],
],[
["OUT", "float", "Value mapped considering input and output ranges"],
],[
["input_range", "float", "Input's range. Used only if use_input_range is disabled.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 0.0, 'min': '-DBL_MAX'}"],
["output_range", "float", "Output's range.", ""],
["use_input_range", "boolean", "Use min and max values from input package instead of option input_range. It's useful if you need to convert from many different sources to the same range and all of them inform these values correctly in each package.", "True"],
]);
entry.add(group);
var entry = new Entry("float/max", "Float Max", [
["IN", "float", "Two ports for max operation. Indexed from 0 to 1."],
],[
["OUT", "float", "Maximum value between IN[0] and IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/min", "Float Min", [
["IN", "float", "Two ports for min operation. Indexed from 0 to 1."],
],[
["OUT", "float", "Minimum value between IN[0] and IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/pow", "Calculates the value of a number raised to a power.", [
["BASE", "float", "Number to be raised."],
["EXPONENT", "float", "The power to which the base is raised."],
],[
["OUT", "float", "The result of the exponentiation."],
],[
]);
entry.add(group);
var entry = new Entry("float/sqrt", "Calculates the square root of a number.", [
["IN", "float", "Input number."],
],[
["OUT", "float", "Number's square root."],
],[
]);
entry.add(group);
var entry = new Entry("float/equal", "Check if an float is equal to other.", [
["IN", "float", "Two ports for equal comparison operation. Indexed from 0 to 1."],
],[
["OUT", "boolean", "True if value received on port IN[0] is equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/greater-or-equal", "Check if an float is greater than or equal to other.", [
["IN", "float", "Two ports for greater-or-equal comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is greater than or equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/greater", "Check if an float is greater than other.", [
["IN", "float", "Two ports for greater comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is greater than value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/less-or-equal", "Check if an float is less than or equal to other.", [
["IN", "float", "Two ports for less-or-equal comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is less than or equal to value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/less", "Check if an float is less than other.", [
["IN", "float", "Two ports for less comparison operation. Indexed from 0 to 1, and IN[0] being the left operand."],
],[
["OUT", "boolean", "True if value received on port IN[0] is less than value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/not-equal", "Check if an float is different from other.", [
["IN", "float", "Two ports for not-equal comparison operation. Indexed from 0 to 1"],
],[
["OUT", "boolean", "True if value received on port IN[0] is different from value received on port IN[1]."],
],[
]);
entry.add(group);
var entry = new Entry("float/filter", "Filter floats in range", [
["IN", "float", "Data input port."],
],[
["OUT", "float", "Outputs the same variable as the input if it's in range, nothing otherwise."],
],[
["min", "float", "Minimum value (inclusive)", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': '-DBL_MAX', 'min': '-DBL_MAX'}"],
["max", "float", "Maximum value (inclusive)", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 'DBL_MAX', 'min': '-DBL_MAX'}"],
["range_override", "boolean", "if true, the packet irange will have it's min and max changed to the min and max of this node.", "False"],
]);
entry.add(group);
var entry = new Entry("wave-generator/trapezoidal", "A waves generator node that, after each input tick, generates the next value of its defined function on its output port. That function is defined by the various options members it's got, and has the form that goes from a minimum to an maximum value. When at those two extreme values, it may hold (for a pulse or more) on them, before resuming the increment/decrement steps. Thus, it is capable of producing trapezoidal/triangular/sawtooth/square waves. This node won't send any initial packets after port connections are made on its output port solely -- it needs an explicit 'pulse' on its input port to produce packets.", [
["TICK", "any", "Iterate to next generator's function value, outputting a packet."],
],[
["OUT", "float", "The generator's current function value. This port won't send any initial packets after a connection is made. The node expects an explicit 'pulse' on its input port to produce packets."],
],[
["ticks_inc", "int", "In how many function iterations (ticks) it should go from max to min values. The value must be greater than or equal to 1 (which means go from max to min instantly). With this value, the node will calculate the 'increasing step' of the function for you.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
["max", "float", "The maximum value of the wave. This must be greater than min.", ""],
["ticks_dec", "int", "In how many function iterations (ticks) it should go from min to max values. The value must be greater than or equal to 1 (which means go from min to max instantly). With this value, the node will calculate the 'increasing step' of the function for you.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
["min", "float", "The minimum value of the wave. This must be less than max.", ""],
["tick_start", "int", "The starting point of the wave, in ticks (must be greater or equal to 0). Zero means to start at min value, when no ticks have happened yet. Use this to shift the starting point and overwrite the default behavior.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["ticks_at_max", "int", "The number of (extra) input ticks the wave will hold its output at max value when it reaches it. The value must be greater than or equal to 0.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["ticks_at_min", "int", "The number of (extra) input ticks the wave will hold its output at min value when it reaches it. The value must be greater than or equal to 0.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("wave-generator/sinusoidal", "A node that, after each input tick, generates the next value of the sine function on its output port. With fine tuning of it tick_start option, the cosine function can be achieved as well. A multiplier value can be supplied for the original [-1.0, 1.0] range, too. This node won't send any initial packets after port connections are made on its output port solely -- it needs an explicit 'pulse' on its input port to produce packets.", [
["TICK", "any", "Iterate to next generator's function value, outputting a packet."],
],[
["OUT", "float", "The generator's current function value. This port won't send any initial packets after a connection is made. The node expects an explicit 'pulse' on its input port to produce packets."],
],[
["ticks_per_period", "int", "In how many function iterations (ticks) it should go from the starting to the ending value of each function period (AKA function's resolution). The value must be greater than or equal to 1 (which means go from start to end in one step only), but note that waves very small values for this option tend to be useless.", ""],
["amplitude", "float", "The sine wave's amplitude. This must be a positive number, which will multiply the values in the pristine [-1.0, 1.0] range.", "{'step': 'DBL_MIN', 'max': 'DBL_MAX', 'val': 1.0, 'min': '-DBL_MAX'}"],
["tick_start", "int", "The starting point of the wave, in ticks (must be greater or equal to 0). Zero means to start at the beginning of the sive wave, when no ticks have happened yet. Use this to shift the starting point and overwrite the default behavior.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("float/classify", "Classifies input float according to one of float classifications: Not a Number, Infinite, Zero, Subnormal or Normal. It has OUT ports for each classification and sends input float to its classification OUT port.", [
["IN", "float", "Float to be classified."],
],[
["NAN", "float", "If input is NaN, it will go through this port."],
["INFINITE", "float", "If input is Infinite (either positive or negative), it will go through this port."],
["ZERO", "float", "If input is Zero, it will go through this port."],
["SUBNORMAL", "float", "If input is Subnormal, it will go through this port."],
["NORMAL", "float", "If input is Normal, it will go through this port."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/boolean", "Filter repeated boolean packets.", [
["IN", "boolean", "Where to receive the boolean packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "boolean", "Filtered boolean packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/byte", "Filter repeated byte packets.", [
["IN", "byte", "Where to receive the byte packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "byte", "Filtered byte packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/error", "Filter repeated error packets.", [
["IN", "error", "Where to receive the error packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded. They're forwared via 'ERROR' port."],
],[
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/float", "Filter repeated float packets.", [
["IN", "float", "Where to receive the float packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "float", "Filtered float packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/int", "Filter repeated int packets.", [
["IN", "int", "Where to receive the int packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "int", "Filtered int packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/rgb", "Filter repeated rgb packets.", [
["IN", "rgb", "Where to receive the rgb packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "rgb", "Filtered rgb packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/direction-vector", "Filter repeated direction vector packets.", [
["IN", "direction-vector", "Where to receive the direction vector packet to be filtered. If the packet is equal to the previously received one, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "direction-vector", "Filtered direction vector packets."],
],[
]);
entry.add(group);
var entry = new Entry("filter-repeated/string", "Filter repeated string packets.", [
["IN", "string", "Where to receive the string packet to be filtered. If the packet is equal to the previously received, it'll be dropped. Otherwise, it'll be forwarded."],
],[
["OUT", "string", "Filtered string packets."],
],[
]);
entry.add(group);
var entry = new Entry("timer", "Provides an empty packet on a timely manner", [
["RESET", "any", "Resets the timer without triggering a packet in the current iteration."],
["INTERVAL", "int", "Set the timer's tick interval in milliseconds."],
["ENABLED", "boolean", "Enables or disables the timer, based on the value of the packet received. When stopped, the timer will cease to emit packets from the OUT port. When enabled again, it does not resume from the point where it was stopped."],
],[
["OUT", "empty", "an empty packet when timer ticks."],
],[
["interval", "int", "Tick interval the timer will start with, in milliseconds.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1000, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("console", "Console Output", [
["IN", "any", "Prints the packet to console"],
],[
],[
["prefix", "string", "prefix messages with given string.", "None"],
["suffix", "string", "suffix messages with given string.", "None"],
["output_on_stdout", "boolean", "If true will output to stdout, otherwise stderr.", "True"],
["flush", "boolean", "If true will force flush after messages are printed.", "True"],
]);
entry.add(group);
var entry = new Entry("random/boolean", "Generate random booleans", [
["SEED", "int", "Seed value. Sequences are repeatable by using the same seed."],
["IN", "any", "Receives a pulse to generate a new random boolean."],
],[
["OUT", "boolean", "Random boolean. Do NOT use it for anything else than test purposes."],
],[
["seed", "int", "Seed value. Sequences are repeatable by using the same seed.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("random/byte", "Generate random bytes", [
["SEED", "int", "Seed value. Sequences are repeatable by using the same seed."],
["IN", "any", "Receives a pulse to generate a new random byte."],
],[
["OUT", "byte", "Random byte. Do NOT use it for anything else than test purposes."],
],[
["seed", "int", "Seed value. Sequences are repeatable by using the same seed.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("random/float", "Generate random float values", [
["SEED", "int", "Seed value. Sequences are repeatable by using the same seed."],
["IN", "any", "Receives a pulse to generate a new random float number."],
],[
["OUT", "float", "Random float value from 0 to INT32_MAX. Do NOT use it for anything else than test purposes."],
],[
["seed", "int", "Seed value. Sequences are repeatable by using the same seed.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("random/int", "Generate random int values", [
["SEED", "int", "Seed value. Sequences are repeatable by using the same seed."],
["IN", "any", "Receives a pulse to generate a new random int number."],
],[
["OUT", "int", "Random int value from 0 to INT32_MAX. Do NOT use it for anything else than test purposes."],
],[
["seed", "int", "Seed value. Sequences are repeatable by using the same seed.", "{'step': 1, 'max': 'INT32_MAX', 'val': 1, 'min': 'INT32_MIN'}"],
]);
entry.add(group);
var entry = new Entry("boolean/and", "Boolean And", [
["IN", "boolean", "Two ports for logical operation AND. Indexed from 0 to 1."],
],[
["OUT", "boolean", "True if both IN[0] and IN[1] are true."],
],[
]);
entry.add(group);
var entry = new Entry("boolean/counter", "Receives boolean packets from different connections and returns the number of them in TRUE and FALSE state", [
["IN", "boolean", "Input port"],
],[
["TRUE", "int", "Number of connections in TRUE state"],
["FALSE", "int", "Number of connections in FALSE state"],
],[
]);
entry.add(group);
var entry = new Entry("boolean/filter", "Receives a boolean packet and forwards it through the TRUE or FALSE ports depending on its value.", [
["IN", "boolean", "First port of AND operation."],
],[
["TRUE", "boolean", "Emits a packet with value TRUE when it recives a TRUE value on the IN port"],
["FALSE", "boolean", "Emits a packet with value FALSE when it recives a FALSE value on the IN port"],
],[
]);
entry.add(group);
var entry = new Entry("boolean/not", "Boolean Not", [
["IN", "boolean", "Where to receive the input of NOT operation."],
],[
["OUT", "boolean", "True if 'IN' is false, false otherwise."],
],[
]);
entry.add(group);
var entry = new Entry("boolean/or", "Boolean Or", [
["IN", "boolean", "Two ports for logical operation OR. Indexed from 0 to 1."],
],[
["OUT", "boolean", "True if either IN[0] or IN[1] is true."],
],[
]);
entry.add(group);
var entry = new Entry("boolean/toggle", "Receives an empty packet and toggle the boolean output.", [
["IN", "any", "Where to receive the toggle trigger"],
],[
["OUT", "boolean", "Current toggle state."],
],[
["initial_state", "boolean", "the initial state, defaults to false.", "False"],
]);
entry.add(group);
var entry = new Entry("boolean/xor", "Boolean XOR - exclusive or", [
["IN", "boolean", "Two ports for logical operation XOR. Indexed from 0 to 1."],
],[
["OUT", "boolean", "True whenever both inputs differ (one is true, the other is false). False if IN[0] and IN[1] are the same."],
],[
]);
entry.add(group);
var entry = new Entry("boolean/buffer", "Apply desired computation when buffer fills or timeout happens.", [
["IN", "boolean", "Input port."],
["TIMEOUT", "int", "Receives an int packet to set the timeout time to be used."],
["RESET", "any", "Reset buffer and timer to its initial state."],
],[
["OUT", "boolean", "Output port."],
],[
["samples", "int", "Number of samples that the buffer should hold.", ""],
["timeout", "int", "Timeout time in milliseconds. Default is zero which means that timeout is disabled.", "{'step': 1, 'max': 'INT32_MAX', 'val': 0, 'min': 'INT32_MIN'}"],
["operation", "string", "Operation to be applied in the buffer elements to compute the output.", "all_true"],
]);
entry.add(group);
var entry = new Entry("gpio/reader", "GPIO reader", [
],[
["OUT", "boolean", "GPIO reader, port out"],
],[
["pin", "int", "GPIO pin", ""],
["poll_timeout", "int", "Polling time", "{'step': 1, 'max': 'INT32_MAX', 'val': 1000, 'min': 'INT32_MIN'}"],
["active_low", "boolean", "Is active low", "False"],
["edge_rising", "boolean", "Is edge rising", "False"],
["edge_falling", "boolean", "Is edge falling", "False"],
["pull", "string", "up for pull up, down for pull down, none for no pull", "none"],
]);
entry.add(group);
var entry = new Entry("gpio/writer", "GPIO writer", [
["IN", "boolean", "GPIO writer, port in"],
],[
],[
["pin", "int", "GPIO pin", ""],
["active_low", "boolean", "Is active low", "False"],
]);
entry.add(group);
var entry = new Entry("wallclock/hour", "Provides int packets on a timely manner (after each system clock hour changes)", [
],[
["OUT", "int", "An int range packet when wallclock hour ticks."],
],[
]);
entry.add(group);
var entry = new Entry("wallclock/minute", "Provides int packets on a timely manner (after each system clock minute changes)", [
],[
["OUT", "int", "An int range packet when wallclock minute ticks."],
],[
]);
entry.add(group);
var entry = new Entry("wallclock/monthday", "Provides int packets on a timely manner (after each system clock month day changes)", [
],[
["OUT", "int", "An int range packet when wallclock month day ticks."],
],[
]);
entry.add(group);
var entry = new Entry("wallclock/second", "Provides int packets on a timely manner (after each system clock second changes)", [
],[
["OUT", "int", "An int range packet when wallclock second ticks."],
],[
]);
entry.add(group);
var entry = new Entry("wallclock/weekday", "Provides int packets on a timely manner (after each system clock week day changes)", [
],[
["OUT", "int", "An int range packet when wallclock week day ticks."],
],[
]);
entry.add(group);

    for(i = 0; i<createdGroups.length; i++)
    {
        var container = document.querySelector(createdGroups[i]);
        var iso = new Isotope(container,{
            itemSelector:'.Entry',
            layoutMode:'masonry',
            columnWidth:450
        });
    }
}
</script>

</head>
<body onLoad="init()">

  <div class="Container"  id="container">
    <img src="images/logo.jpg" class="Logo">
    <div class="Sidebar" id="sideBar"></div>
    <div class="Content" id="content"></div>
  </div>

</body>
</html>
